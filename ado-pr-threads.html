<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Azure DevOps PR Threads Viewer</title>
    <link rel="stylesheet" href="common.css">
    <style>
        .container.wide {
            padding: 0;
        }

        /* Sidebar layout */
        .page-layout {
            display: flex;
            gap: 0;
            height: calc(100vh - 50px);
        }

        .sidebar {
            width: 280px;
            min-width: 200px;
            max-width: 400px;
            background: #edebe9;
            border-radius: 0;
            padding: 20px;
            overflow-y: auto;
            flex-shrink: 0;
            position: relative;
        }

        .resize-handle {
            position: absolute;
            right: 0;
            top: 0;
            bottom: 0;
            width: 8px;
            cursor: col-resize;
            background: transparent;
            transition: background 0.2s;
        }

        .resize-handle:hover {
            background: rgba(0, 120, 212, 0.2);
        }

        .main-content {
            flex: 1;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        .results-container {
            flex: 1;
            overflow-y: auto;
            background: #f9f8f7;
        }

        /* Filter section styling */
        .filter-section {
            margin-bottom: 20px;
        }

        .filter-section:last-child {
            margin-bottom: 0;
        }

        .filter-section h4 {
            margin-bottom: 10px;
            margin-top: 0;
            color: #323130;
            font-size: 14px;
        }

        .filter-section select {
            width: 100%;
            padding: 8px;
            border: 1px solid #d1d1d1;
            border-radius: 0;
            background: white;
        }

        .filter-section input[type="text"] {
            width: 100%;
            padding: 8px;
            border: 1px solid #d1d1d1;
            border-radius: 0;
            font-size: 14px;
            box-sizing: border-box;
        }

        .filter-section input[type="text"]:focus {
            outline: none;
            border-color: #0078d4;
        }

        /* Status chips for vertical layout */
        .status-chips-vertical {
            display: flex;
            flex-direction: column;
            gap: 6px;
        }

        .status-chip {
            padding: 6px 12px;
            border: 1px solid #d1d1d1;
            border-radius: 0;
            background: white;
            color: #323130;
            font-size: 13px;
            cursor: pointer;
            transition: all 0.2s;
            user-select: none;
            text-align: left;
        }

        .status-chip:hover {
            border-color: #0078d4;
            background: #f3f9fd;
        }

        .status-chip.selected {
            background: #0078d4;
            color: white;
            border-color: #0078d4;
        }

        .checkbox-label {
            display: flex;
            align-items: center;
            padding: 8px;
            background: white;
            border-radius: 0;
            cursor: pointer;
            transition: background 0.2s;
            margin-top: 8px;
        }

        .checkbox-label:hover {
            background: #e1f3ff;
        }

        .checkbox-label input[type="checkbox"] {
            margin-right: 8px;
        }

        .filter-actions {
            display: flex;
            gap: 10px;
            margin-top: 20px;
        }

        .thread-count {
            font-size: 13px;
            color: #605e5c;
            margin-top: 15px;
            padding-top: 15px;
            border-top: 1px solid #d1d1d1;
        }

        /* PR info bar */
        .pr-info {
            background: #f9f8f7;
            padding: 15px;
            border-radius: 0;
            margin-bottom: 20px;
            display: flex;
            gap: 20px;
        }

        .pr-info-main {
            flex: 1;
            min-width: 0;
        }

        .pr-info-sidebar {
            flex: 0 0 auto;
            min-width: 200px;
            max-width: 280px;
        }

        .pr-info-sidebar .avatars-section {
            margin-top: 0;
        }

        .pr-info-sidebar .avatars-section + .avatars-section {
            margin-top: 10px;
        }

        .thread-container {
            margin-bottom: 30px;
            padding: 20px;
            background: #f9f8f7;
        }

        .thread {
            border: 1px solid #e1dfdd;
            border-radius: 0;
            margin-bottom: 20px;
            overflow: hidden;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }

        .thread-status-change {
            display: inline-flex;
            align-items: center;
            gap: 8px;
            margin-left: 10px;
        }

        .thread-status-change select {
            padding: 4px 8px;
            border: 1px solid #d1d1d1;
            border-radius: 0;
            font-size: 12px;
            background: white;
        }

        /* PR Status and Actions inline */
        #prStatusBadges {
            display: inline-flex;
            align-items: center;
        }

        #prStatusActions {
            display: inline-block;
            vertical-align: middle;
            margin-left: 8px;
            margin-right: 6px;
        }

        /* PR Action Dropdown */
        .pr-action-select {
            appearance: none;
            -webkit-appearance: none;
            -moz-appearance: none;
            padding: 4px 24px 4px 10px;
            border: 1px solid #0078d4;
            border-radius: 2px;
            font-size: 12px;
            font-weight: 600;
            color: #0078d4;
            background: white url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='12' height='12' viewBox='0 0 12 12'%3E%3Cpath fill='%230078d4' d='M2 4l4 4 4-4z'/%3E%3C/svg%3E") no-repeat right 6px center;
            cursor: pointer;
            vertical-align: middle;
        }

        .pr-action-select:hover {
            background-color: #e1f3ff;
            border-color: #106ebe;
        }

        .pr-action-select:focus {
            outline: none;
            border-color: #106ebe;
            box-shadow: 0 0 0 1px #106ebe;
        }

        .pr-action-select:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        /* Auto-complete button */
        .auto-complete-btn {
            padding: 4px 10px;
            border: 1px solid #0078d4;
            border-radius: 2px;
            font-size: 12px;
            font-weight: 600;
            color: #0078d4;
            background: white;
            cursor: pointer;
            display: inline-flex;
            align-items: center;
            gap: 4px;
            white-space: nowrap;
        }

        .auto-complete-btn:hover {
            background-color: #e1f3ff;
            border-color: #106ebe;
        }

        .auto-complete-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .auto-complete-btn.active {
            background: #0078d4;
            color: white;
        }

        .auto-complete-btn.active:hover {
            background: #106ebe;
        }

        /* New Thread Button */
        .new-thread-container {
            padding: 20px;
            background: #f9f8f7;
        }

        .new-thread-btn {
            padding: 8px 16px;
            background: #0078d4;
            color: white;
            border: none;
            border-radius: 2px;
            cursor: pointer;
            font-size: 14px;
            display: inline-flex;
            align-items: center;
            gap: 6px;
        }

        .new-thread-btn:hover {
            background: #106ebe;
        }

        .new-thread-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        /* Inline Comment Editor */
        .comment-editor {
            background: #fff;
            border: 1px solid #0078d4;
            border-radius: 2px;
            padding: 12px;
            margin-top: 8px;
        }

        .comment-editor textarea {
            width: 100%;
            min-height: 80px;
            padding: 8px;
            border: 1px solid #d1d1d1;
            border-radius: 2px;
            font-family: inherit;
            font-size: 13px;
            resize: vertical;
            box-sizing: border-box;
        }

        .comment-editor textarea:focus {
            outline: none;
            border-color: #0078d4;
        }

        .comment-editor-actions {
            display: flex;
            justify-content: flex-end;
            gap: 8px;
            margin-top: 8px;
        }

        .comment-editor-actions button {
            padding: 6px 12px;
            border-radius: 2px;
            font-size: 13px;
            cursor: pointer;
        }

        .comment-editor-actions .btn-save {
            background: #0078d4;
            color: white;
            border: 1px solid #0078d4;
        }

        .comment-editor-actions .btn-save:hover {
            background: #106ebe;
        }

        .comment-editor-actions .btn-save:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .comment-editor-actions .btn-cancel {
            background: white;
            color: #323130;
            border: 1px solid #d1d1d1;
        }

        .comment-editor-actions .btn-cancel:hover {
            background: #f3f2f1;
        }

        /* Comment Action Buttons */
        .comment-actions {
            display: inline-flex;
            gap: 4px;
            margin-left: auto;
        }

        .comment-action-btn {
            padding: 4px 6px;
            font-size: 12px;
            color: #605e5c;
            background: transparent;
            border: 1px solid transparent;
            border-radius: 2px;
            cursor: pointer;
            display: inline-flex;
            align-items: center;
            justify-content: center;
        }

        .comment-action-btn svg {
            width: 14px;
            height: 14px;
            fill: currentColor;
        }

        .comment-action-btn:hover {
            color: #0078d4;
            background: #f3f2f1;
            border-color: #d1d1d1;
        }

        .comment-action-btn.delete:hover {
            color: #a4262c;
        }

        /* Thread controls in first comment header (after edit/delete buttons) */
        .thread-controls {
            display: inline-flex;
            align-items: center;
            gap: 8px;
        }

        .thread-link {
            font-size: 13px;
            color: #0078d4;
            text-decoration: none;
        }

        .thread-link:hover {
            text-decoration: underline;
        }

        /* Thread Reply Button */
        .thread-reply-btn {
            padding: 6px 12px;
            margin: 8px 15px 12px;
            font-size: 13px;
            color: #0078d4;
            background: transparent;
            border: 1px solid #0078d4;
            border-radius: 2px;
            cursor: pointer;
        }

        .thread-reply-btn:hover {
            background: #e1f3ff;
        }

        /* Reply editor container at bottom of thread */
        .thread-reply-container {
            padding: 0 15px 15px;
            background: #ffffff;
        }

        /* New thread form */
        .new-thread-form {
            background: white;
            border: 1px solid #e1dfdd;
            border-radius: 0;
            padding: 15px;
            margin-top: 10px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }

        .new-thread-form h4 {
            margin: 0 0 12px 0;
            color: #323130;
        }

        /* PR Action Modal */
        .pr-modal-body-loading {
            text-align: center;
            padding: 30px;
            color: #605e5c;
        }

        .blocker-list {
            list-style: none;
            padding: 0;
            margin: 15px 0;
        }

        .blocker-list li {
            padding: 10px 12px;
            margin-bottom: 8px;
            border-radius: 0;
            display: flex;
            align-items: center;
            gap: 10px;
            font-size: 13px;
        }

        .blocker-list li.blocker-conflict {
            background: #fff4ce;
            color: #8a6d3b;
            border-left: 3px solid #ffb900;
        }

        .blocker-list li.blocker-policy {
            background: #fde7e9;
            color: #d13438;
            border-left: 3px solid #d13438;
        }

        .blocker-list li.blocker-running {
            background: #e1f3ff;
            color: #0078d4;
            border-left: 3px solid #0078d4;
        }

        .merge-option-group {
            margin-bottom: 15px;
        }

        .merge-option-group label {
            display: block;
            margin-bottom: 8px;
            font-weight: 600;
        }

        .merge-option-group select,
        .merge-option-group textarea {
            width: 100%;
            padding: 8px;
            border: 1px solid #d1d1d1;
            border-radius: 0;
            font-size: 13px;
            font-family: inherit;
        }

        .merge-option-group textarea {
            min-height: 80px;
            resize: vertical;
        }

        .merge-option-checkbox {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-top: 10px;
            font-weight: normal;
        }

        .merge-option-checkbox input[type="checkbox"] {
            width: auto;
        }

        .pr-action-modal-footer {
            margin-top: 20px;
            display: flex;
            justify-content: flex-end;
            gap: 10px;
            padding-top: 15px;
            border-top: 1px solid #edebe9;
        }

        .thread-checkbox {
            margin-right: 10px;
        }

        .bulk-actions {
            background: #fff4ce;
            border-left: 4px solid #ffb900;
            padding: 15px;
            border-radius: 0;
            margin-bottom: 20px;
            display: none;
        }

        .bulk-actions.show {
            display: block;
        }

        .bulk-actions-buttons {
            display: flex;
            gap: 10px;
            align-items: center;
            flex-wrap: wrap;
            margin-top: 10px;
        }

        .bulk-actions-buttons select {
            padding: 8px;
            border: 1px solid #d1d1d1;
            border-radius: 0;
        }

        .comment {
            padding: 12px 15px;
            border-bottom: 1px solid #edebe9;
            background: #ffffff;
        }

        .comment:last-child {
            border-bottom: none;
        }

        .comment.system-comment {
            background: #f8f8f8;
            border-left: 3px solid #a19f9d;
        }

        .comment.code-change-comment {
            background: #fff9e6;
            border-left: 3px solid #ffb900;
        }

        .comment-type-badge {
            display: inline-block;
            padding: 2px 8px;
            border-radius: 12px;
            font-size: 11px;
            font-weight: 600;
            margin-left: 8px;
            text-transform: uppercase;
        }

        .comment-type-system {
            background: #e1dfdd;
            color: #605e5c;
        }

        .comment-type-code-change {
            background: #fff4ce;
            color: #8a6d3b;
        }

        .comment-type-text {
            background: #e1f3ff;
            color: #004578;
        }

        .comment-type-deleted {
            background: #fde7e9;
            color: #a4262c;
        }

        .comment-header {
            margin-bottom: 8px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-wrap: wrap;
            gap: 8px;
        }

        .comment-author-info {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .comment-author-info .avatar-wrapper {
            --avatar-size: 28px;
        }

        .comment-date {
            color: #605e5c;
            font-size: 13px;
        }

        .comment-link {
            text-decoration: none;
            margin-left: 8px;
            display: inline-flex;
            align-items: center;
        }

        .comment-link svg {
            width: 16px;
            height: 16px;
            fill: #0078d4;
        }

        .comment-link:hover svg {
            filter: drop-shadow(0 0 3px #0078d4);
        }

        .code-links {
            display: flex;
            align-items: center;
        }

        .iteration-range {
            font-size: 11px;
            color: #605e5c;
            margin-left: 8px;
        }

        .comment-content {
            color: #323130;
            white-space: pre-wrap;
            word-wrap: break-word;
        }

        .comment-content strong {
            font-weight: 700;
            color: #323130;
        }

        .comment-content em {
            font-style: italic;
            color: #323130;
        }

        .comment-content a {
            color: #0078d4;
            text-decoration: none;
        }

        .comment-content a:hover {
            text-decoration: underline;
        }

        .comment-content img {
            max-width: 100%;
            height: auto;
            border: 1px solid #d1d1d1;
            border-radius: 0;
            margin: 5px 5px 5px 0;
            display: inline-block;
            vertical-align: middle;
        }

        .thread-context {
            background: #fff4ce;
            padding: 8px 12px;
            margin-bottom: 10px;
            border-left: 3px solid #ffb900;
            font-size: 13px;
        }

        .file-preview {
            background: #f8f8f8;
            border: 1px solid #d1d1d1;
            border-radius: 0;
        }

        .file-preview-header {
            padding: 8px 12px;
            background: #fff4ce;
            border-left: 3px solid #ffb900;
            cursor: pointer;
            font-size: 13px;
            color: #323130;
            font-weight: normal;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .file-preview-header:hover {
            background: #ffecb3;
        }

        .file-preview-header span:first-child {
            color: #0078d4;
            font-weight: 600;
        }

        .file-preview-content {
            display: none;
            padding: 0;
            max-height: 400px;
            overflow-y: auto;
        }

        .file-preview-content.show {
            display: block;
        }

        .file-preview-content pre {
            margin: 0;
            padding: 12px;
            background: #f8f8f8;
            color: #323130;
            font-family: monospace;
            font-size: 12px;
            line-height: 1.5;
            overflow-x: auto;
        }

        .file-preview-line {
            display: flex;
            gap: 10px;
        }

        .file-preview-line-number {
            color: #999;
            text-align: right;
            min-width: 40px;
            user-select: none;
        }

        .file-preview-line-content {
            flex: 1;
        }

        /* Diff styles */
        .diff-line {
            display: flex;
            font-family: monospace;
            font-size: 12px;
            line-height: 1.5;
            position: relative;
        }

        .diff-line-number {
            color: #6e7681;
            text-align: right;
            width: 40px;
            min-width: 40px;
            padding: 0 4px;
            user-select: none;
            background: rgba(0, 0, 0, 0.05);
            box-sizing: border-box;
        }

        /* Gutter avatar for collapsed thread — overlays the first line-number column */
        .diff-gutter-avatar {
            position: absolute;
            left: 10px;
            top: 50%;
            transform: translateY(-50%);
            width: 20px;
            height: 20px;
            border-radius: 50%;
            cursor: pointer;
            z-index: 2;
            border: 2px solid #fff;
            box-shadow: 0 1px 3px rgba(0,0,0,0.3);
        }
        .diff-gutter-avatar img {
            width: 100%;
            height: 100%;
            border-radius: 50%;
            display: block;
        }
        .diff-gutter-avatar .gutter-avatar-placeholder {
            width: 100%;
            height: 100%;
            border-radius: 50%;
            background: #0078d4;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        .diff-gutter-avatar .gutter-avatar-placeholder svg {
            width: 12px;
            height: 12px;
            fill: #fff;
        }

        .diff-indicator {
            width: 20px;
            text-align: center;
            font-weight: bold;
            user-select: none;
        }

        .diff-content {
            flex: 1;
            padding-left: 8px;
            white-space: pre;
            min-width: 0;
        }

        .diff-unchanged {
            background: #f6f8fa;
            color: #24292f;
        }

        .diff-added {
            background: #e6ffec;
            color: #1a7f37;
        }

        .diff-added .diff-indicator {
            color: #1a7f37;
        }

        .diff-removed {
            background: #ffebe9;
            color: #cf222e;
        }

        .diff-removed .diff-indicator {
            color: #cf222e;
        }

        /* Highlighted diff lines in a thread's code range */
        .diff-line-commented {
            background: #fff3cd !important;
            box-shadow: inset 3px 0 0 #e8a517;
        }
        .diff-line-commented.diff-added {
            background: #d4f0b4 !important;
            box-shadow: inset 3px 0 0 #6a9e3a;
        }
        .diff-line-commented.diff-removed {
            background: #f5c2c0 !important;
            box-shadow: inset 3px 0 0 #c44f4f;
        }

        /* Side-by-side diff mode */
        .sbs-row {
            display: flex;
            font-family: monospace;
            font-size: 12px;
            line-height: 1.5;
            position: relative;
        }
        .sbs-row.diff-unchanged .sbs-left,
        .sbs-row.diff-unchanged .sbs-right {
            background: #f6f8fa;
            color: #24292f;
        }
        .sbs-left, .sbs-right {
            flex: 1;
            display: flex;
            min-width: 0;
            flex-basis: 50%;
            overflow-x: hidden;
        }
        .sbs-left {
            border-right: 1px solid #d8dee4;
        }
        .sbs-left .diff-content, .sbs-right .diff-content {
            flex: 1;
            padding-left: 8px;
            white-space: pre;
        }
        .sbs-left .diff-line-number, .sbs-right .diff-line-number {
            color: #6e7681;
            text-align: right;
            width: 40px;
            min-width: 40px;
            padding: 0 4px;
            user-select: none;
            background: #f0f0f0;
            box-sizing: border-box;
            position: relative;
            z-index: 1;
        }
        .sbs-left.diff-removed {
            background: #ffebe9;
            color: #cf222e;
        }
        .sbs-left.diff-removed .diff-line-number {
            background: #ffd7d5;
        }
        .sbs-right.diff-added {
            background: #e6ffec;
            color: #1a7f37;
        }
        .sbs-right.diff-added .diff-line-number {
            background: #ccffd8;
        }
        .sbs-empty {
            background: repeating-linear-gradient(
                -45deg,
                #f6f8fa,
                #f6f8fa 4px,
                #eef0f2 4px,
                #eef0f2 8px
            );
        }
        .sbs-empty .diff-line-number {
            visibility: hidden;
        }
        /* Commented-line highlights for SBS */
        .sbs-left.diff-line-commented,
        .sbs-right.diff-line-commented {
            background: #fff3cd !important;
            box-shadow: inset 3px 0 0 #e8a517;
        }
        .sbs-left.diff-line-commented .diff-line-number,
        .sbs-right.diff-line-commented .diff-line-number {
            background: #ffe9a0;
        }
        .sbs-left.diff-line-commented.diff-removed {
            background: #f5c2c0 !important;
            box-shadow: inset 3px 0 0 #c44f4f;
        }
        .sbs-left.diff-line-commented.diff-removed .diff-line-number {
            background: #eaacaa;
        }
        .sbs-right.diff-line-commented.diff-added {
            background: #d4f0b4 !important;
            box-shadow: inset 3px 0 0 #6a9e3a;
        }
        .sbs-right.diff-line-commented.diff-added .diff-line-number {
            background: #b8e098;
        }
        /* SBS thread positioning */
        .sbs-thread-row {
            display: flex;
        }
        .sbs-thread-side {
            flex: 1;
            min-width: 0;
        }
        .sbs-thread-side.sbs-thread-left {
            border-right: 1px solid #d8dee4;
        }
        .sbs-thread-spacer {
            flex: 1;
            min-width: 0;
            background: repeating-linear-gradient(
                -45deg,
                #f6f8fa,
                #f6f8fa 4px,
                #eef0f2 4px,
                #eef0f2 8px
            );
        }
        .sbs-thread-row .sbs-thread-spacer.sbs-thread-left {
            border-right: 1px solid #d8dee4;
        }
        .sbs-thread-side .inline-thread {
            border-right: none;
        }
        /* SBS gutter avatar positioning */
        .diff-lines-sbs .diff-gutter-avatar.gutter-left {
            left: 10px;
        }
        .diff-lines-sbs .diff-gutter-avatar.gutter-right {
            left: calc(50% + 10px);
        }
        .sbs-scroll-track {
            flex-shrink: 0;
            height: 14px;
            background: #f0f0f0;
            border-top: 1px solid #e1dfdd;
            position: relative;
            cursor: pointer;
        }
        .sbs-scroll-thumb {
            position: absolute;
            top: 2px;
            height: 10px;
            min-width: 30px;
            background: #a0a0a0;
            border-radius: 5px;
            cursor: grab;
        }
        .sbs-scroll-thumb:hover {
            background: #888;
        }
        .sbs-scroll-thumb.dragging {
            background: #666;
            cursor: grabbing;
        }
        .diff-display-mode-bar {
            display: flex;
            gap: 0;
            margin-left: 12px;
        }

        /* Inline thread block inserted between diff lines */
        .inline-thread {
            border: 1px solid #d1d5db;
            border-left: 3px solid #0078d4;
            background: #fff;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            font-size: 13px;
            white-space: normal;
        }
        .inline-thread .comment {
            padding: 10px 14px;
            border-bottom: 1px solid #edebe9;
        }
        .inline-thread .comment:last-of-type {
            border-bottom: none;
        }
        .inline-thread .inline-thread-header {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 6px 14px;
            background: #f3f6fc;
            border-bottom: 1px solid #d1d5db;
            font-size: 12px;
        }
        .inline-thread .thread-reply-container {
            padding: 0 14px 10px;
        }
        .inline-thread .comment-header {
            margin-bottom: 6px;
        }
        .inline-thread .comment-content {
            font-size: 13px;
        }
        .inline-thread .comment-editor {
            margin-top: 4px;
        }

        /* Focused: highlight when navigated to from file tree, fades out */
        .inline-thread.focused {
            outline: 2px solid #0078d4;
            outline-offset: -2px;
            box-shadow: 0 0 0 4px rgba(0, 120, 212, 0.15);
            animation: thread-focus-fade 5s ease-out forwards;
        }
        @keyframes thread-focus-fade {
            0%, 40% { outline-color: #0078d4; box-shadow: 0 0 0 4px rgba(0, 120, 212, 0.15); }
            100% { outline-color: transparent; box-shadow: 0 0 0 4px transparent; }
        }

        /* Collapsed: thread block is fully hidden, avatar in gutter shows instead */
        .inline-thread.collapsed {
            display: none;
        }

        /* Thread from a different iteration — dimmed */
        .inline-thread-outdated {
            opacity: 0.55;
        }

        .api-link {
            color: #0078d4;
            text-decoration: none;
            font-size: 12px;
            font-family: monospace;
            background: #f9f8f7;
            padding: 4px 8px;
            border-radius: 0;
            display: inline-block;
            margin-top: 5px;
        }

        .api-link:hover {
            background: #e1dfdd;
            text-decoration: underline;
        }

        /* Reviewer/Author avatars section */
        .avatars-section {
            margin-top: 15px;
            padding: 12px;
            background: #f8f8f8;
            border-radius: 0;
        }

        .avatars-section h4 {
            margin: 0 0 10px 0;
            font-size: 14px;
            color: #323130;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .avatars-section .avatars-container {
            gap: 8px;
        }

        .avatars-section .avatar-wrapper {
            --avatar-size: 36px;
        }

        .avatars-section .avatar,
        .avatars-section .avatar-fallback,
        .avatars-section .avatar-placeholder {
            border-width: 2px;
            border-color: #e1dfdd;
        }

        /* Vote badges */
        .vote-badge {
            position: absolute;
            bottom: -3px;
            right: -3px;
            width: 16px;
            height: 16px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 10px;
            font-weight: bold;
            color: white;
            border: 2px solid white;
            z-index: 5;
        }

        .vote-badge.vote-approved {
            background: #107c10;
        }

        .vote-badge.vote-approved-suggestions {
            background: #498205;
        }

        .vote-badge.vote-wait {
            background: #d83b01;
        }

        .vote-badge.vote-rejected {
            background: #a4262c;
        }

        .vote-badge.vote-no-vote {
            background: #8a8886;
        }

        /* Thread count badge */
        .thread-badge {
            position: absolute;
            top: -5px;
            right: -5px;
            min-width: 18px;
            height: 18px;
            border-radius: 50%;
            background: #d83b01;
            color: white;
            font-size: 11px;
            font-weight: bold;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 0 4px;
            border: 2px solid white;
            z-index: 5;
        }

        .avatar-wrapper:hover .vote-badge,
        .avatar-wrapper:hover .thread-badge,
        .avatar-wrapper:hover .author-badge {
            transform: scale(1.15);
            z-index: 11;
        }

        /* PR Author badge */
        .author-badge {
            position: absolute;
            top: -5px;
            left: -5px;
            width: 18px;
            height: 18px;
            border-radius: 50%;
            background: #ffb900;
            display: flex;
            align-items: center;
            justify-content: center;
            border: 1px solid white;
            z-index: 5;
        }

        .author-badge svg {
            width: 10px;
            height: 10px;
        }

        .comment-author-info .author-badge {
            width: 12px;
            height: 12px;
            top: -3px;
            left: -3px;
        }

        .comment-author-info .author-badge svg {
            width: 7px;
            height: 7px;
        }

        /* Reviewer Management */
        .reviewer-avatar-wrapper {
            position: relative;
            display: inline-block;
        }

        .no-reviewers {
            color: #605e5c;
            font-size: 13px;
            font-style: italic;
        }

        .add-reviewer-inline-btn {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            width: 18px;
            height: 18px;
            border-radius: 50%;
            border: 1px solid #d1d1d1;
            background: transparent;
            color: #605e5c;
            cursor: pointer;
            font-size: 14px;
            font-weight: bold;
            padding: 0;
        }

        .add-reviewer-inline-btn:hover {
            border-color: #0078d4;
            color: #0078d4;
            background: #e1f3ff;
        }

        .inline-reviewer-search {
            margin: 8px 0;
        }

        .inline-reviewer-search input {
            width: 100%;
            padding: 6px 8px;
            border: 1px solid #d1d1d1;
            border-radius: 4px;
            font-size: 12px;
        }

        .inline-reviewer-search input:focus {
            outline: none;
            border-color: #0078d4;
        }

        .inline-search-results {
            max-height: 150px;
            overflow-y: auto;
            margin-top: 4px;
        }

        .inline-search-result {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 6px 8px;
            cursor: pointer;
            border-radius: 4px;
            font-size: 12px;
        }

        .inline-search-result:hover {
            background: #e1f3ff;
        }

        .inline-search-result .result-name {
            font-weight: 500;
        }

        .inline-search-result .result-email {
            color: #605e5c;
            font-size: 11px;
        }

        /* @mention autocomplete dropdown */
        .comment-editor {
            position: relative;
        }

        .mention-dropdown {
            position: absolute;
            left: 0;
            right: 0;
            bottom: 100%;
            margin-bottom: 2px;
            background: white;
            border: 1px solid #d1d1d1;
            border-radius: 4px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.15);
            max-height: 180px;
            overflow-y: auto;
            z-index: 1000;
            display: none;
        }

        .mention-dropdown.active {
            display: block;
        }

        .mention-result {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 6px 8px;
            cursor: pointer;
            font-size: 12px;
        }

        .mention-result:hover,
        .mention-result.selected {
            background: #e1f3ff;
        }

        .mention-result .result-name {
            font-weight: 500;
        }

        .mention-result .result-email {
            color: #605e5c;
            font-size: 11px;
        }

        .mention-hint {
            padding: 6px 8px;
            color: #605e5c;
            font-size: 11px;
        }

        .reviewer-dropdown {
            display: none;
            position: absolute;
            top: 100%;
            left: 50%;
            transform: translateX(-50%);
            background: white;
            border: 1px solid #d1d1d1;
            border-radius: 4px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.15);
            z-index: 100;
            min-width: 140px;
            margin-top: 4px;
        }

        .reviewer-dropdown.open {
            display: block;
        }

        .reviewer-avatar-wrapper {
            cursor: pointer;
        }

        .reviewer-dropdown-item {
            display: block;
            width: 100%;
            padding: 8px 12px;
            border: none;
            background: none;
            text-align: left;
            cursor: pointer;
            font-size: 12px;
            color: #323130;
            white-space: nowrap;
        }

        .reviewer-dropdown-item:hover {
            background: #f3f2f1;
        }

        .reviewer-dropdown-item.danger {
            color: #a4262c;
        }

        .reviewer-dropdown-item.danger:hover {
            background: #fde7e9;
        }


        /* PR title avatar */
        .pr-title-avatar {
            --avatar-size: 28px;
            vertical-align: middle;
            margin-right: 8px;
        }

        /* Branch info */
        .branch-info {
            margin: 8px 0;
        }

        .branch-info code {
            background: #f9f8f7;
            padding: 2px 6px;
            border-radius: 0;
            font-family: monospace;
            font-size: 13px;
        }

        /* Checks section */
        .work-items-section {
            margin-top: 15px;
            padding: 12px;
            background: #f8f8f8;
            border-radius: 0;
        }

        .work-items-section h4 {
            margin: 0 0 10px 0;
            font-size: 14px;
            color: #323130;
        }

        .work-item-entry {
            margin-bottom: 4px;
        }

        .work-item-entry a {
            display: flex;
            align-items: center;
            gap: 6px;
            padding: 4px 6px;
            border-radius: 3px;
            text-decoration: none;
            color: #323130;
            font-size: 13px;
        }

        .work-item-entry a:hover {
            background: #e8e8e8;
        }

        .work-item-id {
            color: #0078d4;
            font-weight: 600;
            flex-shrink: 0;
        }

        .work-item-title {
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }

        .work-item-icon {
            flex-shrink: 0;
            font-size: 14px;
        }

        .checks-section {
            margin-top: 15px;
            padding: 12px;
            background: #f8f8f8;
            border-radius: 0;
        }

        .checks-section h4 {
            margin: 0 0 12px 0;
            font-size: 14px;
            color: #323130;
        }

        .checks-loading {
            color: #605e5c;
            font-size: 13px;
        }

        .check-group {
            margin-bottom: 12px;
        }

        .check-group:last-child {
            margin-bottom: 0;
        }

        .check-group-header {
            font-weight: 600;
            font-size: 13px;
            margin-bottom: 6px;
            padding: 4px 8px;
            border-radius: 0;
            background: #e1dfdd;
            color: #323130;
        }

        .check-group-header.status-indicator-error {
            background: #fde7e9;
            color: #d13438;
        }

        .check-group-header.status-indicator-pending {
            background: #e1f3ff;
            color: #0078d4;
        }

        .check-list {
            list-style: none;
            margin: 0;
            padding: 0;
        }

        .check-item {
            display: flex;
            align-items: flex-start;
            gap: 6px;
            padding: 4px 0;
            font-size: 12px;
            color: #323130;
            border-bottom: 1px solid #edebe9;
        }

        .check-item:last-child {
            border-bottom: none;
        }

        .check-item code {
            font-size: 11px;
            background: #fff;
            padding: 2px 6px;
            border-radius: 0;
            word-break: break-all;
        }

        .check-item a {
            color: #0078d4;
            text-decoration: none;
        }

        .check-item a:hover {
            text-decoration: underline;
        }

        .check-icon {
            flex-shrink: 0;
            width: 14px;
            text-align: center;
        }

        .check-item.status-indicator-success .check-icon {
            color: #107c10;
        }

        .check-item.status-indicator-error .check-icon {
            color: #d13438;
        }

        .check-item.status-indicator-pending .check-icon {
            color: #0078d4;
        }

        .check-item.status-indicator-expired {
            background-color: rgba(202, 140, 0, 0.1);
        }

        .check-item.status-indicator-not-triggered {
            background-color: rgba(138, 136, 134, 0.1);
        }

        .check-item-note {
            font-size: 12px;
            color: #605e5c;
            font-style: italic;
            padding: 4px 0;
        }

        .check-extra {
            color: #8a6d3b;
            font-size: 11px;
            font-style: italic;
        }

        /* Build status SVG icons */
        .build-status-icon {
            vertical-align: middle;
        }

        .build-status-running {
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            from { transform: rotate(0deg); }
            to { transform: rotate(360deg); }
        }

        .queue-build-btn {
            background: transparent;
            border: none;
            padding: 0;
            margin-left: auto;
            cursor: pointer;
            flex-shrink: 0;
            display: flex;
            align-items: center;
            justify-content: center;
            outline: none;
            -webkit-appearance: none;
            appearance: none;
        }

        .queue-build-btn:hover,
        .queue-build-btn:focus,
        .queue-build-btn:active {
            background: transparent;
            outline: none;
            box-shadow: none;
        }

        .queue-build-btn:hover svg {
            filter: drop-shadow(0 0 3px #0078d4);
        }

        .queue-build-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        /* Right sidebar */
        .right-sidebar {
            width: 300px;
            min-width: 200px;
            max-width: 500px;
            background: #edebe9;
            padding: 20px;
            overflow-y: auto;
            flex-shrink: 0;
            position: relative;
        }

        /* Left-edge resize handle for right sidebar */
        .resize-handle-left {
            position: absolute;
            left: 0;
            top: 0;
            bottom: 0;
            width: 8px;
            cursor: col-resize;
            background: transparent;
            transition: background 0.2s;
        }

        .resize-handle-left:hover {
            background: rgba(0, 120, 212, 0.2);
        }

        /* Vertical stats layout for right sidebar */
        .right-sidebar .stats {
            flex-direction: column;
            gap: 8px;
        }

        .right-sidebar .stat {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 8px 12px;
            background: white;
        }

        .right-sidebar .stat-value {
            font-size: 18px;
            order: 2;
        }

        .right-sidebar .stat-label {
            font-size: 13px;
            order: 1;
        }

        /* Sticky PR title bar */
        #pr-title-bar-container {
            position: sticky;
            top: 0;
            z-index: 10;
        }

        .pr-title-bar {
            background: #f9f8f7;
            padding: 12px 20px;
        }

        .pr-title-bar h2 {
            margin: 0;
        }

        /* PR header details (non-sticky) */
        .pr-header {
            background: #f9f8f7;
            padding: 4px 20px 20px 20px;
        }

        /* Description card */
        .description-card {
            border: 1px solid #e1dfdd;
            margin-top: 15px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }

        .description-card-header {
            padding: 10px 15px;
            font-weight: 600;
            font-size: 14px;
            color: #323130;
            background: white;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .description-edit-btn {
            background: none;
            border: 1px solid transparent;
            cursor: pointer;
            padding: 2px 6px;
            border-radius: 3px;
            color: #605e5c;
            font-size: 13px;
        }

        .description-card-content .comment-editor textarea {
            min-height: 160px;
        }

        .description-preview {
            margin-top: 10px;
            border: 1px solid #e1dfdd;
            border-radius: 2px;
        }

        .description-preview-header {
            padding: 6px 10px;
            font-size: 12px;
            font-weight: 600;
            color: #605e5c;
            background: #faf9f8;
            border-bottom: 1px solid #e1dfdd;
        }

        .description-preview-content {
            padding: 10px;
            white-space: pre-wrap;
        }

        .description-edit-btn:hover {
            background: #f3f2f1;
            border-color: #e1dfdd;
            color: #323130;
        }

        .description-card-content {
            padding: 15px;
            background: white;
        }

        .description-card-content .pr-description {
            white-space: pre-wrap;
        }

        /* Right sidebar section styling */
        .right-sidebar-section {
            margin-bottom: 20px;
        }

        .right-sidebar-section:last-child {
            margin-bottom: 0;
        }

        .right-sidebar-section h4 {
            margin: 0 0 10px 0;
            color: #323130;
            font-size: 14px;
            font-weight: 600;
        }

        /* Compact stats (inline) */
        .compact-stats {
            display: flex;
            gap: 12px;
            align-items: center;
            font-size: 14px;
            padding: 8px 12px;
            background: white;
            margin-bottom: 8px;
        }

        .compact-stats:last-child {
            margin-bottom: 0;
        }

        .compact-stats span {
            cursor: default;
        }

        /* Line stats context menu */
        .line-stats-menu-wrapper {
            position: relative;
            margin-left: auto;
        }

        .line-stats-menu-btn {
            background: none;
            border: none;
            cursor: pointer;
            padding: 2px 4px;
            border-radius: 3px;
            color: #605e5c;
            font-size: 14px;
            line-height: 1;
            display: flex;
            align-items: center;
        }

        .line-stats-menu-btn:hover {
            background: #e1dfdd;
            color: #323130;
        }

        .line-stats-menu-btn svg {
            width: 16px;
            height: 16px;
        }

        .line-stats-context-menu {
            display: none;
            position: absolute;
            right: 0;
            top: 100%;
            background: white;
            border: 1px solid #e1dfdd;
            border-radius: 4px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.15);
            z-index: 1000;
            min-width: 160px;
            padding: 4px 0;
        }

        .line-stats-context-menu.open {
            display: block;
        }

        .line-stats-context-menu button {
            display: flex;
            align-items: center;
            gap: 8px;
            width: 100%;
            padding: 6px 12px;
            background: none;
            border: none;
            cursor: pointer;
            font-size: 13px;
            color: #323130;
            text-align: left;
            white-space: nowrap;
        }

        .line-stats-context-menu button:hover {
            background: #f3f2f1;
        }

        /* Live updates toggle */
        .live-toggle {
            display: inline-flex;
            align-items: center;
            gap: 8px;
            font-size: 13px;
            color: #605e5c;
            cursor: pointer;
            user-select: none;
        }

        .live-toggle-switch {
            position: relative;
            width: 34px;
            height: 18px;
            background: #8a8886;
            border-radius: 9px;
            transition: background 0.2s;
            flex-shrink: 0;
        }

        .live-toggle-switch::after {
            content: '';
            position: absolute;
            top: 2px;
            left: 2px;
            width: 14px;
            height: 14px;
            background: white;
            border-radius: 50%;
            transition: transform 0.2s;
        }

        .live-toggle.active .live-toggle-switch {
            background: #107c10;
        }

        .live-toggle.active .live-toggle-switch::after {
            transform: translateX(16px);
        }

        .live-toggle-label {
            white-space: nowrap;
        }

        /* View tabs */
        .view-tabs {
            display: flex;
            gap: 0;
            border-bottom: 2px solid #e1dfdd;
            padding: 0 20px;
            background: #f9f8f7;
        }

        .view-tab {
            padding: 6px 16px;
            border: none;
            background: none;
            cursor: pointer;
            font-size: 14px;
            font-weight: 600;
            color: #605e5c;
            border-bottom: 2px solid transparent;
            margin-bottom: -2px;
            transition: color 0.15s;
        }

        .view-tab:hover {
            color: #323130;
        }

        .view-tab.active {
            color: #0078d4;
            border-bottom-color: #0078d4;
        }

        /* Files view layout */
        #filesView {
            display: none;
            flex: 1;
            overflow: hidden;
        }

        #filesView.active {
            display: flex;
        }

        .files-layout {
            display: flex;
            flex: 1;
            overflow: hidden;
            height: 100%;
        }

        /* File tree panel */
        .file-tree-panel {
            width: 300px;
            min-width: 200px;
            max-width: 500px;
            border-right: 1px solid #e1dfdd;
            background: #fff;
            display: flex;
            flex-direction: column;
            overflow: hidden;
            position: relative;
        }

        .file-tree-header {
            padding: 12px 16px;
            font-weight: 600;
            font-size: 13px;
            color: #323130;
            border-bottom: 1px solid #e1dfdd;
            background: #faf9f8;
            flex-shrink: 0;
        }

        #fileTreeContainer {
            flex: 1;
            overflow-y: auto;
            padding: 4px 0;
        }

        .file-tree-dir {
            user-select: none;
        }

        .file-tree-dir-label {
            display: flex;
            align-items: center;
            padding: 3px 8px;
            padding-left: calc(8px + var(--depth, 0) * 16px);
            cursor: pointer;
            font-size: 13px;
            color: #323130;
            gap: 4px;
        }

        .file-tree-dir-label:hover {
            background: #f3f2f1;
        }

        .file-tree-toggle {
            width: 16px;
            text-align: center;
            font-size: 10px;
            color: #a19f9d;
            flex-shrink: 0;
        }

        .file-tree-dir-name {
            font-weight: 600;
        }

        .file-tree-dir-children {
            display: none;
        }

        .file-tree-dir.expanded > .file-tree-dir-children {
            display: block;
        }

        .file-tree-file {
            display: flex;
            align-items: center;
            padding: 3px 8px;
            padding-left: calc(28px + var(--depth, 0) * 16px);
            cursor: pointer;
            font-size: 13px;
            color: #323130;
            gap: 6px;
        }

        .file-tree-file:hover {
            background: #f3f2f1;
        }

        .file-tree-file.selected {
            background: #e1dfdd;
        }

        .file-tree-file-name {
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }

        .file-change-indicator {
            font-size: 11px;
            font-weight: 700;
            padding: 0 4px;
            border-radius: 3px;
            flex-shrink: 0;
            line-height: 18px;
        }

        .file-change-indicator.add {
            color: #1a7f37;
            background: #dafbe1;
        }

        .file-change-indicator.edit {
            color: #0550ae;
            background: #ddf4ff;
        }

        .file-change-indicator.delete {
            color: #cf222e;
            background: #ffebe9;
        }

        .file-change-indicator.rename {
            color: #8250df;
            background: #fbefff;
        }

        /* File tree resize handle */
        .file-tree-resize-handle {
            position: absolute;
            top: 0;
            right: -3px;
            width: 6px;
            height: 100%;
            cursor: col-resize;
            z-index: 10;
        }

        .file-tree-resize-handle:hover {
            background: rgba(0, 120, 212, 0.2);
        }

        /* File diff panel */
        .file-diff-panel {
            flex: 1;
            overflow-y: auto;
            background: #fff;
            display: flex;
            flex-direction: column;
        }

        .file-diff-header {
            padding: 10px 16px;
            border-bottom: 1px solid #e1dfdd;
            background: #faf9f8;
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 13px;
            flex-shrink: 0;
            flex-wrap: wrap;
        }

        .file-diff-path {
            font-family: monospace;
            font-weight: 600;
            word-break: break-all;
        }

        .file-diff-stats {
            margin-left: auto;
            display: flex;
            gap: 8px;
            font-size: 12px;
            font-weight: 600;
            flex-shrink: 0;
        }

        .file-diff-stats .stat-added {
            color: #1a7f37;
        }

        .file-diff-stats .stat-removed {
            color: #cf222e;
        }

        /* Hunk/thread jump navigation (shared styles) */
        .hunk-nav, .thread-nav {
            display: flex;
            align-items: center;
            gap: 4px;
            margin-left: 8px;
            flex-shrink: 0;
        }
        .hunk-nav-btn, .thread-nav-btn {
            background: none;
            border: 1px solid #d1d5db;
            border-radius: 3px;
            cursor: pointer;
            padding: 2px 6px;
            font-size: 14px;
            color: #605e5c;
            line-height: 1;
        }
        .hunk-nav-btn:hover, .thread-nav-btn:hover { background: #f3f2f1; }
        .hunk-nav-btn:disabled, .thread-nav-btn:disabled { opacity: 0.3; cursor: default; }
        .hunk-nav-btn:disabled:hover, .thread-nav-btn:disabled:hover { background: none; }
        .hunk-nav-label, .thread-nav-label {
            font-size: 11px;
            color: #8a8886;
            white-space: nowrap;
        }

        .file-diff-rename-info {
            font-size: 12px;
            color: #8250df;
            width: 100%;
        }

        .file-diff-body {
            flex: 1;
            overflow: auto;
        }
        .file-diff-body:has(.sbs-scroll-track) {
            display: flex;
            flex-direction: column;
            overflow-x: hidden;
        }
        .file-diff-body .diff-scroll-area {
            flex: 1;
            overflow: auto;
        }

        .file-diff-body .diff-lines {
            margin: 0;
            font-size: 12px;
        }
        .file-diff-body .diff-lines:not(.diff-lines-sbs) {
            width: fit-content;
            min-width: 100%;
        }

        .file-diff-empty {
            display: flex;
            align-items: center;
            justify-content: center;
            flex: 1;
            color: #a19f9d;
            font-size: 14px;
        }

        .file-diff-loading {
            display: flex;
            align-items: center;
            justify-content: center;
            flex: 1;
            color: #605e5c;
            font-size: 14px;
            gap: 8px;
        }

        .file-diff-error {
            display: flex;
            align-items: center;
            justify-content: center;
            flex: 1;
            color: #a4262c;
            font-size: 14px;
            padding: 20px;
        }

        /* Iteration selector */
        .iteration-selector {
            flex-shrink: 0;
            font-size: 12px;
            border-bottom: 1px solid #e1dfdd;
            background: #faf9f8;
        }

        .iteration-selector-bar {
            display: flex;
            align-items: center;
            gap: 6px;
            padding: 6px 12px;
        }

        .iteration-selector-label {
            font-weight: 600;
            color: #605e5c;
            margin-right: 2px;
        }

        .iteration-btn {
            min-width: 24px;
            height: 24px;
            padding: 0 6px;
            border: 1px solid #c8c6c4;
            background: #fff;
            border-radius: 3px;
            cursor: pointer;
            font-size: 12px;
            font-weight: 600;
            color: #323130;
            line-height: 22px;
            text-align: center;
        }

        .iteration-btn:hover {
            background: #f3f2f1;
            border-color: #a19f9d;
        }

        .iteration-btn.active {
            background: #0078d4;
            color: #fff;
            border-color: #0078d4;
        }

        .iteration-collapse-toggle {
            background: none;
            border: none;
            cursor: pointer;
            font-size: 11px;
            color: #605e5c;
            padding: 2px 4px;
            line-height: 1;
        }

        .iteration-collapse-toggle:hover {
            color: #323130;
        }

        .iteration-selection-text {
            font-size: 12px;
            color: #605e5c;
        }

        .iteration-panel {
            max-height: 0;
            overflow: hidden;
            background: #fff;
            border-top: none;
            transition: max-height 0.15s ease;
        }

        .iteration-panel.open {
            max-height: 220px;
            overflow-y: auto;
            border-top: 1px solid #e1dfdd;
        }

        .iteration-row {
            display: flex;
            align-items: center;
            padding: 8px 12px;
            gap: 10px;
            cursor: pointer;
            position: relative;
            user-select: none;
        }

        .iteration-row:hover {
            background: #f3f2f1;
        }

        .iteration-row.in-range {
            background: #eff6fc;
        }

        .iteration-row.in-range:hover {
            background: #deecf9;
        }

        .iteration-row.range-edge {
            background: #deecf9;
        }

        .iteration-row.range-edge:hover {
            background: #c7e0f4;
        }

        .iteration-node-col {
            display: flex;
            flex-direction: column;
            align-items: center;
            width: 16px;
            flex-shrink: 0;
            position: relative;
            align-self: stretch;
        }

        /* Timeline line segments above and below the node */
        .iteration-node-col::before,
        .iteration-node-col::after {
            content: '';
            position: absolute;
            left: 50%;
            transform: translateX(-50%);
            width: 2px;
            background: #c8c6c4;
        }

        .iteration-node-col::before {
            top: 0;
            height: calc(50% - 6px);
        }

        .iteration-node-col::after {
            bottom: 0;
            height: calc(50% - 6px);
        }

        .iteration-row:first-child .iteration-node-col::before {
            display: none;
        }

        .iteration-row:last-child .iteration-node-col::after {
            display: none;
        }

        /* In-range timeline line segments are blue and thicker */
        .iteration-row.in-range .iteration-node-col::before,
        .iteration-row.in-range .iteration-node-col::after,
        .iteration-row.range-edge .iteration-node-col::after {
            background: #0078d4;
            width: 3px;
        }

        /* The top edge: line above is normal, line below is blue */
        .iteration-row.range-edge-start .iteration-node-col::before {
            background: #c8c6c4;
            width: 2px;
        }

        .iteration-row.range-edge-start .iteration-node-col::after {
            background: #0078d4;
            width: 3px;
        }

        /* The bottom edge: line above is blue, line below is normal */
        .iteration-row.range-edge-end .iteration-node-col::before {
            background: #0078d4;
            width: 3px;
        }

        .iteration-row.range-edge-end .iteration-node-col::after {
            background: #c8c6c4;
            width: 2px;
        }

        /* When start == end (single selection), both lines are normal */
        .iteration-row.range-edge-start.range-edge-end .iteration-node-col::before,
        .iteration-row.range-edge-start.range-edge-end .iteration-node-col::after {
            background: #c8c6c4;
            width: 2px;
        }

        .iteration-node {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            border: 2px solid #c8c6c4;
            background: #fff;
            flex-shrink: 0;
            z-index: 1;
            box-sizing: border-box;
        }

        .iteration-row.in-range .iteration-node {
            border-color: #0078d4;
            background: #deecf9;
        }

        .iteration-row.range-edge .iteration-node {
            width: 16px;
            height: 16px;
            border-color: #0078d4;
            background: #0078d4;
            cursor: grab;
        }

        .iteration-row.range-edge .iteration-node:active {
            cursor: grabbing;
        }

        .iteration-info {
            flex: 1;
            min-width: 0;
            display: flex;
            flex-direction: column;
            gap: 1px;
        }

        .iteration-info-top {
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .iteration-number {
            font-weight: 700;
            font-size: 12px;
            color: #323130;
        }

        .iteration-date {
            font-size: 11px;
            color: #605e5c;
        }

        .iteration-commit {
            font-size: 11px;
            color: #605e5c;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }

        /* File view mode selector */
        .file-view-mode-bar {
            display: flex;
            align-items: center;
            gap: 2px;
            padding: 6px 12px;
            border-bottom: 1px solid #e1dfdd;
            background: #faf9f8;
            flex-shrink: 0;
        }

        .file-view-mode-btn {
            padding: 2px 8px;
            border: 1px solid #c8c6c4;
            background: #fff;
            cursor: pointer;
            font-size: 11px;
            color: #605e5c;
            line-height: 18px;
        }

        .file-view-mode-btn:first-child {
            border-radius: 3px 0 0 3px;
        }

        .file-view-mode-btn:last-child {
            border-radius: 0 3px 3px 0;
        }

        .file-view-mode-btn:not(:first-child) {
            border-left: none;
        }

        .file-view-mode-btn:hover {
            background: #f3f2f1;
            color: #323130;
        }

        .file-view-mode-btn.active {
            background: #0078d4;
            color: #fff;
            border-color: #0078d4;
        }

        .file-view-mode-btn.active + .file-view-mode-btn {
            border-left: 1px solid #c8c6c4;
        }

        /* Thread count badge on files */
        .file-thread-count {
            font-size: 10px;
            font-weight: 700;
            background: #e1dfdd;
            color: #605e5c;
            border-radius: 8px;
            padding: 0 5px;
            line-height: 16px;
            flex-shrink: 0;
            margin-left: auto;
        }

        .file-thread-count.has-active {
            background: #fff4ce;
            color: #835c00;
        }

        /* Thread sub-list under files */
        .file-tree-threads {
            padding-left: calc(28px + var(--depth, 0) * 16px);
        }

        .file-tree-thread {
            display: flex;
            align-items: center;
            gap: 6px;
            padding: 2px 8px;
            cursor: pointer;
            font-size: 11px;
            color: #605e5c;
        }

        .file-tree-thread:hover {
            background: #f3f2f1;
        }

        .file-tree-thread.focused {
            animation: tree-thread-focus-fade 5s ease-out forwards;
            background: #e8f0fe;
            color: #0078d4;
            font-weight: 600;
        }
        @keyframes tree-thread-focus-fade {
            0%, 40% { background: #e8f0fe; color: #0078d4; font-weight: 600; }
            100% { background: transparent; color: #605e5c; font-weight: normal; }
        }

        .thread-status-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            flex-shrink: 0;
        }

        .thread-status-dot.active {
            background: #0078d4;
        }

        .thread-status-dot.pending {
            background: #ffaa44;
        }

        .thread-status-dot.fixed,
        .thread-status-dot.closed,
        .thread-status-dot.wontFix {
            background: #a19f9d;
        }

        .thread-status-dot.byDesign {
            background: #a19f9d;
        }

        .thread-preview {
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
            min-width: 0;
        }

        /* Directory indicators */
        .dir-indicators {
            display: inline-flex;
            gap: 3px;
            margin-left: 6px;
            align-items: center;
        }

        .dir-indicator-change {
            width: 6px;
            height: 6px;
            border-radius: 50%;
            background: #0550ae;
        }

        .dir-indicator-comment {
            width: 6px;
            height: 6px;
            border-radius: 50%;
            background: #bf8700;
        }

        /* Comment-only file indicator */
        .file-change-indicator.comment {
            color: #835c00;
            background: #fff4ce;
        }

        /* No-change file (all files mode) */
        .file-tree-file.no-change {
            color: #a19f9d;
        }

        .file-tree-file.no-change .file-tree-file-name {
            color: #a19f9d;
        }

        /* Lazy-loading directory indicator */
        .file-tree-dir-loading {
            padding: 3px 8px;
            padding-left: calc(28px + var(--depth, 0) * 16px);
            font-size: 11px;
            color: #a19f9d;
            font-style: italic;
        }
    </style>
</head>
<body>
    <div class="container wide">
        <div style="display: flex; justify-content: space-between; align-items: center; margin: 0; padding: 8px 8px; border-radius: 0;">
            <div>
                <h1 style="font-size: 1.3em; margin: 0;">💬 PR Threads Viewer</h1>
            </div>
            <div style="display: flex; gap: 14px; align-items: center;">
                <label id="liveUpdatesToggle" class="live-toggle active" onclick="toggleLiveUpdates()">
                    <span class="live-toggle-switch"></span>
                    <span class="live-toggle-label">Live Updates</span>
                </label>
                <a href="ado-pr-list.html" onclick="const url = sessionStorage.getItem('prListReturnUrl'); if (url) { window.location.href = url; return false; } return true;" style="color: #0078d4; text-decoration: none; font-size: 14px;">📋 PR List</a>
                <a href="index.html" style="color: #0078d4; text-decoration: none; font-size: 14px;">🏠 Home</a>
                <a href="ado-settings.html" style="color: #0078d4; text-decoration: none; font-size: 14px;">⚙️ Settings</a>
            </div>
        </div>

        <div class="page-layout">
            <!-- Left Sidebar with Filters -->
            <div class="sidebar left-sidebar" id="threadFilters" style="display: none;">
                <div class="resize-handle" id="resizeHandle"></div>
                <h3 style="margin-top: 0; margin-bottom: 20px;">Filters</h3>

                <div class="filter-section">
                    <h4>Thread Status</h4>
                    <div class="status-chips-vertical">
                        <button class="status-chip selected" data-status="active" onclick="toggleStatusChip(this)">Active</button>
                        <button class="status-chip selected" data-status="fixed" onclick="toggleStatusChip(this)">Resolved</button>
                        <button class="status-chip selected" data-status="closed" onclick="toggleStatusChip(this)">Closed</button>
                        <button class="status-chip selected" data-status="wontFix" onclick="toggleStatusChip(this)">Won't Fix</button>
                        <button class="status-chip selected" data-status="pending" onclick="toggleStatusChip(this)">Pending</button>
                        <button class="status-chip" data-status="unknown" onclick="toggleStatusChip(this)">Unknown</button>
                        <button class="status-chip" data-status="noStatus" onclick="toggleStatusChip(this)">No status</button>
                    </div>
                    <label class="checkbox-label">
                        <input type="checkbox" id="showDeleted" onchange="applyThreadFilters()">
                        Show deleted threads
                    </label>
                </div>

                <div class="filter-section">
                    <h4>Thread Author</h4>
                    <select id="threadAuthorFilter" onchange="applyThreadFilters()">
                        <option value="">All authors</option>
                    </select>
                </div>

                <div class="filter-section">
                    <h4>Comments by User</h4>
                    <select id="commentAuthorFilter" onchange="applyThreadFilters()">
                        <option value="">All users</option>
                    </select>
                </div>

                <div class="filter-section">
                    <h4>Search in Comments</h4>
                    <input type="text" id="searchFilter" placeholder="Search text..." oninput="applyThreadFilters()">
                </div>

                <div class="filter-section">
                    <h4>View Options</h4>
                    <button id="bulkModeToggle" onclick="toggleBulkMode()" class="btn-secondary" style="width: 100%;">
                        Enable Bulk Selection
                    </button>
                </div>

                <div class="thread-count">
                    Showing <span id="filteredCount">0</span> of <span id="totalCount">0</span> threads
                </div>
            </div>

            <!-- Main Content -->
            <div class="main-content">
                <div id="bulkActions" class="bulk-actions">
                    <strong>Bulk Thread Selection Mode Active</strong>
                    <p style="margin: 10px 0 0 0; font-size: 14px; color: #605e5c;">Select threads using checkboxes, then change their status below. Filters are disabled in bulk mode.</p>
                    <div class="bulk-actions-buttons">
                        <button onclick="selectAllThreads()" class="btn-secondary">Select All</button>
                        <button onclick="deselectAllThreads()" class="btn-secondary">Deselect All</button>
                        <span style="margin-left: 10px; color: #323130;">Selected: <strong id="selectedCount">0</strong> threads</span>
                        <div style="margin-left: auto; display: flex; gap: 10px; align-items: center;">
                            <label for="bulkStatusSelect" style="margin: 0;">Change selected to:</label>
                            <select id="bulkStatusSelect">
                                <option value="">Select status...</option>
                                <option value="active">Active</option>
                                <option value="fixed">Resolved</option>
                                <option value="closed">Closed</option>
                                <option value="wontFix">Won't Fix</option>
                                <option value="pending">Pending</option>
                            </select>
                            <button onclick="applyBulkStatusChange()" class="btn-primary">Apply Changes</button>
                        </div>
                    </div>
                </div>


                <div class="config-section" id="configSection" style="display: none;">
                    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px;">
                        <h3 style="margin: 0;">Configuration</h3>
                    </div>

                    <details id="advancedConfig">
                        <summary style="cursor: pointer; color: #0078d4; font-weight: 600;">🔧 Advanced Configuration</summary>
                        <div style="margin-top: 15px;">
                            <div class="form-group">
                                <label for="serverUrl">Azure DevOps Server URL</label>
                                <input type="text" id="serverUrl" placeholder="https://your-ado-server.com" />
                            </div>
                            <div class="form-group">
                                <label for="organization">Organization/Collection</label>
                                <input type="text" id="organization" placeholder="DefaultCollection" />
                            </div>
                            <div class="form-group">
                                <label for="project">Project Name</label>
                                <input type="text" id="project" placeholder="MyProject" />
                            </div>
                            <div class="form-group">
                                <label for="repository">Repository Name</label>
                                <input type="text" id="repository" placeholder="MyRepo" />
                            </div>
                        </div>
                    </details>

                    <button id="loadButton" onclick="loadPRThreads()">Load PR Threads</button>
                    <div id="configStatus" style="margin-top: 10px; font-size: 12px; color: #605e5c;"></div>
                </div>

                <div id="pr-title-bar-container"></div>
                <div class="results-container" id="overviewView">
                    <div id="results">
                        <div id="pr-header-container"></div>
                        <div class="new-thread-container" id="newThreadContainer" style="display: none;">
                            <button class="new-thread-btn" onclick="showNewThreadForm()" id="newThreadBtn">+ New Thread</button>
                            <div id="newThreadFormContainer"></div>
                        </div>
                        <div id="thread-list-container"></div>
                    </div>
                </div>
                <div id="filesView">
                    <div class="files-layout">
                        <div class="file-tree-panel">
                            <div class="file-tree-resize-handle" id="fileTreeResizeHandle"></div>
                            <div class="iteration-selector" id="iterationSelector" style="display: none;"></div>
                            <div class="file-view-mode-bar" id="fileViewModeBar">
                                <button class="file-view-mode-btn active" data-mode="changed" onclick="setFileViewMode('changed')">Changed</button>
                                <button class="file-view-mode-btn" data-mode="commented" onclick="setFileViewMode('commented')">With comments</button>
                                <button class="file-view-mode-btn" data-mode="all" onclick="setFileViewMode('all')">All files</button>
                            </div>
                            <div class="file-tree-header" id="fileTreeHeader">Changed Files</div>
                            <div id="fileTreeContainer"></div>
                        </div>
                        <div class="file-diff-panel" id="fileDiffPanel">
                            <div class="file-diff-empty">Select a file to view changes</div>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Right Sidebar with Stats, Reviewers, Checks -->
            <div class="sidebar right-sidebar" id="rightSidebar" style="display: none;">
                <div class="resize-handle resize-handle-left" id="resizeHandleRight"></div>
                <div id="rightSidebarStats" class="right-sidebar-section"></div>
                <div id="rightSidebarReviewers" class="right-sidebar-section"></div>
                <div id="rightSidebarWorkItems" class="right-sidebar-section"></div>
                <div id="rightSidebarChecks" class="right-sidebar-section"></div>
            </div>
        </div>
    </div>

    <script src="common.js"></script>
    <script src="diff.js"></script>
    <script src="diff-utils.js"></script>
    <script src="pr-threads-utils.js"></script>
    <script src="mention-utils.js"></script>
    <script>
        DiffUtils.init(ADOContent.escapeHtml.bind(ADOContent));

        let currentPRId = null;
        let allThreads = [];
        let allIterations = [];
        let currentPRData = null;
        let currentConfig = null;
        let currentFileChangeStats = null;
        let allChangeEntries = [];
        let currentView = 'overview';
        let selectedFilePath = null;
        let fileDiffCache = new Map();
        let fileTreeBuilt = false;
        let currentMergeBase = null;
        let selectedIterationStart = null; // null = "all"
        let selectedIterationEnd = null;
        let threadsByFilePath = new Map();     // Map<filePath, Thread[]>
        let fileViewMode = 'changed';          // 'changed' | 'commented' | 'all'
        let repoTreeCache = new Map();         // Map<dirPath, Array<item>>
        let repoTreeFullyLoaded = false;
        let commentedFilePaths = new Set();    // Files with threads but not in changeEntries
        let changedFilePaths = new Set();      // Files in changeEntries
        let isBulkMode = false;
        let selectedThreadIds = new Set();
        let isRestoringFromURL = false;
        let urlProject = null;  // Saved from initial URL
        let urlRepo = null;     // Saved from initial URL
        let liveUpdatesEnabled = localStorage.getItem('prThreadsLiveUpdates') !== 'false'; // default: true
        let fileDiffDisplayMode = localStorage.getItem('fileDiffDisplayMode') || 'side-by-side';

        // Cache for iteration changes and file path history
        let iterationChangesCache = new Map(); // iterationId → changes array
        let filePathHistoryCache = new Map();  // filePath → Map<iterationId, pathAtIteration>

        // --- @mention autocomplete ---
        const MentionAutocomplete = (() => {
            let searchTimeout = null;
            let activeDropdown = null;
            let selectedIndex = -1;

            function getMentionContext(textarea) {
                return MentionUtils.getMentionContext(textarea.value, textarea.selectionStart);
            }

            function getOrCreateDropdown(textarea) {
                const editor = textarea.closest('.comment-editor') || textarea.parentElement;
                let dropdown = editor.querySelector('.mention-dropdown');
                if (!dropdown) {
                    dropdown = document.createElement('div');
                    dropdown.className = 'mention-dropdown';
                    editor.insertBefore(dropdown, textarea);
                }
                return dropdown;
            }

            function closeDropdown() {
                if (activeDropdown) {
                    activeDropdown.classList.remove('active');
                    activeDropdown = null;
                }
                selectedIndex = -1;
                clearTimeout(searchTimeout);
            }

            function insertMention(textarea, identity, mentionStart) {
                // Populate identity cache so resolveMentions can display the name after submit
                if (identity.localId && identity.displayName) {
                    identityCache[identity.localId] = identity.displayName;
                }
                // Track mention mapping on the textarea for resolution on submit
                if (!textarea._mentionMap) textarea._mentionMap = new Map();
                textarea._mentionMap.set(identity.displayName, identity.localId);

                const result = MentionUtils.buildMentionText(textarea.value, textarea.selectionStart, mentionStart, identity.displayName);
                textarea.value = result.text;
                textarea.selectionStart = textarea.selectionEnd = result.cursorPos;
                textarea.focus();
                textarea.dispatchEvent(new Event('input', { bubbles: true }));
                closeDropdown();
            }

            function renderResults(dropdown, textarea, identities, mentionStart) {
                if (identities.length === 0) {
                    dropdown.innerHTML = '<div class="mention-hint">No users found</div>';
                    return;
                }
                selectedIndex = 0;
                dropdown.innerHTML = identities.map((identity, i) => {
                    const name = ADOContent.escapeHtml(identity.displayName || 'Unknown');
                    const email = ADOContent.escapeHtml(identity.mail || '');
                    const initials = name.split(' ').map(n => n[0]).join('').substring(0, 2).toUpperCase();
                    return `
                        <div class="mention-result${i === 0 ? ' selected' : ''}" data-index="${i}">
                            <div class="avatar-fallback" style="width: 24px; height: 24px; font-size: 9px;">${initials}</div>
                            <div>
                                <div class="result-name">${name}</div>
                                ${email ? `<div class="result-email">${email}</div>` : ''}
                            </div>
                        </div>
                    `;
                }).join('');

                dropdown.querySelectorAll('.mention-result').forEach((el, i) => {
                    el.addEventListener('mousedown', (e) => {
                        e.preventDefault();
                        insertMention(textarea, identities[i], mentionStart);
                    });
                });
            }

            function updateSelection(dropdown) {
                dropdown.querySelectorAll('.mention-result').forEach((el, i) => {
                    el.classList.toggle('selected', i === selectedIndex);
                    if (i === selectedIndex) el.scrollIntoView({ block: 'nearest' });
                });
            }

            function attach(textarea) {
                let currentIdentities = [];
                let currentMentionStart = 0;

                textarea.addEventListener('input', () => {
                    const ctx = getMentionContext(textarea);
                    if (!ctx) { closeDropdown(); return; }

                    const dropdown = getOrCreateDropdown(textarea);
                    activeDropdown = dropdown;
                    currentMentionStart = ctx.mentionStart;
                    dropdown.classList.add('active');

                    if (ctx.query.length < 2) {
                        dropdown.innerHTML = '<div class="mention-hint">Keep typing to search...</div>';
                        selectedIndex = -1;
                        currentIdentities = [];
                        return;
                    }

                    clearTimeout(searchTimeout);
                    dropdown.innerHTML = '<div class="mention-hint">Searching...</div>';
                    searchTimeout = setTimeout(async () => {
                        try {
                            const identities = await ADOAPI.searchIdentities(currentConfig, ctx.query);
                            currentIdentities = identities;
                            // Re-check context is still valid
                            const freshCtx = getMentionContext(textarea);
                            if (!freshCtx || freshCtx.query !== ctx.query) return;
                            renderResults(dropdown, textarea, identities, ctx.mentionStart);
                        } catch (err) {
                            dropdown.innerHTML = `<div class="mention-hint" style="color: #a4262c;">Search failed</div>`;
                        }
                    }, 300);
                });

                textarea.addEventListener('keydown', (e) => {
                    if (!activeDropdown || !activeDropdown.classList.contains('active')) return;
                    const results = activeDropdown.querySelectorAll('.mention-result');
                    if (results.length === 0 && e.key !== 'Escape') return;

                    if (e.key === 'ArrowDown') {
                        e.preventDefault();
                        selectedIndex = Math.min(selectedIndex + 1, results.length - 1);
                        updateSelection(activeDropdown);
                    } else if (e.key === 'ArrowUp') {
                        e.preventDefault();
                        selectedIndex = Math.max(selectedIndex - 1, 0);
                        updateSelection(activeDropdown);
                    } else if (e.key === 'Enter' && selectedIndex >= 0 && currentIdentities[selectedIndex]) {
                        e.preventDefault();
                        insertMention(textarea, currentIdentities[selectedIndex], currentMentionStart);
                    } else if (e.key === 'Escape') {
                        e.preventDefault();
                        closeDropdown();
                    }
                });

                textarea.addEventListener('blur', () => {
                    // Delay to allow mousedown on results
                    setTimeout(closeDropdown, 200);
                });
            }

            return { attach, closeDropdown };
        })();

        /** Resolve @DisplayName → @<id> in a textarea's content before submitting */
        function resolveMentionsForSubmit(textarea) {
            if (!textarea) return textarea?.value?.trim() || '';
            const text = textarea.value.trim();
            return MentionUtils.resolveDisplayMentions(text, textarea._mentionMap);
        }

        /**
         * Get changes for an iteration (cached)
         */
        async function getIterationChanges(iterationId) {
            if (iterationChangesCache.has(iterationId)) {
                return iterationChangesCache.get(iterationId);
            }
            try {
                const data = await ADOAPI.getPRIterationChanges(currentConfig, currentPRId, iterationId);
                const changes = data.changeEntries || [];
                iterationChangesCache.set(iterationId, changes);
                return changes;
            } catch (e) {
                console.warn(`Failed to fetch changes for iteration ${iterationId}:`, e);
                iterationChangesCache.set(iterationId, []);
                return [];
            }
        }

        function buildThreadsByFilePath() {
            threadsByFilePath.clear();
            commentedFilePaths.clear();
            changedFilePaths.clear();

            // Build rename maps: oldPath→newPath and newPath→oldPath from change entries
            const oldToNew = new Map();
            const newToOld = new Map();
            for (const entry of allChangeEntries) {
                if (!entry.item?.path) continue;
                const ct = (entry.changeType || '').toLowerCase();
                if (ct.includes('rename')) {
                    const oldPath = entry.sourceServerItem || entry.originalPath;
                    if (oldPath) {
                        oldToNew.set(oldPath, entry.item.path);
                        newToOld.set(entry.item.path, oldPath);
                    }
                }
            }

            for (const thread of allThreads) {
                if (thread.isDeleted) continue;
                const fp = thread.threadContext?.filePath;
                if (!fp) continue;
                // Skip system threads (no real comments)
                const hasRealComment = thread.comments?.some(c => c.commentType !== 'system');
                if (!hasRealComment) continue;

                // Map thread to its original path
                if (!threadsByFilePath.has(fp)) threadsByFilePath.set(fp, []);
                threadsByFilePath.get(fp).push(thread);

                // If this thread's path was renamed, also map it under the new path
                const newPath = oldToNew.get(fp);
                if (newPath && newPath !== fp) {
                    if (!threadsByFilePath.has(newPath)) threadsByFilePath.set(newPath, []);
                    threadsByFilePath.get(newPath).push(thread);
                }

                // If this thread's path is the new name, also map under old path
                const oldPath = newToOld.get(fp);
                if (oldPath && oldPath !== fp) {
                    if (!threadsByFilePath.has(oldPath)) threadsByFilePath.set(oldPath, []);
                    threadsByFilePath.get(oldPath).push(thread);
                }
            }
            for (const entry of allChangeEntries) {
                if (entry.item?.path && entry.item.gitObjectType !== 'tree' && !entry.item.path.endsWith('/')) {
                    changedFilePaths.add(entry.item.path);
                }
            }
            for (const fp of threadsByFilePath.keys()) {
                if (!changedFilePaths.has(fp)) commentedFilePaths.add(fp);
            }
        }

        function calculateFileChangeStats(changeEntries) {
            return PRThreadsUtils.calculateFileChangeStats(changeEntries);
        }

        function getLineStatsCacheKey(config, prId, iterationCount) {
            return PRThreadsUtils.getLineStatsCacheKey(config, prId, iterationCount);
        }

        function getCachedLineStats(cacheKey) {
            try {
                const cached = localStorage.getItem(cacheKey);
                if (cached) {
                    return JSON.parse(cached);
                }
            } catch (e) {
                console.warn('Failed to read line stats cache:', e);
            }
            return null;
        }

        function setCachedLineStats(cacheKey, stats) {
            try {
                localStorage.setItem(cacheKey, JSON.stringify(stats));
            } catch (e) {
                console.warn('Failed to cache line stats:', e);
            }
        }

        function computeLineDiff(oldContent, newContent) {
            // Use histogram diff for accurate line stats
            return HistogramDiff.stats(oldContent, newContent);
        }

        async function fetchFileContent(config, path, commitId) {
            try {
                const url = `${config.serverUrl}/${config.organization}/${config.project}/_apis/git/repositories/${config.repository}/items?path=${encodeURIComponent(path)}&versionDescriptor.version=${commitId}&versionDescriptor.versionType=commit&api-version=6.0`;
                const response = await fetch(url, {
                    headers: { 'Authorization': `Basic ${btoa(':' + config.pat)}` }
                });
                if (!response.ok) return null;
                return await response.text();
            } catch (e) {
                return null;
            }
        }

        async function fetchLineStatsViaLocalDiff(config, prData, changes, mergeBaseCommit) {
            const baseCommit = mergeBaseCommit;
            const targetCommit = prData.lastMergeSourceCommit?.commitId;

            console.group('[LineStats:LocalDiff] Starting');
            console.log('baseCommit (merge base):', baseCommit);
            console.log('targetCommit (lastMergeSourceCommit):', targetCommit);

            let totalAdded = 0;
            let totalRemoved = 0;

            // Process files
            for (const change of changes) {
                const newPath = change.item?.path;
                if (!newPath) continue;

                const changeType = (change.changeType || '').toLowerCase();
                // For renames, sourceServerItem or originalPath contains the old path
                const oldPath = change.sourceServerItem || change.originalPath || newPath;

                console.group(`  File: ${newPath} (changeType: ${changeType})`);

                if (changeType.includes('add')) {
                    const content = await fetchFileContent(config, newPath, targetCommit);
                    if (content) {
                        const lines = content.split('\n').length;
                        console.log(`  Added file: ${lines} lines`);
                        totalAdded += lines;
                    }
                } else if (changeType.includes('delete')) {
                    const content = await fetchFileContent(config, oldPath, baseCommit);
                    if (content) {
                        const lines = content.split('\n').length;
                        console.log(`  Deleted file: ${lines} lines`);
                        totalRemoved += lines;
                    }
                } else if (changeType.includes('edit') || changeType.includes('rename')) {
                    const [oldContent, newContent] = await Promise.all([
                        fetchFileContent(config, oldPath, baseCommit),
                        fetchFileContent(config, newPath, targetCommit)
                    ]);
                    console.log(`  Old content length: ${oldContent?.length ?? 'null'} chars, ${oldContent?.split('\\n').length ?? 0} lines`);
                    console.log(`  New content length: ${newContent?.length ?? 'null'} chars, ${newContent?.split('\\n').length ?? 0} lines`);
                    const diff = computeLineDiff(oldContent, newContent);
                    console.log(`  Diff result: +${diff.added} -${diff.removed}`);
                    totalAdded += diff.added;
                    totalRemoved += diff.removed;
                }

                console.log(`  Running total: +${totalAdded} -${totalRemoved}`);
                console.groupEnd();
            }

            console.log(`TOTAL via local diff: +${totalAdded} -${totalRemoved}`);
            console.groupEnd();
            return { added: totalAdded, removed: totalRemoved };
        }

        async function resolveMergeBase(config) {
            const sourceCommit = currentPRData.lastMergeSourceCommit?.commitId;
            const targetBranchCommit = currentPRData.lastMergeTargetCommit?.commitId;

            if (!sourceCommit || !targetBranchCommit) return null;

            // Try iteration commonRefCommit first
            if (allIterations.length > 0 && allIterations[0].commonRefCommit?.commitId) {
                return allIterations[0].commonRefCommit.commitId;
            }

            // Fallback: merge bases API
            try {
                const mergeBasesData = await ADOAPI.getMergeBases(config, sourceCommit, targetBranchCommit);
                const bases = mergeBasesData.value || [];
                if (bases.length > 0) {
                    return bases[0].commitId;
                }
            } catch (e) {
                console.warn('Merge bases API failed:', e);
            }

            // Last resort: target branch HEAD
            console.warn('Could not resolve merge base, falling back to lastMergeTargetCommit');
            return targetBranchCommit;
        }

        async function fetchLineStatsAsync(config, prData) {
            const iterationCount = allIterations.length;
            const cacheKey = getLineStatsCacheKey(config, prData.pullRequestId, iterationCount);

            console.group('[LineStats] fetchLineStatsAsync for PR #' + prData.pullRequestId);
            console.log('Iteration count:', iterationCount);
            console.log('Cache key:', cacheKey);
            console.log('PR source branch:', prData.sourceRefName);
            console.log('PR target branch:', prData.targetRefName);
            console.log('lastMergeTargetCommit:', prData.lastMergeTargetCommit?.commitId);
            console.log('lastMergeSourceCommit:', prData.lastMergeSourceCommit?.commitId);
            console.log('lastMergeCommit:', prData.lastMergeCommit?.commitId);

            // Check cache first (validate that values are numbers, not null)
            const cached = getCachedLineStats(cacheKey);
            if (cached && typeof cached.added === 'number' && typeof cached.removed === 'number') {
                console.log('CACHE HIT — returning cached stats:', cached);
                console.log('To force recalculation, run: localStorage.removeItem("' + cacheKey + '")');
                console.groupEnd();
                updateLineStatsDisplay(cached.added, cached.removed);
                return;
            }
            console.log('CACHE MISS — computing fresh stats');

            // Need to compute - show loading
            updateLineStatsLoading();

            try {
                const mergeBaseCommit = currentMergeBase || await resolveMergeBase(config);

                if (!mergeBaseCommit) {
                    console.warn('Missing merge base commit, aborting');
                    console.groupEnd();
                    hideLineStatsLoading();
                    return;
                }

                console.log('Using merge base:', mergeBaseCommit);

                // Get file changes from the latest iteration compared to base (compareTo=0)
                // This gives cumulative changes across all pushes, not just the first push
                const latestIterationId = iterationCount;
                console.log('Fetching changes for iteration', latestIterationId, 'compared to base (compareTo=0)');
                const changesData = await ADOAPI.getPRIterationChanges(config, prData.pullRequestId, latestIterationId, 0);
                const changes = changesData.changeEntries || [];

                console.log('Cumulative PR changes (' + changes.length + ' files):', changes.map(c => ({
                    path: c.item?.path,
                    changeType: c.changeType,
                    sourceServerItem: c.sourceServerItem
                })));

                if (changes.length === 0) {
                    console.log('No changes found, displaying 0/0');
                    console.groupEnd();
                    updateLineStatsDisplay(0, 0);
                    return;
                }

                const stats = await fetchLineStatsViaLocalDiff(config, prData, changes, mergeBaseCommit);
                console.log('Final stats via local diff:', stats);

                console.log('=== FINAL LINE STATS: +' + stats.added + ' -' + stats.removed + ' ===');
                setCachedLineStats(cacheKey, stats);
                updateLineStatsDisplay(stats.added, stats.removed);

            } catch (e) {
                console.warn('Failed to compute line stats:', e);
                hideLineStatsLoading();
            }
            console.groupEnd();
        }

        function hideLineStatsLoading() {
            const container = document.getElementById('lineStatsContainer');
            if (container) {
                container.innerHTML = '';
            }
        }

        function updateLineStatsLoading() {
            const container = document.getElementById('lineStatsContainer');
            if (!container) return;
            container.innerHTML = `
                <span>Lines</span>
                <span style="color: #605e5c;">⏳</span>
                ${getLineStatsMenuHtml()}
            `;
        }

        function getLineStatsMenuHtml() {
            return `
                <div class="line-stats-menu-wrapper">
                    <button class="line-stats-menu-btn" onclick="toggleLineStatsMenu(event)" title="Options">
                        <svg viewBox="0 0 16 16" fill="currentColor"><circle cx="8" cy="3" r="1.5"/><circle cx="8" cy="8" r="1.5"/><circle cx="8" cy="13" r="1.5"/></svg>
                    </button>
                    <div class="line-stats-context-menu" id="lineStatsContextMenu">
                        <button onclick="resetLineStats()">🔄 Reset line stat</button>
                    </div>
                </div>
            `;
        }

        function toggleLineStatsMenu(event) {
            event.stopPropagation();
            const menu = document.getElementById('lineStatsContextMenu');
            if (!menu) return;
            menu.classList.toggle('open');

            // Close on outside click
            if (menu.classList.contains('open')) {
                const closeHandler = (e) => {
                    if (!menu.contains(e.target)) {
                        menu.classList.remove('open');
                        document.removeEventListener('click', closeHandler);
                    }
                };
                // Defer so the current click doesn't immediately close it
                setTimeout(() => document.addEventListener('click', closeHandler), 0);
            }
        }

        async function resetLineStats() {
            // Close the menu
            const menu = document.getElementById('lineStatsContextMenu');
            if (menu) menu.classList.remove('open');

            if (!currentConfig || !currentPRData) return;

            // Remove cache entry
            const iterationCount = allIterations.length;
            const cacheKey = getLineStatsCacheKey(currentConfig, currentPRData.pullRequestId, iterationCount);
            try {
                localStorage.removeItem(cacheKey);
                console.log('Removed line stats cache for key:', cacheKey);
            } catch (e) {
                console.warn('Failed to remove line stats cache:', e);
            }

            // Trigger fresh computation
            await fetchLineStatsAsync(currentConfig, currentPRData);
        }

        function updateLineStatsDisplay(added, removed) {
            const container = document.getElementById('lineStatsContainer');
            if (!container) return;

            container.innerHTML = `
                <span>Lines</span>
                <strong style="color: #107c10;" title="Added">+${added}</strong>
                <strong style="color: #a4262c;" title="Removed">-${removed}</strong>
                ${getLineStatsMenuHtml()}
            `;
        }

        function getActiveThreadCounts(threads) {
            return PRThreadsUtils.getActiveThreadCounts(threads);
        }

        function renderAvatarWithBadges(user, vote, threadCount, isPRAuthor = false) {
            const initials = user.displayName.split(' ').map(n => n[0]).join('').substring(0, 2).toUpperCase();
            const displayName = ADOContent.escapeHtml(user.displayName);

            // Vote info
            let voteClass = '';
            let voteText = '';
            let voteIcon = '';
            if (vote !== undefined) {
                switch (vote) {
                    case 10:
                        voteClass = 'vote-approved';
                        voteText = 'Approved';
                        voteIcon = '✓';
                        break;
                    case 5:
                        voteClass = 'vote-approved-suggestions';
                        voteText = 'Approved with suggestions';
                        voteIcon = '✓';
                        break;
                    case -5:
                        voteClass = 'vote-wait';
                        voteText = 'Waiting for author';
                        voteIcon = '!';
                        break;
                    case -10:
                        voteClass = 'vote-rejected';
                        voteText = 'Rejected';
                        voteIcon = '✗';
                        break;
                    default:
                        voteClass = 'vote-no-vote';
                        voteText = 'No vote';
                }
            }

            const title = vote !== undefined ? `${displayName} - ${voteText}` : displayName;

            let avatarHtml;
            if (user.id) {
                const cachedUrl = AvatarLoader.getCached(user.id);
                if (cachedUrl) {
                    avatarHtml = `<img src="${cachedUrl}" alt="${title}" title="${title}" class="avatar">`;
                } else {
                    avatarHtml = `<div class="avatar-placeholder" title="${title}"></div><img data-user-id="${user.id}" alt="${title}" title="${title}" class="avatar avatar-pending">`;
                }
            } else {
                avatarHtml = `<div class="avatar-fallback" title="${title}">${initials}</div>`;
            }

            // Vote badge (bottom-left)
            let voteBadgeHtml = '';
            if (voteIcon) {
                voteBadgeHtml = `<span class="vote-badge ${voteClass}">${voteIcon}</span>`;
            }

            // Thread count badge (top-right)
            let threadBadgeHtml = '';
            if (threadCount && threadCount > 0) {
                threadBadgeHtml = `<span class="thread-badge" title="${threadCount} active thread${threadCount > 1 ? 's' : ''}">${threadCount}</span>`;
            }

            // PR Author badge (top-left)
            let authorBadgeHtml = '';
            if (isPRAuthor) {
                authorBadgeHtml = `<span class="author-badge" title="PR Author"><svg viewBox="0 0 24 24"><path d="M12 2l3.09 6.26L22 9.27l-5 4.87 1.18 6.88L12 17.77l-6.18 3.25L7 14.14 2 9.27l6.91-1.01L12 2z" fill="#323130"/></svg></span>`;
            }

            return `<div class="avatar-wrapper" data-user-id="${user.id || ''}">${avatarHtml}${voteBadgeHtml}${threadBadgeHtml}${authorBadgeHtml}</div>`;
        }

        function renderReviewerWithDropdown(reviewer, vote, threadCount, isPRAuthor, isRequired) {
            const avatarHtml = renderAvatarWithBadges(reviewer, vote, threadCount, isPRAuthor);
            const reviewerId = reviewer.id;
            const displayName = ADOContent.escapeHtml(reviewer.displayName);
            const toggleText = isRequired ? 'Make Optional' : 'Make Required';
            const toggleRequired = !isRequired;

            return `
                <div class="reviewer-avatar-wrapper" onclick="toggleReviewerDropdown(event, this)">
                    ${avatarHtml}
                    <div class="reviewer-dropdown">
                        <button class="reviewer-dropdown-item" onclick="event.stopPropagation(); toggleReviewerRequired('${reviewerId}', ${toggleRequired})">${toggleText}</button>
                        <button class="reviewer-dropdown-item danger" onclick="event.stopPropagation(); removeReviewer('${reviewerId}', '${displayName}')">Remove</button>
                    </div>
                </div>
            `;
        }

        function renderReviewersSection(reviewers, threadCounts, prAuthorId) {
            let html = '';

            // Separate required and optional reviewers
            const requiredReviewers = (reviewers || []).filter(r => r.isRequired);
            const optionalReviewers = (reviewers || []).filter(r => !r.isRequired);

            // Always show Required Reviewers section with inline add
            const requiredAvatarsHtml = requiredReviewers.map(r => {
                const count = threadCounts[r.id] || 0;
                return renderReviewerWithDropdown(r, r.vote, count, r.id === prAuthorId, true);
            }).join('');

            html += `
                <div class="avatars-section">
                    <h4><span>Required Reviewers</span> <button class="add-reviewer-inline-btn" onclick="toggleInlineReviewerSearch('required')" title="Add required reviewer">+</button></h4>
                    <div id="reviewerSearchRequired" class="inline-reviewer-search" style="display: none;">
                        <input type="text" placeholder="Search by name or email..." oninput="searchReviewersInline(this.value, 'required')">
                        <div class="inline-search-results"></div>
                    </div>
                    <div id="requiredReviewersAvatars" class="avatars-container">${requiredAvatarsHtml || '<span class="no-reviewers">None</span>'}</div>
                </div>
            `;

            // Always show Optional Reviewers section with inline add
            const optionalAvatarsHtml = optionalReviewers.map(r => {
                const count = threadCounts[r.id] || 0;
                return renderReviewerWithDropdown(r, r.vote, count, r.id === prAuthorId, false);
            }).join('');

            html += `
                <div class="avatars-section">
                    <h4><span>Optional Reviewers</span> <button class="add-reviewer-inline-btn" onclick="toggleInlineReviewerSearch('optional')" title="Add optional reviewer">+</button></h4>
                    <div id="reviewerSearchOptional" class="inline-reviewer-search" style="display: none;">
                        <input type="text" placeholder="Search by name or email..." oninput="searchReviewersInline(this.value, 'optional')">
                        <div class="inline-search-results"></div>
                    </div>
                    <div id="optionalReviewersAvatars" class="avatars-container">${optionalAvatarsHtml || '<span class="no-reviewers">None</span>'}</div>
                </div>
            `;

            return html;
        }

        function renderOtherAuthorsSection(threads, reviewers, threadCounts, prAuthorId) {
            // Get all unique thread authors who are not reviewers
            // Only include authors with at least one "real" comment (not system/codeChange)
            const reviewerIds = new Set((reviewers || []).map(r => r.id));
            const otherAuthors = new Map();

            threads.forEach(thread => {
                if (thread.isDeleted) return;
                const firstComment = thread.comments && thread.comments[0];
                const author = firstComment?.author;
                const commentType = firstComment?.commentType;

                // Skip system (3/'system') and codeChange (2/'codeChange') comments
                const isRealComment = commentType === 1 || commentType === 'text';

                if (author && author.id && isRealComment && !reviewerIds.has(author.id) && !otherAuthors.has(author.id)) {
                    otherAuthors.set(author.id, author);
                }
            });

            if (otherAuthors.size === 0) {
                return '';
            }

            const avatarsHtml = Array.from(otherAuthors.values()).map(author => {
                const count = threadCounts[author.id] || 0;
                return renderAvatarWithBadges(author, undefined, count, author.id === prAuthorId);
            }).join('');

            return `
                <div class="avatars-section">
                    <h4>Other Thread Authors</h4>
                    <div class="avatars-container">${avatarsHtml}</div>
                </div>
            `;
        }

        // Live updates toggle
        function toggleLiveUpdates() {
            liveUpdatesEnabled = !liveUpdatesEnabled;
            localStorage.setItem('prThreadsLiveUpdates', liveUpdatesEnabled);

            const toggle = document.getElementById('liveUpdatesToggle');
            if (liveUpdatesEnabled) {
                toggle.classList.add('active');
                const config = ADOConfig.get();
                if (config && currentPRData) startPRPolling(config);
            } else {
                toggle.classList.remove('active');
                stopPRPolling();
            }
        }

        function initLiveUpdatesToggle() {
            const toggle = document.getElementById('liveUpdatesToggle');
            if (liveUpdatesEnabled) {
                toggle.classList.add('active');
            } else {
                toggle.classList.remove('active');
            }
        }

        // PR data polling
        let prChecksData = null;
        let prWorkItems = null;
        let prPollingInterval = null;
        const PR_POLL_INTERVAL = 15000; // 15 seconds

        // Fetch and update PR basic info (status, draft, target branch)
        async function fetchAndUpdatePRInfo(config) {
            try {
                const prData = await ADOAPI.getPR(config, currentPRId);

                // Update status badges
                const statusBadgesEl = document.getElementById('prStatusBadges');
                if (statusBadgesEl) {
                    statusBadgesEl.innerHTML = ADOUI.renderStatusBadge(prData.status, prData);
                }

                // Update target branch
                const targetBranchEl = document.getElementById('prTargetBranch');
                if (targetBranchEl) {
                    targetBranchEl.textContent = prData.targetRefName?.replace('refs/heads/', '') || 'Unknown';
                }

                // Update description if not currently being edited
                const descriptionContentEl = document.getElementById('pr-description-content');
                if (descriptionContentEl && !descriptionContentEl.querySelector('.comment-editor')) {
                    if (prData.description !== currentPRData.description) {
                        descriptionContentEl.innerHTML = prData.description
                            ? `<div class="pr-description">${ADOContent.processContent(prData.description)}</div>`
                            : '<div class="pr-description" style="color: #a19f9d; font-style: italic;">No description</div>';
                    }
                }

                // Update stored PR data first so updateReviewersDisplay uses fresh data
                currentPRData = prData;

                // Update reviewers (only avatar containers, preserving search forms)
                updateReviewersDisplay();
            } catch (error) {
                console.error('Failed to fetch PR info:', error);
            }
        }

        // Fetch and update threads
        async function fetchAndUpdateThreads(config) {
            try {
                const threadsData = await ADOAPI.getPRThreads(config, currentPRId);
                const newThreads = (threadsData.value || []).map((t, idx) => ({ ...t, _originalIndex: idx }));

                // Check if threads changed (compare without _originalIndex for stability)
                const compareThreads = (threads) => JSON.stringify(threads.map(t => {
                    const { _originalIndex, ...rest } = t;
                    return rest;
                }));
                if (compareThreads(newThreads) !== compareThreads(allThreads)) {
                    allThreads = newThreads;
                    buildThreadsByFilePath();
                    updateThreadStats();
                    // Re-apply filters to refresh thread display
                    applyThreadFilters();
                    refreshInlineThreadsIfNeeded();
                }
            } catch (error) {
                console.error('Failed to fetch threads:', error);
            }
        }

        // Update thread stats display
        function updateThreadStats() {
            const container = document.getElementById('threadStatsContainer');
            if (!container) return;

            const statusCounts = allThreads.reduce((acc, thread) => {
                if (thread.isDeleted === true) {
                    acc.deleted = (acc.deleted || 0) + 1;
                } else if (thread.status === undefined) {
                    acc.noStatus = (acc.noStatus || 0) + 1;
                } else {
                    const status = thread.status;
                    acc[status] = (acc[status] || 0) + 1;
                }
                return acc;
            }, {});

            container.innerHTML = `
                <span title="Active">💬 <strong>${statusCounts.active || 0}</strong></span>
                <span title="Resolved" style="color: #107c10;">✅ <strong>${statusCounts.fixed || 0}</strong></span>
                <span title="Closed" style="color: #605e5c;">🔒 <strong>${statusCounts.closed || 0}</strong></span>
                ${statusCounts.pending ? `<span title="Pending" style="color: #8a6d3b;">⏱️ <strong>${statusCounts.pending}</strong></span>` : ''}
                ${statusCounts.wontFix ? `<span title="Won't Fix" style="color: #605e5c;">🚫 <strong>${statusCounts.wontFix}</strong></span>` : ''}
                ${statusCounts.deleted ? `<span title="Deleted" style="color: #a4262c;">🗑️ <strong>${statusCounts.deleted}</strong></span>` : ''}
            `;
        }

        // Fetch and update iterations
        async function fetchAndUpdateIterations(config) {
            try {
                const iterationsData = await ADOAPI.getPRIterations(config, currentPRId);
                const newIterations = iterationsData.value || [];

                // Check if iterations changed
                if (newIterations.length !== allIterations.length) {
                    allIterations = newIterations;

                    // Update iterations count
                    const container = document.getElementById('updatesStatsContainer');
                    if (container) {
                        container.innerHTML = `<span>Updates</span><strong>${allIterations.length}</strong>`;
                    }

                    // Refresh file change stats if we have a new iteration
                    if (allIterations.length > 0) {
                        try {
                            const changesData = await ADOAPI.getPRIterationChanges(config, currentPRId, allIterations.length, 0);
                            const entries = changesData.changeEntries || [];
                            allChangeEntries = entries;
                            fileDiffCache.clear();
                            fileTreeBuilt = false;
                            currentFileChangeStats = calculateFileChangeStats(entries);
                            updateFileStats();
                            // Rebuild file tree if currently in files view
                            if (currentView === 'files') {
                                buildFileTree(allChangeEntries);
                                buildIterationSelector();
                            }
                            // Update files tab count
                            const filesTabBtn = document.querySelector('.view-tab[data-view="files"]');
                            if (filesTabBtn) {
                                filesTabBtn.textContent = `Files (${allChangeEntries.length})`;
                            }
                            // Also refresh line stats
                            fetchLineStatsAsync(config, currentPRData);
                        } catch (e) {
                            console.warn('Failed to fetch file change stats:', e);
                        }
                    }
                }
            } catch (error) {
                console.error('Failed to fetch iterations:', error);
            }
        }

        // Update file stats display
        function updateFileStats() {
            const container = document.getElementById('fileStatsContainer');
            if (!container || !currentFileChangeStats) return;

            container.innerHTML = `
                <span>Files</span>
                <strong style="color: #107c10;" title="Added">+${currentFileChangeStats.added}</strong>
                <strong style="color: #0078d4;" title="Modified">~${currentFileChangeStats.modified}</strong>
                <strong style="color: #a4262c;" title="Deleted">-${currentFileChangeStats.deleted}</strong>
            `;
        }

        // Fetch and update checks (statuses, policies, conflicts)
        async function fetchAndUpdateChecks(config, prData) {
            try {
                const projectId = prData.repository?.project?.id || config.project;
                prChecksData = await ChecksFormatter.fetchPRChecks(
                    config,
                    config.project,
                    config.repository,
                    prData.pullRequestId,
                    projectId,
                    prData.mergeStatus
                );
                updateChecksDisplay();
            } catch (error) {
                console.error('Failed to fetch checks:', error);
            }
        }

        // Fetch and update work items
        async function fetchAndUpdateWorkItems(config, prId) {
            try {
                const refsData = await ADOAPI.getPRWorkItemRefs(config, prId);
                const refs = refsData.value || [];
                if (refs.length > 0) {
                    const ids = refs.map(r => r.id);
                    const detailsData = await ADOAPI.getWorkItemsBatch(config, ids);
                    prWorkItems = detailsData.value || [];
                } else {
                    prWorkItems = [];
                }
                const container = document.getElementById('rightSidebarWorkItems');
                if (container) {
                    container.innerHTML = renderWorkItemsSection();
                }
            } catch (error) {
                console.warn('Failed to fetch work items:', error);
                prWorkItems = [];
            }
        }

        // Legacy alias for fetchAndUpdateChecks
        async function fetchPRChecks(config, prData) {
            await fetchAndUpdateChecks(config, prData);
        }

        // Poll all PR data
        async function pollPRData(config) {
            if (document.hidden) return; // Don't poll if tab is hidden

            await Promise.all([
                fetchAndUpdatePRInfo(config),
                fetchAndUpdateThreads(config),
                fetchAndUpdateIterations(config),
                fetchAndUpdateChecks(config, currentPRData)
            ]);
        }

        function startPRPolling(config) {
            if (!liveUpdatesEnabled) return; // Live updates disabled by user
            if (prPollingInterval) return; // Already polling

            prPollingInterval = setInterval(() => pollPRData(config), PR_POLL_INTERVAL);
        }

        function stopPRPolling() {
            if (prPollingInterval) {
                clearInterval(prPollingInterval);
                prPollingInterval = null;
            }
        }

        // Refresh all data when tab becomes visible
        document.addEventListener('visibilitychange', () => {
            if (!document.hidden && liveUpdatesEnabled && currentPRData) {
                const config = ADOConfig.get();
                if (config) pollPRData(config);
            }
        });

        // Cleanup on page unload
        window.addEventListener('beforeunload', stopPRPolling);

        function updateChecksDisplay() {
            const container = document.getElementById('rightSidebarChecks');
            if (!container) return;

            container.innerHTML = renderChecksSection();

            // Attach click handlers for queue build buttons
            container.querySelectorAll('.queue-build-btn').forEach(btn => {
                btn.addEventListener('click', async (e) => {
                    const evaluationId = btn.dataset.evaluationId;
                    if (!evaluationId || !currentPRData) return;

                    btn.disabled = true;
                    btn.textContent = '⏳';

                    try {
                        const config = ADOConfig.get();
                        await ADOAPI.requeuePolicyEvaluation(config, config.project, evaluationId);

                        // Refresh checks after queueing
                        await fetchPRChecks(config, currentPRData);
                    } catch (err) {
                        alert(`Failed to queue build: ${err.message}`);
                        btn.disabled = false;
                        btn.textContent = '▶';
                    }
                });
            });
        }

        // Use shared utilities from common.js
        const getStatusIcon = ChecksFormatter.getIcon.bind(ChecksFormatter);
        const getStatusClass = ChecksFormatter.getClass.bind(ChecksFormatter);

        function renderWorkItemsSection() {
            if (!prWorkItems) {
                return '';
            }
            if (prWorkItems.length === 0) {
                return `
                    <div class="work-items-section">
                        <h4>Work Items</h4>
                        <span class="no-reviewers">None</span>
                    </div>
                `;
            }

            const workItemTypeIcons = {
                'Bug': '🐛',
                'Task': '📋',
                'User Story': '📖',
                'Feature': '🚀',
                'Epic': '⚡',
                'Issue': '⚠️',
                'Test Case': '🧪',
                'Impediment': '🚧',
            };

            const itemsHtml = prWorkItems.map(wi => {
                const typeName = wi.fields?.['System.WorkItemType'] || '';
                const title = wi.fields?.['System.Title'] || `Work Item ${wi.id}`;
                const state = wi.fields?.['System.State'] || '';
                const icon = workItemTypeIcons[typeName] || '📌';
                const wiUrl = `${currentConfig.serverUrl}/${currentConfig.organization}/${currentConfig.project}/_workitems/edit/${wi.id}`;

                return `<div class="work-item-entry">
                    <a href="${wiUrl}" target="_blank" rel="noopener" title="${ADOContent.escapeHtml(typeName)}${state ? ' - ' + ADOContent.escapeHtml(state) : ''}">
                        <span class="work-item-icon">${icon}</span>
                        <span class="work-item-id">${wi.id}</span>
                        <span class="work-item-title">${ADOContent.escapeHtml(title)}</span>
                    </a>
                </div>`;
            }).join('');

            return `
                <div class="work-items-section">
                    <h4>Work Items</h4>
                    ${itemsHtml}
                </div>
            `;
        }

        function renderChecksSection() {
            if (!prChecksData) {
                return `
                    <div class="checks-section">
                        <h4>Checks</h4>
                        <div class="checks-loading">Loading...</div>
                    </div>
                `;
            }

            const sections = [];
            const { statuses, policies, conflicts, mergeStatus } = prChecksData;

            // Merge conflicts section
            if (mergeStatus === 'conflicts') {
                let conflictHtml = '<div class="check-group"><div class="check-group-header status-indicator-error">⚠️ Merge Conflicts</div>';
                if (conflicts.length > 0) {
                    conflictHtml += '<ul class="check-list">';
                    conflicts.forEach(c => {
                        const path = c.conflictPath || c.filePath || c.sourceFilePath || c.targetFilePath || c.path || 'Unknown file';
                        conflictHtml += `<li class="check-item"><code>${ADOContent.escapeHtml(path)}</code></li>`;
                    });
                    conflictHtml += '</ul>';
                } else {
                    conflictHtml += '<div class="check-item-note">Unable to load conflict details</div>';
                }
                conflictHtml += '</div>';
                sections.push(conflictHtml);
            } else if (mergeStatus && mergeStatus !== 'succeeded' && mergeStatus !== 'notSet') {
                // Other merge issues
                let mergeText = '';
                switch (mergeStatus) {
                    case 'rejectedByPolicy': mergeText = '🚫 Rejected by policy'; break;
                    case 'queued': mergeText = '⏳ Merge queued'; break;
                    case 'failure': mergeText = '❌ Merge failed'; break;
                }
                if (mergeText) {
                    sections.push(`<div class="check-group"><div class="check-group-header ${getStatusClass(mergeStatus)}">${mergeText}</div></div>`);
                }
            }

            // Status checks section - use improved deduplication from common.js
            const statusList = ChecksFormatter.getLatestStatuses(statuses);
            if (statusList.length > 0) {
                const failed = statusList.filter(s => s.state === 'failed' || s.state === 'error');
                const pending = statusList.filter(s => s.state === 'pending' || !s.state);
                const succeeded = statusList.filter(s => s.state === 'succeeded');

                let checksHtml = '<div class="check-group"><div class="check-group-header">📊 Status Checks</div><ul class="check-list">';

                // Show failed first, then pending, then succeeded
                [...failed, ...pending, ...succeeded].forEach(s => {
                    const info = ChecksFormatter.formatStatus(s);
                    const icon = getStatusIcon(s.state || 'pending');
                    const cls = getStatusClass(s.state || 'pending');
                    const desc = s.description ? ` - ${ADOContent.escapeHtml(s.description)}` : '';

                    if (info.url) {
                        checksHtml += `<li class="check-item ${cls}"><span class="check-icon">${icon}</span> <a href="${ADOContent.escapeHtml(info.url)}" target="_blank" rel="noopener">${ADOContent.escapeHtml(info.name)}</a>${desc}</li>`;
                    } else {
                        checksHtml += `<li class="check-item ${cls}"><span class="check-icon">${icon}</span> ${ADOContent.escapeHtml(info.name)}${desc}</li>`;
                    }
                });

                checksHtml += '</ul></div>';
                sections.push(checksHtml);
            }

            // Build policies section - separate with SVG icons
            const buildPolicies = policies.filter(p => ChecksFormatter.isBuildPolicy(p));
            if (buildPolicies.length > 0) {
                // Sort by state: failed, expired, notTriggered, running, queued, succeeded
                const stateOrder = { failed: 0, expired: 1, notTriggered: 2, running: 3, queued: 4, succeeded: 5 };
                const sorted = buildPolicies.sort((a, b) => {
                    const stateA = ChecksFormatter.getBuildState(a);
                    const stateB = ChecksFormatter.getBuildState(b);
                    return (stateOrder[stateA] ?? 5) - (stateOrder[stateB] ?? 5);
                });

                let buildHtml = '<div class="check-group"><div class="check-group-header">🔧 Builds</div><ul class="check-list">';

                sorted.forEach(p => {
                    const state = ChecksFormatter.getBuildState(p);
                    const icon = ChecksFormatter.getBuildStatusSvg(state, 14);
                    const stateClasses = { expired: 'status-indicator-expired', notTriggered: 'status-indicator-not-triggered' };
                    const cls = stateClasses[state] || getStatusClass(p.status);
                    const { label, extra } = ChecksFormatter.formatPolicy(p);
                    const extraHtml = extra ? ` <span class="check-extra">${extra}</span>` : '';

                    // Queue button for builds that can be queued/requeued
                    const canQueue = ['notTriggered', 'failed', 'succeeded', 'expired'].includes(state);
                    const evaluationId = p.evaluationId;
                    let queueBtn = '';
                    if (canQueue && evaluationId) {
                        const tooltip = state === 'notTriggered' ? 'Queue build' : 'Requeue build';
                        queueBtn = `<button class="queue-build-btn" data-evaluation-id="${evaluationId}" title="${tooltip}"><svg height="16" viewBox="0 0 32 32" width="16"><circle cx="16" cy="16" r="16" fill="#0078d4"/><path d="M12 9v14l12-7z" fill="#fff"/></svg></button>`;
                    }

                    buildHtml += `<li class="check-item ${cls}"><span class="check-icon">${icon}</span> ${ADOContent.escapeHtml(label)}${extraHtml}${queueBtn}</li>`;
                });

                buildHtml += '</ul></div>';
                sections.push(buildHtml);
            }

            // Non-build policy evaluations section
            const nonBuildPolicies = policies.filter(p => !ChecksFormatter.isBuildPolicy(p));
            if (nonBuildPolicies.length > 0) {
                const rejected = nonBuildPolicies.filter(e => e.status === 'rejected');
                const running = nonBuildPolicies.filter(e => e.status === 'running' || e.status === 'queued');
                const approved = nonBuildPolicies.filter(e => e.status === 'approved');

                let policyHtml = '<div class="check-group"><div class="check-group-header">📋 Policies</div><ul class="check-list">';

                // Show rejected first, then running, then approved
                [...rejected, ...running, ...approved].forEach(p => {
                    const icon = getStatusIcon(p.status);
                    const cls = getStatusClass(p.status);
                    const { label, extra } = ChecksFormatter.formatPolicy(p);
                    const extraHtml = extra ? ` <span class="check-extra">${extra}</span>` : '';

                    policyHtml += `<li class="check-item ${cls}"><span class="check-icon">${icon}</span> ${ADOContent.escapeHtml(label)}${extraHtml}</li>`;
                });

                policyHtml += '</ul></div>';
                sections.push(policyHtml);
            }

            if (sections.length === 0) {
                return '';
            }

            return `
                <div class="checks-section">
                    <h4>Checks</h4>
                    ${sections.join('')}
                </div>
            `;
        }

        // Parse URL parameters on load
        window.addEventListener('DOMContentLoaded', () => {
            const urlParams = ADOURL.getParams();
            currentPRId = urlParams.get('prId') || urlParams.get('id');
            urlProject = urlParams.get('project');
            urlRepo = urlParams.get('repo');

            // Set up PR action modal event listeners
            const prActionModal = document.getElementById('prActionModal');
            if (prActionModal) {
                prActionModal.addEventListener('click', (e) => {
                    if (e.target.id === 'prActionModal') {
                        closePRActionModal();
                    }
                });
            }
            document.addEventListener('keydown', (e) => {
                if (e.key === 'Escape' && document.getElementById('prActionModal')?.classList.contains('show')) {
                    closePRActionModal();
                }
                // Jump navigation in files view
                if (currentView === 'files' && e.altKey && !e.ctrlKey && !e.metaKey) {
                    // Alt+Up/Down: thread navigation
                    if (e.key === 'ArrowDown') { e.preventDefault(); jumpToNextThread(); }
                    else if (e.key === 'ArrowUp') { e.preventDefault(); jumpToPrevThread(); }
                    // Alt+Left/Right: hunk (modification) navigation
                    else if (e.key === 'ArrowRight') { e.preventDefault(); jumpToNextHunk(); }
                    else if (e.key === 'ArrowLeft') { e.preventDefault(); jumpToPrevHunk(); }
                }
            });

            // Load saved configuration from localStorage
            const savedConfig = ADOConfig.get();
            if (savedConfig) {
                document.getElementById('serverUrl').value = savedConfig.serverUrl || '';
                document.getElementById('organization').value = savedConfig.organization || '';
                // Use URL params if provided, otherwise fall back to saved config
                document.getElementById('project').value = urlProject || savedConfig.project || '';
                document.getElementById('repository').value = urlRepo || savedConfig.repository || '';
            }

            // Initialize live updates toggle from saved preference
            initLiveUpdatesToggle();

            // Auto-load or show config
            if (currentPRId) {
                // Auto-load if config is valid (repo can come from URL or saved config)
                const hasRepo = urlRepo || (savedConfig && savedConfig.repository);
                if (savedConfig && ADOConfig.isValid(savedConfig) && hasRepo) {
                    setTimeout(() => loadPRThreads(), 100);
                } else {
                    // Show config section if settings are missing
                    document.getElementById('configSection').style.display = 'block';
                    const statusDiv = document.getElementById('configStatus');
                    statusDiv.innerHTML = '⚠️ Some settings are missing. <a href="ado-settings.html" style="color: #0078d4;">Configure in Settings</a> or use Advanced Configuration below.';
                    statusDiv.style.color = '#8a6d3b';
                }
            } else {
                showNoPRError();
            }
        });

        function showNoPRError() {
            document.getElementById('results').innerHTML = `
                <div class="warning">
                    <strong>⚠️ No Pull Request specified</strong><br>
                    Please navigate from the <a href="ado-pr-list.html" style="color: #0078d4; font-weight: 600;">PR List page</a>
                    or provide a PR ID in the URL (e.g., ?prId=123).
                </div>
            `;
        }

        // URL parameter helpers
        function getURLParams() {
            const params = new URLSearchParams(window.location.search);
            const statusParam = params.get('status');
            return {
                prId: params.get('prId') || params.get('id') || null,
                status: statusParam ? (statusParam === 'none' ? [] : statusParam.split(',')) : null,
                showDeleted: params.get('showDeleted') !== null ? params.get('showDeleted') === 'true' : null,
                author: params.get('author') || null,
                commentAuthor: params.get('commentAuthor') || null,
                search: params.get('search') || null,
                view: params.get('view') || null
            };
        }

        function updateURL() {
            if (isRestoringFromURL) return;

            const params = new URLSearchParams();

            // PR ID
            if (currentPRId) {
                params.set('prId', currentPRId);
            }

            // Preserve project and repo from original URL
            if (urlProject) params.set('project', urlProject);
            if (urlRepo) params.set('repo', urlRepo);

            // Thread status filters
            // Always include status parameter to preserve chip selection state (even if none selected)
            const selectedStatuses = getSelectedThreadStatuses();
            params.set('status', selectedStatuses.length > 0 ? selectedStatuses.join(',') : 'none');

            // Show deleted checkbox
            const showDeleted = document.getElementById('showDeleted').checked;
            if (showDeleted) {  // Only add to URL if checked (default is unchecked)
                params.set('showDeleted', 'true');
            }

            // Author filter
            const author = document.getElementById('threadAuthorFilter').value;
            if (author) {
                params.set('author', author);
            }

            // Comment author filter
            const commentAuthor = document.getElementById('commentAuthorFilter').value;
            if (commentAuthor) {
                params.set('commentAuthor', commentAuthor);
            }

            // Search filter
            const search = document.getElementById('searchFilter').value.trim();
            if (search) {
                params.set('search', search);
            }

            // View (files/overview)
            if (currentView === 'files') {
                params.set('view', 'files');
            }

            const newURL = params.toString() ? `${window.location.pathname}?${params.toString()}` : window.location.pathname;
            history.replaceState(null, '', newURL);
        }

        function restoreFiltersFromURL() {
            const urlParams = getURLParams();
            isRestoringFromURL = true;

            try {
                // Restore status chips
                // If status param exists in URL (even if empty/none), restore that selection
                // If status param is missing, keep HTML defaults
                if (urlParams.status !== null) {
                    // First deselect all status chips
                    document.querySelectorAll('.sidebar .status-chip').forEach(chip => {
                        chip.classList.remove('selected');
                    });

                    // Then select only the ones in the URL (if any)
                    urlParams.status.forEach(status => {
                        const chip = document.querySelector(`.sidebar .status-chip[data-status="${status}"]`);
                        if (chip) {
                            chip.classList.add('selected');
                        }
                    });
                }

                // Restore showDeleted checkbox
                if (urlParams.showDeleted !== null) {
                    document.getElementById('showDeleted').checked = urlParams.showDeleted;
                }

                // Restore author filter
                if (urlParams.author) {
                    const authorSelect = document.getElementById('threadAuthorFilter');
                    // Check if the option exists (it might not be populated yet)
                    const option = Array.from(authorSelect.options).find(opt => opt.value === urlParams.author);
                    if (option) {
                        authorSelect.value = urlParams.author;
                    }
                }

                // Restore comment author filter
                if (urlParams.commentAuthor) {
                    const commentAuthorSelect = document.getElementById('commentAuthorFilter');
                    const option = Array.from(commentAuthorSelect.options).find(opt => opt.value === urlParams.commentAuthor);
                    if (option) {
                        commentAuthorSelect.value = urlParams.commentAuthor;
                    }
                }

                // Restore search filter
                if (urlParams.search) {
                    document.getElementById('searchFilter').value = urlParams.search;
                }
            } finally {
                isRestoringFromURL = false;
            }

            // Apply filters to show the filtered results
            applyThreadFilters();
        }

        async function loadPRThreads() {
            const savedConfig = ADOConfig.get() || {};
            const formConfig = ADOConfig.getFromForm({});
            const urlParams = ADOURL.getParams();

            // Priority: URL params > form values > saved config
            const config = {
                serverUrl: formConfig.serverUrl || savedConfig.serverUrl,
                organization: formConfig.organization || savedConfig.organization,
                project: urlParams.get('project') || formConfig.project || savedConfig.project,
                repository: urlParams.get('repo') || formConfig.repository || savedConfig.repository,
                pat: savedConfig.pat
            };

            // Validation
            if (!currentPRId) {
                showNoPRError();
                return;
            }

            if (!ADOConfig.isValid(config) || !config.repository) {
                ADOUI.showError('results', 'Please fill in all fields. PAT must be configured in <a href="ado-settings.html" style="color: #0078d4;">Settings</a>.');
                document.getElementById('configSection').style.display = 'block';
                return;
            }

            // Save configuration (only base settings, not project/repo which may come from URL)
            ADOConfig.save({
                serverUrl: config.serverUrl,
                organization: config.organization,
                pat: config.pat,
                project: savedConfig.project || config.project,
                repository: savedConfig.repository || config.repository
            });

            ADOUI.showLoading('results', 'Loading PR threads...');

            // Reset checks and work items data for new PR
            prChecksData = null;
            prWorkItems = null;

            try {
                // Clear caches for new PR
                iterationChangesCache.clear();
                filePathHistoryCache.clear();

                // Fetch PR details, threads, and iterations in parallel
                const [prData, threadsData, iterationsData] = await Promise.all([
                    ADOAPI.getPR(config, currentPRId),
                    ADOAPI.getPRThreads(config, currentPRId),
                    ADOAPI.getPRIterations(config, currentPRId)
                ]);

                allThreads = (threadsData.value || []).map((t, idx) => ({ ...t, _originalIndex: idx }));
                allIterations = iterationsData.value || [];
                currentPRData = prData;
                currentConfig = config;

                // Fetch file change stats from the latest iteration compared to base (cumulative)
                let fileChangeStats = null;
                if (allIterations.length > 0) {
                    try {
                        const changesData = await ADOAPI.getPRIterationChanges(config, currentPRId, allIterations.length, 0);
                        const entries = changesData.changeEntries || [];
                        allChangeEntries = entries;
                        fileDiffCache.clear();
                        fileTreeBuilt = false;
                        fileChangeStats = calculateFileChangeStats(entries);
                    } catch (e) {
                        console.warn('Failed to fetch file change stats:', e);
                    }
                }
                currentFileChangeStats = fileChangeStats;

                // Resolve merge base for file diffs and line stats
                currentMergeBase = await resolveMergeBase(config);

                // Build thread-to-file mapping
                buildThreadsByFilePath();

                // Debug: Log unique status values found in threads
                const uniqueStatuses = new Set(allThreads.map(t => t.status));
                console.log('Loaded threads. Unique status values found:', Array.from(uniqueStatuses));
                console.log('Sample threads with their statuses:', allThreads.slice(0, 5).map(t => ({ id: t.id, status: t.status })));

                // Pre-populate identity cache from thread authors, reviewers, PR author
                ADOIdentity.populateCacheFromKnownIdentities(allThreads, currentPRData);
                // Resolve any remaining @mention identities not found in known data
                await ADOIdentity.collectAndResolveFromThreads(allThreads, config.serverUrl, config.organization, config.pat, [currentPRData?.description]);

                // Show filters
                document.getElementById('threadFilters').style.display = 'block';

                // Populate author filter
                populateAuthorFilter();

                // Restore filters from URL (if any) and apply
                restoreFiltersFromURL();

                // Start background repo tree preload
                preloadRepoTree();

            } catch (error) {
                ADOUI.showError('results', error.message);
            }
        }

        function populateAuthorFilter() {
            const threadAuthorFilter = document.getElementById('threadAuthorFilter');
            const commentAuthorFilter = document.getElementById('commentAuthorFilter');
            const threadAuthors = new Set();
            const allCommentAuthors = new Set();

            allThreads.forEach(thread => {
                if (thread.comments && thread.comments.length > 0) {
                    // Collect first comment authors for thread author filter
                    const firstComment = thread.comments[0];
                    if (firstComment.author && firstComment.author.displayName) {
                        threadAuthors.add(firstComment.author.displayName);
                    }

                    // Collect all comment authors for comment author filter
                    thread.comments.forEach(comment => {
                        if (comment.author && comment.author.displayName) {
                            allCommentAuthors.add(comment.author.displayName);
                        }
                    });
                }
            });

            // Populate thread author filter
            let threadAuthorHtml = '<option value="">All authors</option>';
            Array.from(threadAuthors).sort().forEach(author => {
                threadAuthorHtml += `<option value="${ADOContent.escapeHtml(author)}">${ADOContent.escapeHtml(author)}</option>`;
            });
            threadAuthorFilter.innerHTML = threadAuthorHtml;

            // Populate comment author filter
            let commentAuthorHtml = '<option value="">All users</option>';
            Array.from(allCommentAuthors).sort().forEach(author => {
                commentAuthorHtml += `<option value="${ADOContent.escapeHtml(author)}">${ADOContent.escapeHtml(author)}</option>`;
            });
            commentAuthorFilter.innerHTML = commentAuthorHtml;
        }

        function applyThreadFilters(skipFormRestore = false) {
            const showDeleted = document.getElementById('showDeleted').checked;
            const selectedStatuses = getSelectedThreadStatuses();
            const selectedAuthor = document.getElementById('threadAuthorFilter').value;
            const selectedCommentAuthor = document.getElementById('commentAuthorFilter').value;
            const searchText = document.getElementById('searchFilter').value.trim();

            const filtered = allThreads.filter(thread => {
                // Deleted filter
                if (!showDeleted && thread.isDeleted === true) {
                    return false;
                }

                // Status filter
                // Distinguish between undefined (no status) and "unknown" (actual status value)
                if (selectedStatuses.length > 0) {
                    if (thread.status === undefined) {
                        // Thread has no status field
                        if (!selectedStatuses.includes('noStatus')) {
                            return false;
                        }
                    } else {
                        // Thread has a status field
                        // Lowercase both the thread status and selected statuses for comparison
                        // (selectedStatuses contains camelCase values like 'wontFix', 'active', etc.)
                        const status = thread.status.toLowerCase();
                        const selectedStatusesLower = selectedStatuses.map(s => s.toLowerCase());
                        if (!selectedStatusesLower.includes(status)) {
                            return false;
                        }
                    }
                }

                // Author filter (first comment author)
                if (selectedAuthor) {
                    if (!thread.comments || thread.comments.length === 0) {
                        return false;
                    }
                    const firstComment = thread.comments[0];
                    if (!firstComment.author || firstComment.author.displayName !== selectedAuthor) {
                        return false;
                    }
                }

                // Comment author filter (any comment from selected user)
                if (selectedCommentAuthor) {
                    if (!thread.comments || thread.comments.length === 0) {
                        return false;
                    }
                    const hasCommentFromUser = thread.comments.some(comment =>
                        comment.author && comment.author.displayName === selectedCommentAuthor
                    );
                    if (!hasCommentFromUser) {
                        return false;
                    }
                }

                // Search filter (search in all comment content)
                if (searchText) {
                    if (!thread.comments || thread.comments.length === 0) {
                        return false;
                    }
                    const searchNorm = ADOSearch.normalize(searchText);
                    const hasMatchingContent = thread.comments.some(comment =>
                        comment.content && ADOSearch.normalize(comment.content).includes(searchNorm)
                    );
                    if (!hasMatchingContent) {
                        return false;
                    }
                }

                return true;
            });

            // Sort threads by creation date descending
            // If dates are equal, reverse original order (later in array = first in display)
            filtered.sort((a, b) => {
                const dateA = a.comments?.[0]?.publishedDate || '';
                const dateB = b.comments?.[0]?.publishedDate || '';

                if (dateA !== dateB) {
                    // Different dates: sort descending (newest first)
                    return dateB.localeCompare(dateA);
                }

                // Same date: use original index (later = higher priority)
                // _originalIndex is set when threads are loaded
                const idxA = a._originalIndex ?? 0;
                const idxB = b._originalIndex ?? 0;
                return idxB - idxA;
            });

            // Update counts
            document.getElementById('totalCount').textContent = allThreads.length;
            document.getElementById('filteredCount').textContent = filtered.length;

            // Save form state before re-render (skip if this is after a CRUD operation)
            const formState = skipFormRestore ? null : saveFormState();

            // Display filtered threads
            displayResults(currentPRData, filtered, allIterations, currentConfig);

            // Restore form state after re-render
            if (!skipFormRestore) {
                restoreFormState(formState);
            }

            // Update URL with current filter state
            updateURL();
        }

        function toggleStatusChip(button) {
            button.classList.toggle('selected');
            applyThreadFilters();
        }

        function getSelectedThreadStatuses() {
            const selectedChips = document.querySelectorAll('.sidebar .status-chip.selected');
            return Array.from(selectedChips).map(chip => {
                // Return original camelCase value (e.g., 'wontFix', 'noStatus', 'active')
                // This preserves the exact data-status attribute value for URL persistence
                return chip.dataset.status;
            });
        }

        function toggleBulkMode() {
            isBulkMode = !isBulkMode;
            selectedThreadIds.clear();

            const button = document.getElementById('bulkModeToggle');
            const bulkActions = document.getElementById('bulkActions');
            const filters = document.querySelectorAll('.sidebar .filter-section');

            if (isBulkMode) {
                button.textContent = 'Disable Bulk Selection';
                button.classList.remove('btn-secondary');
                button.classList.add('btn-primary');
                bulkActions.classList.add('show');

                // Disable filters in bulk mode
                filters.forEach(row => {
                    const inputs = row.querySelectorAll('input, select');
                    inputs.forEach(input => input.disabled = true);
                });
            } else {
                button.textContent = 'Enable Bulk Selection';
                button.classList.remove('btn-primary');
                button.classList.add('btn-secondary');
                bulkActions.classList.remove('show');

                // Enable filters
                filters.forEach(row => {
                    const inputs = row.querySelectorAll('input, select');
                    inputs.forEach(input => input.disabled = false);
                });
            }

            // Refresh display to show/hide checkboxes
            applyThreadFilters();
        }

        function toggleThreadSelection(threadId) {
            if (selectedThreadIds.has(threadId)) {
                selectedThreadIds.delete(threadId);
            } else {
                selectedThreadIds.add(threadId);
            }

            // Update selected count
            document.getElementById('selectedCount').textContent = selectedThreadIds.size;

            // Update checkbox state
            const checkbox = document.getElementById(`thread-checkbox-${threadId}`);
            if (checkbox) {
                checkbox.checked = selectedThreadIds.has(threadId);
            }
        }

        function selectAllThreads() {
            selectedThreadIds.clear();

            // Get all visible thread IDs
            const checkboxes = document.querySelectorAll('.thread-checkbox');
            checkboxes.forEach(checkbox => {
                const threadId = checkbox.dataset.threadId;
                selectedThreadIds.add(threadId);
                checkbox.checked = true;
            });

            document.getElementById('selectedCount').textContent = selectedThreadIds.size;
        }

        function deselectAllThreads() {
            selectedThreadIds.clear();

            const checkboxes = document.querySelectorAll('.thread-checkbox');
            checkboxes.forEach(checkbox => {
                checkbox.checked = false;
            });

            document.getElementById('selectedCount').textContent = 0;
        }

        async function changeThreadStatus(threadId, newStatus) {
            if (!currentConfig || !currentPRId || !newStatus) return;

            try {
                console.log(`Attempting to change thread ${threadId} status to: ${newStatus}`);
                const updatedThread = await ADOAPI.updateThreadStatus(currentConfig, currentPRId, threadId, newStatus);
                console.log(`API returned status:`, updatedThread.status);
                console.log(`Full updated thread:`, updatedThread);

                // Update local thread data with response from API
                // Note: threadId from onclick is a string, but thread.id is a number
                const thread = allThreads.find(t => t.id == threadId);
                if (thread && updatedThread) {
                    const oldStatus = thread.status;
                    thread.status = updatedThread.status;
                    thread.properties = updatedThread.properties;
                    console.log(`Updated local thread from ${oldStatus} to ${thread.status}`);
                } else {
                    console.warn(`Could not find thread ${threadId} in allThreads to update locally`);
                }

                // Refresh display to show updated badge
                applyThreadFilters();
                refreshInlineThreadsIfNeeded();

                return true;
            } catch (error) {
                console.error(`Failed to update thread status:`, error);
                alert(`Failed to update thread status: ${error.message}\n\nNote: This requires a PAT with "Code (Write)" permissions.`);
                return false;
            }
        }

        async function removeThreadStatus(threadId) {
            if (!currentConfig || !currentPRId) return;

            const confirmed = confirm('Are you sure you want to remove the status from this thread?');
            if (!confirmed) return;

            try {
                console.log(`Attempting to remove status from thread ${threadId}`);
                const updatedThread = await ADOAPI.removeThreadStatus(currentConfig, currentPRId, threadId);
                console.log(`API returned after removing status:`, updatedThread);

                // Update local thread data with response from API
                // Note: threadId from onclick is a string, but thread.id is a number
                const thread = allThreads.find(t => t.id == threadId);
                if (thread && updatedThread) {
                    thread.status = updatedThread.status;
                    thread.properties = updatedThread.properties;
                    console.log(`Removed status from thread, new status:`, thread.status);
                } else {
                    console.warn(`Could not find thread ${threadId} in allThreads to update locally`);
                }

                // Refresh display
                applyThreadFilters();
                refreshInlineThreadsIfNeeded();

                return true;
            } catch (error) {
                console.error(`Failed to remove thread status:`, error);
                alert(`Failed to remove thread status: ${error.message}\n\nNote: This requires a PAT with "Code (Write)" permissions.`);
                return false;
            }
        }

        // ==================== Form State Preservation ====================
        // Save/restore state of reply and edit forms in thread list (new thread form is static)

        function saveFormState() {
            const state = {
                replies: {},
                edits: {}
            };

            // Save reply forms
            document.querySelectorAll('[id^="reply-content-"]').forEach(textarea => {
                const threadId = textarea.id.replace('reply-content-', '');
                state.replies[threadId] = textarea.value;
            });

            // Save edit forms
            document.querySelectorAll('[id^="edit-content-"]').forEach(textarea => {
                const match = textarea.id.match(/edit-content-(\d+)-(\d+)/);
                if (match) {
                    const key = `${match[1]}-${match[2]}`;
                    state.edits[key] = textarea.value;
                }
            });

            return state;
        }

        function restoreFormState(state) {
            if (!state) return;

            // Restore reply forms
            for (const [threadId, content] of Object.entries(state.replies)) {
                showReplyForm(parseInt(threadId));
                const textarea = document.getElementById(`reply-content-${threadId}`);
                if (textarea) {
                    textarea.value = content;
                }
            }

            // Restore edit forms
            for (const [key, content] of Object.entries(state.edits)) {
                const [threadId, commentId] = key.split('-').map(Number);
                startEditComment(threadId, commentId);
                const textarea = document.getElementById(`edit-content-${threadId}-${commentId}`);
                if (textarea) {
                    textarea.value = content;
                }
            }
        }

        // ==================== Comment CRUD Functions ====================

        function showNewThreadForm() {
            const container = document.getElementById('newThreadFormContainer');
            const btn = document.getElementById('newThreadBtn');

            if (container.querySelector('.new-thread-form')) {
                // Already showing, hide it
                container.innerHTML = '';
                btn.style.display = '';
                return;
            }

            btn.style.display = 'none';

            container.innerHTML = `
                <div class="new-thread-form">
                    <h4>New Discussion Thread</h4>
                    <div class="comment-editor">
                        <textarea id="newThreadContent" placeholder="Enter your comment..."></textarea>
                        <div class="comment-editor-actions">
                            <button class="btn-cancel" onclick="hideNewThreadForm()">Cancel</button>
                            <button class="btn-save" onclick="createNewThread()" id="createThreadBtn">Create Thread</button>
                        </div>
                    </div>
                </div>
            `;

            const newThreadTextarea = document.getElementById('newThreadContent');
            newThreadTextarea.focus();
            MentionAutocomplete.attach(newThreadTextarea);
        }

        function hideNewThreadForm() {
            document.getElementById('newThreadFormContainer').innerHTML = '';
            document.getElementById('newThreadBtn').style.display = '';
        }

        async function createNewThread() {
            const content = resolveMentionsForSubmit(document.getElementById('newThreadContent'));
            if (!content) {
                alert('Please enter a comment.');
                return;
            }

            const btn = document.getElementById('createThreadBtn');
            btn.disabled = true;
            btn.textContent = 'Creating...';

            try {
                await ADOAPI.createThread(currentConfig, currentPRId, content);
                hideNewThreadForm();
                await refreshThreadsFromAPI();

            } catch (error) {
                console.error('Failed to create thread:', error);
                alert(`Failed to create thread: ${error.message}\n\nNote: This requires a PAT with "Code (Write)" permissions.`);
                btn.disabled = false;
                btn.textContent = 'Create Thread';
            }
        }

        // ==================== Thread CRUD (unified for Overview and Files view) ====================
        // Both views use the same logic with different DOM ID prefixes:
        //   Overview: prefix = ''     → IDs like reply-form-{id}, comment-content-{id}-{cid}
        //   Inline:   prefix = 'inline-' → IDs like inline-reply-form-{id}, inline-comment-content-{id}-{cid}

        /**
         * Refresh threads from API after a mutation (reply, edit, delete).
         * Updates allThreads, stats, filters, and re-renders inline threads if in Files view.
         */
        async function refreshThreadsFromAPI() {
            const threadsData = await ADOAPI.getPRThreads(currentConfig, currentPRId);
            allThreads = (threadsData.value || []).map((t, idx) => ({ ...t, _originalIndex: idx }));
            updateThreadStats();
            applyThreadFilters(true);
            refreshInlineThreadsIfNeeded();
        }

        function showReplyForm(threadId, prefix = '') {
            const container = document.getElementById(`${prefix}reply-form-${threadId}`);
            const btn = document.getElementById(`${prefix}reply-btn-${threadId}`);
            if (!container || container.querySelector('.comment-editor')) return;
            if (btn) btn.style.display = 'none';

            container.innerHTML = `
                <div class="comment-editor">
                    <textarea id="${prefix}reply-content-${threadId}" placeholder="Write a reply..."></textarea>
                    <div class="comment-editor-actions">
                        <button class="btn-cancel" onclick="hideReplyForm(${threadId}, '${prefix}')">Cancel</button>
                        <button class="btn-save" onclick="submitReply(${threadId}, '${prefix}')" id="${prefix}reply-submit-${threadId}">Reply</button>
                    </div>
                </div>
            `;

            const textarea = document.getElementById(`${prefix}reply-content-${threadId}`);
            if (textarea) { textarea.focus(); MentionAutocomplete.attach(textarea); }
        }

        function hideReplyForm(threadId, prefix = '') {
            const container = document.getElementById(`${prefix}reply-form-${threadId}`);
            if (container) container.innerHTML = '';
            const btn = document.getElementById(`${prefix}reply-btn-${threadId}`);
            if (btn) btn.style.display = '';
        }

        async function submitReply(threadId, prefix = '') {
            const content = resolveMentionsForSubmit(document.getElementById(`${prefix}reply-content-${threadId}`));
            if (!content) { alert('Please enter a reply.'); return; }

            const btn = document.getElementById(`${prefix}reply-submit-${threadId}`);
            if (btn) { btn.disabled = true; btn.textContent = 'Sending...'; }

            try {
                await ADOAPI.addComment(currentConfig, currentPRId, threadId, content);
                await refreshThreadsFromAPI();
            } catch (error) {
                console.error('Failed to add reply:', error);
                alert(`Failed to add reply: ${error.message}\n\nNote: This requires a PAT with "Code (Write)" permissions.`);
                if (btn) { btn.disabled = false; btn.textContent = 'Reply'; }
            }
        }

        function startEditComment(threadId, commentId, prefix = '') {
            const contentWrapper = document.getElementById(`${prefix}comment-content-${threadId}-${commentId}`);
            if (!contentWrapper) return;
            const commentDiv = contentWrapper.closest('.comment');
            const originalContent = commentDiv?.dataset.commentContent || '';
            const resolved = MentionUtils.resolveIdsToNames(originalContent, identityCache);
            const escapedContent = resolved.text.replace(/</g, '&lt;').replace(/>/g, '&gt;');

            contentWrapper.dataset.originalHtml = contentWrapper.innerHTML;

            contentWrapper.innerHTML = `
                <div class="comment-editor">
                    <textarea id="${prefix}edit-content-${threadId}-${commentId}">${escapedContent}</textarea>
                    <div class="comment-editor-actions">
                        <button class="btn-cancel" onclick="cancelEditComment(${threadId}, ${commentId}, '${prefix}')">Cancel</button>
                        <button class="btn-save" onclick="saveEditComment(${threadId}, ${commentId}, '${prefix}')" id="${prefix}edit-save-${threadId}-${commentId}">Save</button>
                    </div>
                </div>
            `;

            const textarea = document.getElementById(`${prefix}edit-content-${threadId}-${commentId}`);
            if (textarea) {
                textarea._mentionMap = resolved.mentionMap;
                textarea.focus(); textarea.setSelectionRange(textarea.value.length, textarea.value.length);
                MentionAutocomplete.attach(textarea);
            }

            const actions = commentDiv?.querySelector('.comment-actions');
            if (actions) actions.style.display = 'none';
        }

        function cancelEditComment(threadId, commentId, prefix = '') {
            const contentWrapper = document.getElementById(`${prefix}comment-content-${threadId}-${commentId}`);
            if (!contentWrapper) return;
            const commentDiv = contentWrapper.closest('.comment');

            contentWrapper.innerHTML = contentWrapper.dataset.originalHtml || '';

            const actions = commentDiv?.querySelector('.comment-actions');
            if (actions) actions.style.display = '';
        }

        async function saveEditComment(threadId, commentId, prefix = '') {
            const content = resolveMentionsForSubmit(document.getElementById(`${prefix}edit-content-${threadId}-${commentId}`));
            if (!content) { alert('Comment cannot be empty.'); return; }

            const btn = document.getElementById(`${prefix}edit-save-${threadId}-${commentId}`);
            if (btn) { btn.disabled = true; btn.textContent = 'Saving...'; }

            try {
                await ADOAPI.updateComment(currentConfig, currentPRId, threadId, commentId, content);
                await refreshThreadsFromAPI();
            } catch (error) {
                console.error('Failed to update comment:', error);
                alert(`Failed to update comment: ${error.message}\n\nNote: This requires a PAT with "Code (Write)" permissions.`);
                if (btn) { btn.disabled = false; btn.textContent = 'Save'; }
            }
        }

        function startEditDescription() {
            const contentEl = document.getElementById('pr-description-content');
            const editBtn = document.getElementById('description-edit-btn');
            if (!contentEl) return;

            contentEl.dataset.originalHtml = contentEl.innerHTML;
            const resolved = MentionUtils.resolveIdsToNames(currentPRData.description || '', identityCache);
            const escapedDescription = resolved.text.replace(/</g, '&lt;').replace(/>/g, '&gt;');

            const previewHtml = currentPRData.description
                ? ADOContent.processContent(currentPRData.description)
                : '<span style="color: #a19f9d; font-style: italic;">Nothing to preview</span>';

            contentEl.innerHTML = `
                <div class="comment-editor">
                    <textarea id="edit-description-textarea">${escapedDescription}</textarea>
                    <div class="comment-editor-actions">
                        <button class="btn-cancel" onclick="cancelEditDescription()">Cancel</button>
                        <button class="btn-save" id="edit-description-save" onclick="saveEditDescription()">Save</button>
                    </div>
                </div>
                <div class="description-preview">
                    <div class="description-preview-header">Preview</div>
                    <div class="description-preview-content pr-description" id="edit-description-preview">${previewHtml}</div>
                </div>
            `;

            if (editBtn) editBtn.style.display = 'none';
            const textarea = document.getElementById('edit-description-textarea');
            if (textarea) {
                textarea._mentionMap = resolved.mentionMap;
                textarea.focus();
                textarea.setSelectionRange(textarea.value.length, textarea.value.length);
                textarea.addEventListener('input', updateDescriptionPreview);
                MentionAutocomplete.attach(textarea);
            }
        }

        function updateDescriptionPreview() {
            const textarea = document.getElementById('edit-description-textarea');
            const preview = document.getElementById('edit-description-preview');
            if (!textarea || !preview) return;
            const text = MentionUtils.resolveDisplayMentions(textarea.value, textarea._mentionMap);
            preview.innerHTML = text
                ? ADOContent.processContent(text)
                : '<span style="color: #a19f9d; font-style: italic;">Nothing to preview</span>';
        }

        function cancelEditDescription() {
            const contentEl = document.getElementById('pr-description-content');
            const editBtn = document.getElementById('description-edit-btn');
            if (!contentEl) return;

            contentEl.innerHTML = contentEl.dataset.originalHtml || '';
            if (editBtn) editBtn.style.display = '';
        }

        async function saveEditDescription() {
            const textarea = document.getElementById('edit-description-textarea');
            const btn = document.getElementById('edit-description-save');
            if (!textarea) return;

            const description = resolveMentionsForSubmit(textarea);
            if (btn) { btn.disabled = true; btn.textContent = 'Saving...'; }

            try {
                await ADOAPI.updatePRDescription(currentConfig, currentPRId, description);
                currentPRData.description = description;

                const contentEl = document.getElementById('pr-description-content');
                const editBtn = document.getElementById('description-edit-btn');
                if (contentEl) {
                    contentEl.innerHTML = description
                        ? `<div class="pr-description">${ADOContent.processContent(description)}</div>`
                        : '<div class="pr-description" style="color: #a19f9d; font-style: italic;">No description</div>';
                }
                if (editBtn) editBtn.style.display = '';
            } catch (error) {
                console.error('Failed to update description:', error);
                alert(`Failed to update description: ${error.message}\n\nNote: This requires a PAT with "Code (Write)" permissions.`);
                if (btn) { btn.disabled = false; btn.textContent = 'Save'; }
            }
        }

        async function deleteComment(threadId, commentId) {
            if (!confirm('Are you sure you want to delete this comment?')) return;

            try {
                await ADOAPI.deleteComment(currentConfig, currentPRId, threadId, commentId);
                await refreshThreadsFromAPI();
            } catch (error) {
                console.error('Failed to delete comment:', error);
                alert(`Failed to delete comment: ${error.message}\n\nNote: This requires a PAT with "Code (Write)" permissions.`);
            }
        }

        function toggleInlineThread(threadId) {
            const threadEl = document.querySelector(`.inline-thread[data-thread-id="${threadId}"]`);
            if (!threadEl) return;
            const isCollapsed = threadEl.classList.contains('collapsed');
            threadEl.classList.toggle('collapsed');
            // Show/hide gutter avatar (visible when collapsed, hidden when expanded)
            const avatarEl = document.querySelector(`.diff-gutter-avatar[data-thread-id="${threadId}"]`);
            if (avatarEl) avatarEl.style.display = isCollapsed ? 'none' : '';
        }

        function scrollToThread(threadId) {
            const threadEl = document.querySelector(`.inline-thread[data-thread-id="${threadId}"]`);
            if (!threadEl) return;
            // Expand if collapsed
            if (threadEl.classList.contains('collapsed')) {
                threadEl.classList.remove('collapsed');
                const avatarEl = document.querySelector(`.diff-gutter-avatar[data-thread-id="${threadId}"]`);
                if (avatarEl) avatarEl.style.display = 'none';
            }
            threadEl.scrollIntoView({ behavior: 'smooth', block: 'center' });
            // Highlight focused thread (clear previous, apply fresh)
            clearThreadFocus();
            threadEl.classList.add('focused');
            threadEl.addEventListener('animationend', () => threadEl.classList.remove('focused'), { once: true });
            // Also highlight corresponding file tree entry
            const treeEntry = document.querySelector(`.file-tree-thread[data-thread-id="${threadId}"]`);
            if (treeEntry) {
                treeEntry.classList.add('focused');
                treeEntry.addEventListener('animationend', () => treeEntry.classList.remove('focused'), { once: true });
            }
        }

        function clearThreadFocus() {
            document.querySelectorAll('.inline-thread.focused, .file-tree-thread.focused').forEach(el => el.classList.remove('focused'));
        }

        // Thread jump navigation — sorted thread IDs for the current file
        let currentFileThreadIds = [];
        let currentThreadNavIndex = -1;

        function getSortedFileThreadIds() {
            if (!selectedFilePath) return [];
            const threads = threadsByFilePath.get(selectedFilePath);
            if (!threads || threads.length === 0) return [];
            return [...threads]
                .filter(t => !t.isDeleted && t.threadContext)
                .sort((a, b) => {
                    const lineA = a.threadContext?.rightFileStart?.line || a.threadContext?.leftFileStart?.line || 0;
                    const lineB = b.threadContext?.rightFileStart?.line || b.threadContext?.leftFileStart?.line || 0;
                    if (lineA !== lineB) return lineA - lineB;
                    const offsetA = a.threadContext?.rightFileStart?.offset || a.threadContext?.leftFileStart?.offset || 0;
                    const offsetB = b.threadContext?.rightFileStart?.offset || b.threadContext?.leftFileStart?.offset || 0;
                    return offsetA - offsetB;
                })
                .map(t => t.id);
        }

        function updateThreadNav(jumpedToId) {
            currentFileThreadIds = getSortedFileThreadIds();
            const nav = document.getElementById('threadNav');
            if (!nav) return;
            if (currentFileThreadIds.length === 0) {
                nav.style.display = 'none';
                return;
            }
            nav.style.display = 'flex';
            if (jumpedToId !== undefined) {
                currentThreadNavIndex = currentFileThreadIds.indexOf(jumpedToId);
            }
            const label = document.getElementById('threadNavLabel');
            const prevBtn = document.getElementById('threadNavPrev');
            const nextBtn = document.getElementById('threadNavNext');
            if (label) label.textContent = currentThreadNavIndex >= 0
                ? `${currentThreadNavIndex + 1}/${currentFileThreadIds.length}`
                : `${currentFileThreadIds.length} threads`;
            if (prevBtn) prevBtn.disabled = currentThreadNavIndex <= 0;
            if (nextBtn) nextBtn.disabled = currentThreadNavIndex >= currentFileThreadIds.length - 1;
        }

        function jumpToNextThread() {
            if (currentFileThreadIds.length === 0) return;
            const nextIndex = currentThreadNavIndex < 0 ? 0 : Math.min(currentThreadNavIndex + 1, currentFileThreadIds.length - 1);
            currentThreadNavIndex = nextIndex;
            scrollToThread(currentFileThreadIds[nextIndex]);
            updateThreadNav(currentFileThreadIds[nextIndex]);
        }

        function jumpToPrevThread() {
            if (currentFileThreadIds.length === 0) return;
            const prevIndex = currentThreadNavIndex < 0 ? 0 : Math.max(currentThreadNavIndex - 1, 0);
            currentThreadNavIndex = prevIndex;
            scrollToThread(currentFileThreadIds[prevIndex]);
            updateThreadNav(currentFileThreadIds[prevIndex]);
        }

        // Hunk (modification) jump navigation
        let currentHunkIndex = -1;

        function getHunkElements() {
            return document.querySelectorAll('#fileDiffPanel [data-hunk]');
        }

        function updateHunkNav(index) {
            const nav = document.getElementById('hunkNav');
            if (!nav) return;
            const hunks = getHunkElements();
            if (hunks.length === 0) { nav.style.display = 'none'; return; }
            nav.style.display = 'flex';
            currentHunkIndex = index ?? -1;
            const label = document.getElementById('hunkNavLabel');
            const prevBtn = document.getElementById('hunkNavPrev');
            const nextBtn = document.getElementById('hunkNavNext');
            if (label) label.textContent = currentHunkIndex >= 0
                ? `${currentHunkIndex + 1}/${hunks.length}`
                : `${hunks.length} changes`;
            if (prevBtn) prevBtn.disabled = currentHunkIndex <= 0;
            if (nextBtn) nextBtn.disabled = currentHunkIndex >= hunks.length - 1;
        }

        function scrollToHunk(index) {
            const hunks = getHunkElements();
            if (index < 0 || index >= hunks.length) return;
            const el = hunks[index];
            el.scrollIntoView({ behavior: 'smooth', block: 'center' });
        }

        function jumpToNextHunk() {
            const hunks = getHunkElements();
            if (hunks.length === 0) return;
            const nextIndex = currentHunkIndex < 0 ? 0 : Math.min(currentHunkIndex + 1, hunks.length - 1);
            currentHunkIndex = nextIndex;
            scrollToHunk(nextIndex);
            updateHunkNav(nextIndex);
        }

        function jumpToPrevHunk() {
            const hunks = getHunkElements();
            if (hunks.length === 0) return;
            const prevIndex = currentHunkIndex < 0 ? 0 : Math.max(currentHunkIndex - 1, 0);
            currentHunkIndex = prevIndex;
            scrollToHunk(prevIndex);
            updateHunkNav(prevIndex);
        }

        function refreshInlineThreadsIfNeeded() {
            if (currentView !== 'files' || !selectedFilePath) return;
            buildThreadsByFilePath();

            const changeEntry = allChangeEntries.find(e => e.item?.path === selectedFilePath);
            const ct = (changeEntry?.changeType || 'edit').toLowerCase();
            const { baseCommit, sourceCommit } = getIterationCommits();

            let oldCommitId, newCommitId;
            if (ct.includes('add')) {
                oldCommitId = null;
                newCommitId = sourceCommit;
            } else if (ct.includes('delete')) {
                oldCommitId = baseCommit;
                newCommitId = null;
            } else {
                oldCommitId = baseCommit;
                newCommitId = sourceCommit;
            }

            const cacheKey = `${selectedFilePath}:${oldCommitId || 'null'}-${newCommitId || 'null'}`;
            const cached = fileDiffCache.get(cacheKey);
            if (cached) {
                const sourceServerItem = changeEntry?.sourceServerItem || changeEntry?.originalPath;
                renderFileDiff(selectedFilePath, changeEntry?.changeType || 'edit', cached.diff, cached.addedCount, cached.removedCount, sourceServerItem);
            }
        }

        // Convenience aliases for inline view (kept for backward compat with existing onclick handlers)
        function showInlineReplyForm(threadId) { showReplyForm(threadId, 'inline-'); }
        function hideInlineReplyForm(threadId) { hideReplyForm(threadId, 'inline-'); }
        function submitInlineReply(threadId) { return submitReply(threadId, 'inline-'); }
        function startInlineEditComment(threadId, commentId) { startEditComment(threadId, commentId, 'inline-'); }
        function cancelInlineEditComment(threadId, commentId) { cancelEditComment(threadId, commentId, 'inline-'); }
        function saveInlineEditComment(threadId, commentId) { return saveEditComment(threadId, commentId, 'inline-'); }
        function deleteInlineComment(threadId, commentId) { return deleteComment(threadId, commentId); }

        // ==================== PR Status Actions ====================

        function showPRActionModal(title, bodyHtml, footerHtml) {
            document.getElementById('prActionModalTitle').textContent = title;
            document.getElementById('prActionModalBody').innerHTML = bodyHtml;
            document.getElementById('prActionModalFooter').innerHTML = footerHtml;
            document.getElementById('prActionModal').classList.add('show');
        }

        function closePRActionModal() {
            document.getElementById('prActionModal').classList.remove('show');
        }

        function renderPRStatusActions(prData) {
            if (!prData) return '';

            const status = prData.status;
            const isDraft = prData.isDraft;

            // Completed PRs have no actions
            if (status === 'completed') return '';

            let actions = [];

            if (status === 'active') {
                if (isDraft) {
                    actions.push(`<option value="publish">Publish (Remove Draft)</option>`);
                } else {
                    actions.push(`<option value="draft">Mark as Draft</option>`);
                }
                actions.push(`<option value="abandon">Abandon</option>`);
                actions.push(`<option value="complete">Complete</option>`);
            } else if (status === 'abandoned') {
                actions.push(`<option value="reactivate">Reactivate</option>`);
            }

            if (actions.length === 0) return '';

            return `
                <select id="prStatusActionSelect" onchange="handlePRStatusAction(this.value); this.value='';" class="pr-action-select">
                    <option value="">Set to</option>
                    ${actions.join('')}
                </select>
            `;
        }

        function renderAutoCompleteButton(prData) {
            if (!prData) return '';

            // Only show for active, non-draft PRs
            if (prData.status !== 'active' || prData.isDraft) return '';

            const isSet = !!prData.autoCompleteSetBy;
            const buttonClass = isSet ? 'auto-complete-btn active' : 'auto-complete-btn';
            const buttonText = isSet ? 'Remove Auto-Complete' : 'Set Auto-Complete';
            const lightningIcon = ADOUI.getLightningSvg(14, 14, 'auto-complete-icon');

            return `<button id="autoCompleteBtn" class="${buttonClass}" onclick="handleAutoCompleteToggle()" title="${buttonText}">${lightningIcon} ${buttonText}</button>`;
        }

        async function handleAutoCompleteToggle() {
            if (!currentConfig || !currentPRData) return;

            const isCurrentlySet = !!currentPRData.autoCompleteSetBy;
            const actionText = isCurrentlySet ? 'remove auto-complete from' : 'set auto-complete on';

            // Disable button during operation
            const btn = document.getElementById('autoCompleteBtn');
            if (btn) btn.disabled = true;

            try {
                if (isCurrentlySet) {
                    // Remove auto-complete
                    await ADOAPI.removeAutoComplete(currentConfig, currentPRId);
                } else {
                    // Set auto-complete - need to get current user first
                    const currentUser = await ADOAPI.getCurrentUser(currentConfig);
                    await ADOAPI.setAutoComplete(currentConfig, currentPRId, { id: currentUser.id });
                }

                // Refresh PR data
                currentPRData = await ADOAPI.getPR(currentConfig, currentPRId);
                updatePRStatusDisplay();
            } catch (error) {
                alert(`Failed to ${actionText} this PR: ${error.message}\n\nNote: This requires a PAT with "Code (Write)" permissions.`);
            } finally {
                if (btn) btn.disabled = false;
            }
        }

        async function handlePRStatusAction(action) {
            if (!action || !currentConfig || !currentPRData) return;

            switch (action) {
                case 'draft':
                    await handleSetDraft(true);
                    break;
                case 'publish':
                    await handleSetDraft(false);
                    break;
                case 'abandon':
                    await handleAbandon();
                    break;
                case 'reactivate':
                    await handleReactivate();
                    break;
                case 'complete':
                    await handleComplete();
                    break;
            }
        }

        async function handleSetDraft(isDraft) {
            const actionText = isDraft ? 'mark as draft' : 'publish';
            const confirmed = confirm(`Are you sure you want to ${actionText} this PR?`);
            if (!confirmed) return;

            try {
                await ADOAPI.setDraft(currentConfig, currentPRId, isDraft);
                // Refresh PR data
                currentPRData = await ADOAPI.getPR(currentConfig, currentPRId);
                updatePRStatusDisplay();
            } catch (error) {
                alert(`Failed to ${actionText}: ${error.message}\n\nNote: This requires a PAT with "Code (Write)" permissions.`);
            }
        }

        async function handleAbandon() {
            const confirmed = confirm('Are you sure you want to abandon this PR?\n\nThis will mark the PR as abandoned. It can be reactivated later.');
            if (!confirmed) return;

            try {
                await ADOAPI.abandonPR(currentConfig, currentPRId);
                currentPRData = await ADOAPI.getPR(currentConfig, currentPRId);
                updatePRStatusDisplay();
            } catch (error) {
                alert(`Failed to abandon PR: ${error.message}\n\nNote: This requires a PAT with "Code (Write)" permissions.`);
            }
        }

        async function handleReactivate() {
            const confirmed = confirm('Are you sure you want to reactivate this PR?');
            if (!confirmed) return;

            try {
                await ADOAPI.reactivatePR(currentConfig, currentPRId);
                currentPRData = await ADOAPI.getPR(currentConfig, currentPRId);
                updatePRStatusDisplay();
            } catch (error) {
                alert(`Failed to reactivate PR: ${error.message}\n\nNote: This requires a PAT with "Code (Write)" permissions.`);
            }
        }

        async function handleComplete() {
            // Show loading modal
            showPRActionModal(
                'Complete Pull Request',
                '<div class="pr-modal-body-loading">Checking completion requirements...</div>',
                ''
            );

            try {
                // Use the already-fetched prChecksData if available, otherwise fetch
                let checksData = prChecksData;
                if (!checksData) {
                    const projectId = currentPRData.repository?.project?.id || currentConfig.project;
                    checksData = await ChecksFormatter.fetchPRChecks(
                        currentConfig,
                        currentConfig.project,
                        currentConfig.repository,
                        currentPRId,
                        projectId,
                        currentPRData.mergeStatus
                    );
                }

                // Check for blocking issues
                const blockingIssues = getCompletionBlockers(checksData, currentPRData);

                if (blockingIssues.length > 0) {
                    showCompletionBlockedModal(blockingIssues);
                } else {
                    await showCompletionOptionsModal();
                }
            } catch (error) {
                showPRActionModal(
                    'Error',
                    `<div class="error">Failed to check completion requirements: ${ADOContent.escapeHtml(error.message)}</div>`,
                    `<button class="btn-secondary" onclick="closePRActionModal()">Close</button>`
                );
            }
        }

        function getCompletionBlockers(checksData, prData) {
            return PRThreadsUtils.getCompletionBlockers(checksData, prData, {
                formatPolicy: ChecksFormatter.formatPolicy.bind(ChecksFormatter)
            });
        }

        function showCompletionBlockedModal(blockers) {
            let bodyHtml = `
                <p style="margin-bottom: 15px;">This PR cannot be completed due to the following issues:</p>
                <ul class="blocker-list">
            `;

            blockers.forEach(b => {
                let cls, icon;
                if (b.type === 'conflict') {
                    cls = 'blocker-conflict';
                    icon = '⚠';
                } else if (b.status === 'running' || b.status === 'queued') {
                    cls = 'blocker-running';
                    icon = '⏳';
                } else {
                    cls = 'blocker-policy';
                    icon = '✗';
                }
                bodyHtml += `<li class="${cls}">${icon} ${ADOContent.escapeHtml(b.message)}</li>`;
            });

            bodyHtml += '</ul>';

            showPRActionModal(
                'Cannot Complete PR',
                bodyHtml,
                `<button class="btn-secondary" onclick="closePRActionModal()">Close</button>`
            );
        }

        async function showCompletionOptionsModal() {
            // Build merge strategy options
            const mergeStrategies = [
                { value: 'noFastForward', label: 'Merge (no fast forward)' },
                { value: 'squash', label: 'Squash commit' },
                { value: 'rebase', label: 'Rebase' },
                { value: 'rebaseMerge', label: 'Rebase and merge' }
            ];

            const strategyOptions = mergeStrategies
                .map(s => `<option value="${s.value}">${s.label}</option>`)
                .join('');

            // Build default merge commit message
            const defaultMessage = `Merged PR ${currentPRId}: ${currentPRData.title || ''}`;

            const bodyHtml = `
                <div class="merge-option-group">
                    <label for="mergeStrategy">Merge Type:</label>
                    <select id="mergeStrategy">
                        ${strategyOptions}
                    </select>
                </div>
                <div class="merge-option-group">
                    <label for="mergeCommitMessage">Commit Message:</label>
                    <textarea id="mergeCommitMessage">${ADOContent.escapeHtml(defaultMessage)}</textarea>
                </div>
                <div class="merge-option-group">
                    <label class="merge-option-checkbox">
                        <input type="checkbox" id="deleteSourceBranch" checked>
                        Delete source branch after merging
                    </label>
                </div>
            `;

            const footerHtml = `
                <button class="btn-secondary" onclick="closePRActionModal()">Cancel</button>
                <button class="btn-primary" onclick="executePRCompletion()">Complete</button>
            `;

            showPRActionModal('Complete Pull Request', bodyHtml, footerHtml);
        }

        async function executePRCompletion() {
            const mergeStrategy = document.getElementById('mergeStrategy').value;
            const deleteSourceBranch = document.getElementById('deleteSourceBranch').checked;
            const mergeCommitMessage = document.getElementById('mergeCommitMessage').value;

            // Update modal to show loading
            document.getElementById('prActionModalBody').innerHTML =
                '<div class="pr-modal-body-loading">Completing pull request...</div>';
            document.getElementById('prActionModalFooter').innerHTML = '';

            try {
                const completionOptions = {
                    mergeStrategy,
                    deleteSourceBranch,
                    mergeCommitMessage
                };

                const lastMergeSourceCommitId = currentPRData.lastMergeSourceCommit?.commitId;
                if (!lastMergeSourceCommitId) {
                    throw new Error('Cannot determine source commit for completion. The PR may need to be re-queued for merge.');
                }

                const updatedPR = await ADOAPI.completePR(
                    currentConfig,
                    currentPRId,
                    lastMergeSourceCommitId,
                    completionOptions
                );

                closePRActionModal();

                // Update PR data from response and refresh display
                currentPRData = updatedPR;
                updatePRStatusDisplay();

                // Show success message briefly
                alert('Pull request completed successfully!');
            } catch (error) {
                showPRActionModal(
                    'Completion Failed',
                    `<div class="error">${ADOContent.escapeHtml(error.message)}</div>`,
                    `<button class="btn-secondary" onclick="closePRActionModal()">Close</button>`
                );
            }
        }

        function updatePRStatusDisplay() {
            const statusBadgesEl = document.getElementById('prStatusBadges');
            const actionsEl = document.getElementById('prStatusActions');
            const autoCompleteEl = document.getElementById('autoCompleteBtnContainer');

            if (statusBadgesEl && currentPRData) {
                statusBadgesEl.innerHTML = ADOUI.renderStatusBadge(currentPRData.status, currentPRData);
            }

            if (actionsEl && currentPRData) {
                actionsEl.innerHTML = renderPRStatusActions(currentPRData);
            }

            if (autoCompleteEl && currentPRData) {
                autoCompleteEl.innerHTML = renderAutoCompleteButton(currentPRData);
            }
        }

        // ==================== End PR Status Actions ====================

        // ==================== Reviewer Management ====================

        let reviewerSearchTimeout = null;
        let currentSearchType = null; // 'required' or 'optional'
        let reviewerDropdownOpen = false;

        function toggleReviewerDropdown(event, wrapper) {
            event.stopPropagation();
            const dropdown = wrapper.querySelector('.reviewer-dropdown');
            const wasOpen = dropdown.classList.contains('open');

            // Close all other dropdowns
            closeAllReviewerDropdowns();

            if (!wasOpen) {
                dropdown.classList.add('open');
                reviewerDropdownOpen = true;
            }
        }

        function closeAllReviewerDropdowns() {
            document.querySelectorAll('.reviewer-dropdown.open').forEach(d => d.classList.remove('open'));
            reviewerDropdownOpen = false;
        }

        // Close dropdown when clicking outside
        document.addEventListener('click', (e) => {
            if (!e.target.closest('.reviewer-avatar-wrapper')) {
                closeAllReviewerDropdowns();
            }
        });

        function toggleInlineReviewerSearch(type) {
            const requiredSearch = document.getElementById('reviewerSearchRequired');
            const optionalSearch = document.getElementById('reviewerSearchOptional');

            // Close the other search if open
            if (type === 'required' && optionalSearch) {
                optionalSearch.style.display = 'none';
                optionalSearch.querySelector('input').value = '';
                optionalSearch.querySelector('.inline-search-results').innerHTML = '';
            } else if (type === 'optional' && requiredSearch) {
                requiredSearch.style.display = 'none';
                requiredSearch.querySelector('input').value = '';
                requiredSearch.querySelector('.inline-search-results').innerHTML = '';
            }

            // Toggle current search
            const searchDiv = type === 'required' ? requiredSearch : optionalSearch;
            if (searchDiv) {
                const isVisible = searchDiv.style.display !== 'none';
                searchDiv.style.display = isVisible ? 'none' : 'block';
                if (!isVisible) {
                    searchDiv.querySelector('input').focus();
                    currentSearchType = type;
                } else {
                    searchDiv.querySelector('input').value = '';
                    searchDiv.querySelector('.inline-search-results').innerHTML = '';
                    currentSearchType = null;
                }
            }
        }

        function hideInlineReviewerSearch() {
            const requiredSearch = document.getElementById('reviewerSearchRequired');
            const optionalSearch = document.getElementById('reviewerSearchOptional');

            [requiredSearch, optionalSearch].forEach(div => {
                if (div) {
                    div.style.display = 'none';
                    div.querySelector('input').value = '';
                    div.querySelector('.inline-search-results').innerHTML = '';
                }
            });
            currentSearchType = null;
        }

        function searchReviewersInline(query, type) {
            clearTimeout(reviewerSearchTimeout);

            const searchDiv = document.getElementById(type === 'required' ? 'reviewerSearchRequired' : 'reviewerSearchOptional');
            const resultsDiv = searchDiv?.querySelector('.inline-search-results');
            if (!resultsDiv) return;

            if (!query || query.length < 2) {
                resultsDiv.innerHTML = '';
                return;
            }

            resultsDiv.innerHTML = '<div style="padding: 4px; color: #605e5c; font-size: 11px;">Searching...</div>';

            reviewerSearchTimeout = setTimeout(async () => {
                try {
                    const identities = await ADOAPI.searchIdentities(currentConfig, query);

                    if (identities.length === 0) {
                        resultsDiv.innerHTML = '<div style="padding: 4px; color: #605e5c; font-size: 11px;">No users found</div>';
                        return;
                    }

                    // Filter out users already in reviewers list
                    const existingReviewerIds = new Set((currentPRData.reviewers || []).map(r => r.id));
                    const filteredIdentities = identities.filter(i => !existingReviewerIds.has(i.localId));

                    if (filteredIdentities.length === 0) {
                        resultsDiv.innerHTML = '<div style="padding: 4px; color: #605e5c; font-size: 11px;">All matching users are already reviewers</div>';
                        return;
                    }

                    const isRequired = type === 'required';
                    resultsDiv.innerHTML = filteredIdentities.map(identity => {
                        const name = ADOContent.escapeHtml(identity.displayName || 'Unknown');
                        const email = ADOContent.escapeHtml(identity.mail || '');
                        const id = (identity.localId || '').replace(/'/g, "\\'");
                        const initials = name.split(' ').map(n => n[0]).join('').substring(0, 2).toUpperCase();

                        return `
                            <div class="inline-search-result" onclick="addReviewer('${id}', ${isRequired})">
                                <div class="avatar-fallback" style="width: 24px; height: 24px; font-size: 9px;">${initials}</div>
                                <div>
                                    <div class="result-name">${name}</div>
                                    ${email ? `<div class="result-email">${email}</div>` : ''}
                                </div>
                            </div>
                        `;
                    }).join('');

                } catch (error) {
                    console.error('Failed to search identities:', error);
                    resultsDiv.innerHTML = `<div style="padding: 4px; color: #a4262c; font-size: 11px;">Search failed: ${ADOContent.escapeHtml(error.message)}</div>`;
                }
            }, 300);
        }

        async function addReviewer(reviewerId, isRequired) {
            try {
                await ADOAPI.addReviewer(currentConfig, currentPRId, reviewerId, isRequired);

                // Refresh PR data to get updated reviewers list
                currentPRData = await ADOAPI.getPR(currentConfig, currentPRId);

                // Update reviewers display
                updateReviewersDisplay();

                // Hide the inline search
                hideInlineReviewerSearch();

            } catch (error) {
                alert(`Failed to add reviewer: ${error.message}\n\nNote: This requires a PAT with appropriate permissions.`);
            }
        }

        async function removeReviewer(reviewerId, displayName) {
            const confirmed = confirm(`Are you sure you want to remove ${displayName} as a reviewer?`);
            if (!confirmed) return;

            try {
                await ADOAPI.removeReviewer(currentConfig, currentPRId, reviewerId);

                // Refresh PR data to get updated reviewers list
                currentPRData = await ADOAPI.getPR(currentConfig, currentPRId);

                // Update reviewers display
                updateReviewersDisplay();

            } catch (error) {
                alert(`Failed to remove reviewer: ${error.message}\n\nNote: This requires a PAT with appropriate permissions.`);
            }
        }

        async function toggleReviewerRequired(reviewerId, isRequired) {
            try {
                await ADOAPI.updateReviewerRequired(currentConfig, currentPRId, reviewerId, isRequired);

                // Refresh PR data to get updated reviewers list
                currentPRData = await ADOAPI.getPR(currentConfig, currentPRId);

                // Update reviewers display
                updateReviewersDisplay();

            } catch (error) {
                alert(`Failed to update reviewer: ${error.message}\n\nNote: This requires a PAT with appropriate permissions.`);
            }
        }

        function updateReviewersDisplay() {
            // Recalculate thread counts (reuse canonical logic from getActiveThreadCounts)
            const threadCounts = getActiveThreadCounts(allThreads);

            // Check if avatar containers exist (structure already rendered)
            const requiredAvatarsContainer = document.getElementById('requiredReviewersAvatars');
            const optionalAvatarsContainer = document.getElementById('optionalReviewersAvatars');

            if (requiredAvatarsContainer && optionalAvatarsContainer) {
                // Only update the avatar containers, preserving search forms
                const reviewers = currentPRData.reviewers || [];
                const requiredReviewers = reviewers.filter(r => r.isRequired);
                const optionalReviewers = reviewers.filter(r => !r.isRequired);

                const requiredAvatarsHtml = requiredReviewers.map(r => {
                    const count = threadCounts[r.id] || 0;
                    return renderReviewerWithDropdown(r, r.vote, count, r.id === currentPRData.createdBy?.id, true);
                }).join('');

                const optionalAvatarsHtml = optionalReviewers.map(r => {
                    const count = threadCounts[r.id] || 0;
                    return renderReviewerWithDropdown(r, r.vote, count, r.id === currentPRData.createdBy?.id, false);
                }).join('');

                requiredAvatarsContainer.innerHTML = requiredAvatarsHtml || '<span class="no-reviewers">None</span>';
                optionalAvatarsContainer.innerHTML = optionalAvatarsHtml || '<span class="no-reviewers">None</span>';

                // Also update Other Thread Authors section
                const reviewersContainer = document.getElementById('rightSidebarReviewers');
                const otherAuthorsHtml = renderOtherAuthorsSection(allThreads, reviewers, threadCounts, currentPRData.createdBy?.id);
                // Find and update or append the other authors section
                let otherAuthorsSection = reviewersContainer?.querySelector('.avatars-section:last-child h4');
                if (otherAuthorsSection?.textContent === 'Other Thread Authors') {
                    otherAuthorsSection.closest('.avatars-section').outerHTML = otherAuthorsHtml || '';
                } else if (otherAuthorsHtml && reviewersContainer) {
                    // Append if it doesn't exist but should
                    reviewersContainer.insertAdjacentHTML('beforeend', otherAuthorsHtml);
                }
            } else {
                // Full render (initial load)
                const reviewersHtml = `
                    ${renderReviewersSection(currentPRData.reviewers, threadCounts, currentPRData.createdBy?.id)}
                    ${renderOtherAuthorsSection(allThreads, currentPRData.reviewers, threadCounts, currentPRData.createdBy?.id)}
                `;

                const reviewersContainer = document.getElementById('rightSidebarReviewers');
                if (reviewersContainer) {
                    reviewersContainer.innerHTML = reviewersHtml;
                }
            }

            // Load any new avatars
            AvatarLoader.loadPending();
        }

        // ==================== End Reviewer Management ====================

        async function applyBulkStatusChange() {
            const newStatus = document.getElementById('bulkStatusSelect').value;

            if (!newStatus) {
                alert('Please select a status to apply.');
                return;
            }

            if (selectedThreadIds.size === 0) {
                alert('Please select at least one thread.');
                return;
            }

            const statusLabels = {
                'active': 'Active',
                'fixed': 'Resolved',
                'closed': 'Closed',
                'wontFix': "Won't Fix",
                'pending': 'Pending'
            };
            const statusLabel = statusLabels[newStatus] || newStatus;

            const confirmed = confirm(`Are you sure you want to change ${selectedThreadIds.size} thread(s) to "${statusLabel}"?`);
            if (!confirmed) return;

            ADOUI.showLoading('results', `Updating ${selectedThreadIds.size} thread(s)...`);

            let successCount = 0;
            let failCount = 0;

            for (const threadId of selectedThreadIds) {
                const success = await changeThreadStatus(threadId, newStatus);
                if (success) {
                    successCount++;
                } else {
                    failCount++;
                }
            }

            // Clear selection and refresh
            selectedThreadIds.clear();
            document.getElementById('selectedCount').textContent = 0;
            document.getElementById('bulkStatusSelect').value = '';

            applyThreadFilters();

            if (failCount === 0) {
                alert(`Successfully updated ${successCount} thread(s).`);
            } else {
                alert(`Updated ${successCount} thread(s) successfully.\n${failCount} thread(s) failed to update.`);
            }
        }

        function getLastIterationBeforeTime(sortedIterations, time) {
            for (let i = sortedIterations.length - 1; i >= 0; i--) {
                if (new Date(sortedIterations[i].createdDate) < time) {
                    return sortedIterations[i];
                }
            }
            return null;
        }

        function getIterationLinksForComment(comment, thread, iterations, config, prData, filePath, isFirstComment = false) {
            const commentId = comment.id;
            const discussionId = thread.id;

            if (!iterations || iterations.length === 0) {
                return { beforeLink: null, afterLink: null, completeLink: null };
            }

            const sortedIterations = [...iterations].sort((a, b) =>
                new Date(a.createdDate) - new Date(b.createdDate)
            );

            const commentTime = new Date(comment.publishedDate);
            const latestIteration = sortedIterations[sortedIterations.length - 1];

            // For the first comment, use the thread's secondComparingIteration (what ADO recorded)
            // For subsequent comments, calculate based on timestamp
            let targetIterationId;
            if (isFirstComment) {
                targetIterationId = thread.pullRequestThreadContext?.iterationContext?.secondComparingIteration;
            }
            // Fallback to timestamp-based if not first comment or not available
            if (targetIterationId === null || targetIterationId === undefined) {
                const lastBefore = getLastIterationBeforeTime(sortedIterations, commentTime);
                targetIterationId = lastBefore ? lastBefore.id : sortedIterations[0].id;
            }

            // Check if there are iterations after this comment
            const hasIterationsAfter = targetIterationId < latestIteration.id;

            let beforeLink = null;
            let afterLink = null;
            let completeLink = null;
            let beforeRange = null;
            let afterRange = null;
            let completeRange = null;

            const baseUrl = `${config.serverUrl}/${config.organization}/${config.project}/_git/${config.repository}/pullrequest/${prData.pullRequestId}`;
            const pathParam = filePath ? `&path=${encodeURIComponent(filePath)}` : '';
            const commentParams = `&discussionId=${discussionId}&commentId=${commentId}`;

            const formatRange = (start, end) => start === end ? `${start}` : `${start}..${end}`;

            // Only show before/after links if there are iterations after (otherwise it's same as complete)
            if (hasIterationsAfter) {
                beforeLink = `${baseUrl}?_a=files${pathParam}&iteration=${targetIterationId}&base=0${commentParams}`;
                beforeRange = formatRange(1, targetIterationId);

                afterLink = `${baseUrl}?_a=files${pathParam}&iteration=${latestIteration.id}&base=${targetIterationId}${commentParams}`;
                afterRange = formatRange(targetIterationId + 1, latestIteration.id);
            }

            completeLink = `${baseUrl}?_a=files${pathParam}&iteration=${latestIteration.id}&base=0${commentParams}`;
            completeRange = formatRange(1, latestIteration.id);

            return { beforeLink, afterLink, completeLink, beforeRange, afterRange, completeRange };
        }

        async function renderCodeSuggestion(thread, comment) {
            console.log('renderCodeSuggestion called for thread:', thread.id);

            // Extract suggestion from comment content
            const suggestionMatch = comment.content?.match(/```suggestion\n([\s\S]*?)\n```/);
            if (!suggestionMatch) {
                console.log('No suggestion match found in comment content');
                return null;
            }

            const suggestion = suggestionMatch[1];
            console.log('Found suggestion:', suggestion);

            const ctx = thread.threadContext;

            // For code suggestions, we use rightFileStart (the target/new code location)
            // leftFileStart is only for diffs that show both old and new code
            if (!ctx || !ctx.rightFileStart || !currentConfig || !thread.pullRequestThreadContext) {
                console.log('Missing required context:', {
                    hasCtx: !!ctx,
                    hasRightFileStart: !!ctx?.rightFileStart,
                    hasLeftFileStart: !!ctx?.leftFileStart,
                    hasCurrentConfig: !!currentConfig,
                    hasPullRequestThreadContext: !!thread.pullRequestThreadContext
                });
                return null;
            }

            try {
                console.log('Fetching file content for code suggestion...');
                // Get the iteration to fetch the original code
                const iterationId = thread.pullRequestThreadContext.iterationContext?.secondComparingIteration;
                let iteration;

                if (iterationId !== null && iterationId !== undefined) {
                    iteration = allIterations.find(it => it.id === iterationId);
                }

                if (!iteration) {
                    iteration = allIterations[allIterations.length - 1];
                }

                const commitId = iteration?.sourceRefCommit?.commitId || currentPRData.lastMergeSourceCommit?.commitId;
                if (!commitId) {
                    throw new Error('Could not determine commit version');
                }

                // Fetch the file content
                const fileContent = await ADOAPI.getFileContent(currentConfig, ctx.filePath, {
                    version: commitId,
                    versionType: 'commit'
                });

                // Extract the original lines and character offsets
                // For code suggestions, use rightFileStart (the location in the new/target code)
                const lines = fileContent.split('\n');
                const startLine = ctx.rightFileStart.line;
                const endLine = ctx.rightFileEnd ? ctx.rightFileEnd.line : startLine;
                const startOffset = ctx.rightFileStart.offset || 0;
                const endOffset = ctx.rightFileEnd?.offset || 0;

                // Adjust offsets (ADO uses 1-based, JavaScript uses 0-based)
                const adjustedStartOffset = Math.max(0, startOffset - 1);
                const adjustedEndOffset = Math.max(0, endOffset - 1);

                console.log(`Extracting lines ${startLine}-${endLine} with offsets ${startOffset}-${endOffset} from file`);

                // Extract the full original lines
                const fullOriginalLines = lines.slice(startLine - 1, endLine).join('\n');

                // Extract the portion being changed (using character offsets)
                let originalChangedText = '';
                let prefixText = '';
                let suffixText = '';

                if (startLine === endLine) {
                    // Single line change
                    const line = lines[startLine - 1] || '';
                    prefixText = line.substring(0, adjustedStartOffset);
                    originalChangedText = line.substring(adjustedStartOffset, adjustedEndOffset);
                    suffixText = line.substring(adjustedEndOffset);
                } else {
                    // Multi-line change
                    const firstLine = lines[startLine - 1] || '';
                    const lastLine = lines[endLine - 1] || '';
                    const middleLines = lines.slice(startLine, endLine - 1);

                    prefixText = firstLine.substring(0, adjustedStartOffset);
                    originalChangedText = firstLine.substring(adjustedStartOffset);
                    if (middleLines.length > 0) {
                        originalChangedText += '\n' + middleLines.join('\n');
                    }
                    originalChangedText += '\n' + lastLine.substring(0, adjustedEndOffset);
                    suffixText = lastLine.substring(adjustedEndOffset);
                }

                // Build the diff view (light theme) with full line context
                let html = '<div style="background: #f8f8f8; color: #323130; padding: 12px; margin-top: 8px; border-radius: 0; border: 1px solid #d1d1d1; font-family: monospace; font-size: 12px;">';
                html += '<div style="color: #8a6d3b; font-weight: 600; margin-bottom: 8px;">💡 Code change suggestion</div>';
                html += '<div style="border: 1px solid #d1d1d1; border-radius: 0; overflow: hidden; background: white;">';

                // Original line(s) with changed part highlighted
                const originalWithHighlight = ADOContent.escapeHtml(prefixText) +
                    `<strong style="background: #ffc0cb; font-weight: 700;">${ADOContent.escapeHtml(originalChangedText)}</strong>` +
                    ADOContent.escapeHtml(suffixText);

                const originalLinesArray = originalWithHighlight.split('\n');
                originalLinesArray.forEach(line => {
                    html += `<div style="background: #ffeef0; padding: 2px 8px; border-left: 2px solid #d73a49;"><span style="color: #d73a49; font-weight: 600;">- </span>${line}</div>`;
                });

                // Suggested line(s) with changed part highlighted
                const suggestedWithHighlight = ADOContent.escapeHtml(prefixText) +
                    `<strong style="background: #c3f0c8; font-weight: 700;">${ADOContent.escapeHtml(suggestion)}</strong>` +
                    ADOContent.escapeHtml(suffixText);

                const suggestedLinesArray = suggestedWithHighlight.split('\n');
                suggestedLinesArray.forEach(line => {
                    html += `<div style="background: #e6ffed; padding: 2px 8px; border-left: 2px solid #28a745;"><span style="color: #28a745; font-weight: 600;">+ </span>${line}</div>`;
                });

                html += '</div></div>';
                return html;
            } catch (error) {
                console.error('Failed to render code suggestion:', error);
                return `<div style="background: #f8f8f8; color: #323130; padding: 12px; margin-top: 8px; border-radius: 0; border: 1px solid #d1d1d1; font-family: monospace; font-size: 12px;">
                    <div style="color: #8a6d3b; font-weight: 600; margin-bottom: 8px;">💡 Code change suggestion</div>
                    <div style="color: #605e5c; font-size: 11px;">Could not load suggestion details. Click the iteration links above or "View in ADO" to see the code diff.</div>
                </div>`;
            }
        }

        async function loadFilePreviewContent(previewDiv, filePath, iterationId, startLine, endLine, startOffset, endOffset) {
            if (previewDiv.hasAttribute('data-loaded')) return;

            try {
                let iteration = allIterations.find(it => it.id === iterationId);
                if (!iteration) {
                    iteration = allIterations[allIterations.length - 1];
                }

                const commitId = iteration?.sourceRefCommit?.commitId || currentPRData.lastMergeSourceCommit?.commitId;
                if (!commitId) {
                    throw new Error('Could not determine commit version');
                }

                const fileContent = await ADOAPI.getFileContent(currentConfig, filePath, {
                    version: commitId,
                    versionType: 'commit'
                });

                const lines = fileContent.split('\n');
                const contextLines = 5;
                const startIdx = Math.max(0, startLine - contextLines - 1);
                const endIdx = Math.min(lines.length, endLine + contextLines);

                let html = '<pre>';
                for (let i = startIdx; i < endIdx; i++) {
                    const lineNum = i + 1;
                    const rawLine = lines[i] || '';
                    const isInRange = lineNum >= startLine && lineNum <= endLine;

                    let lineContentHtml;
                    if (isInRange && startOffset !== undefined && endOffset !== undefined) {
                        const adjustedStartOffset = Math.max(0, startOffset - 1);
                        const adjustedEndOffset = Math.max(0, endOffset - 1);

                        if (lineNum === startLine && lineNum === endLine) {
                            const before = ADOContent.escapeHtml(rawLine.substring(0, adjustedStartOffset));
                            const highlighted = ADOContent.escapeHtml(rawLine.substring(adjustedStartOffset, adjustedEndOffset));
                            const after = ADOContent.escapeHtml(rawLine.substring(adjustedEndOffset));
                            lineContentHtml = `${before}<mark style="background: #ffe082; color: #000000; font-weight: 600;">${highlighted}</mark>${after}`;
                        } else if (lineNum === startLine) {
                            const before = ADOContent.escapeHtml(rawLine.substring(0, adjustedStartOffset));
                            const highlighted = ADOContent.escapeHtml(rawLine.substring(adjustedStartOffset));
                            lineContentHtml = `${before}<mark style="background: #ffe082; color: #000000; font-weight: 600;">${highlighted}</mark>`;
                        } else if (lineNum === endLine) {
                            const highlighted = ADOContent.escapeHtml(rawLine.substring(0, adjustedEndOffset));
                            const after = ADOContent.escapeHtml(rawLine.substring(adjustedEndOffset));
                            lineContentHtml = `<mark style="background: #ffe082; color: #000000; font-weight: 600;">${highlighted}</mark>${after}`;
                        } else {
                            lineContentHtml = `<mark style="background: #ffe082; color: #000000; font-weight: 600;">${ADOContent.escapeHtml(rawLine)}</mark>`;
                        }
                    } else {
                        lineContentHtml = ADOContent.escapeHtml(rawLine);
                    }

                    html += `<div class="file-preview-line"><span class="file-preview-line-number">${lineNum}</span><span class="file-preview-line-content">${lineContentHtml}</span></div>`;
                }
                html += '</pre>';

                previewDiv.innerHTML = html;
                previewDiv.setAttribute('data-loaded', 'true');
            } catch (error) {
                console.error('Failed to load file preview:', error);
                previewDiv.innerHTML = `<div style="padding: 12px; color: #a4262c;">Failed to load file preview: ${ADOContent.escapeHtml(error.message)}</div>`;
            }
        }

        async function toggleFilePreview(previewId, filePath, startLine, endLine, firstIterationId, secondIterationId, startOffset, endOffset, useRight = true) {
            const previewDiv = document.getElementById(previewId);
            const headerDiv = previewDiv.previousElementSibling;
            const arrow = headerDiv.querySelector('span:first-child');

            if (previewDiv.classList.contains('show')) {
                previewDiv.classList.remove('show');
                arrow.textContent = '▶';
            } else {
                previewDiv.classList.add('show');
                arrow.textContent = '▼';

                if (!previewDiv.hasAttribute('data-loaded')) {
                    previewDiv.innerHTML = '<div style="padding: 12px; color: #858585;">Loading...</div>';

                    // Determine iteration: prefer secondIterationId for right side, firstIterationId for left
                    const iterationId = useRight
                        ? (secondIterationId ?? firstIterationId)
                        : (firstIterationId ?? secondIterationId);

                    await loadFilePreviewContent(previewDiv, filePath, iterationId, startLine, endLine, startOffset, endOffset);
                }
            }
        }

        async function loadDiffPreviewContent(previewDiv, filePath, oldIterationId, newIterationId, startLine, endLine, startOffset, endOffset, useRight = true) {
            if (previewDiv.hasAttribute('data-loaded')) return;

            try {
                // Get new iteration
                const newIteration = allIterations.find(it => it.id === newIterationId);
                if (!newIteration) {
                    throw new Error('Could not find iteration data');
                }

                const newCommitId = newIteration.sourceRefCommit?.commitId;
                if (!newCommitId) {
                    throw new Error('Could not determine commit versions');
                }

                // For oldIterationId === 0, use merge base (consistent with files view)
                let oldCommitId;
                let oldFilePath;

                if (oldIterationId === 0) {
                    // Compare against merge base
                    oldCommitId = currentMergeBase || currentPRData.lastMergeTargetCommit?.commitId;
                    if (!oldCommitId) {
                        throw new Error('Could not determine base commit');
                    }
                    // Resolve old path via cumulative changes (same approach as files view)
                    oldFilePath = filePath;
                    try {
                        const changesData = await ADOAPI.getPRIterationChanges(currentConfig, currentPRId, newIterationId, 0);
                        const changeEntry = (changesData.changeEntries || []).find(e => e.item?.path === filePath);
                        const ct = (changeEntry?.changeType || '').toLowerCase();
                        if (ct.includes('rename') && (changeEntry.sourceServerItem || changeEntry.originalPath)) {
                            oldFilePath = changeEntry.sourceServerItem || changeEntry.originalPath;
                        }
                    } catch (e) {
                        console.warn('Could not fetch cumulative changes for path resolution:', e);
                    }
                } else {
                    const oldIteration = allIterations.find(it => it.id === oldIterationId);
                    if (!oldIteration) {
                        throw new Error('Could not find old iteration data');
                    }
                    oldCommitId = oldIteration.sourceRefCommit?.commitId;
                    if (!oldCommitId) {
                        throw new Error('Could not determine old commit version');
                    }
                    // Resolve old path via cumulative changes (same approach as files view)
                    oldFilePath = filePath;
                    try {
                        const changesData = await ADOAPI.getPRIterationChanges(currentConfig, currentPRId, newIterationId, oldIterationId);
                        const changeEntry = (changesData.changeEntries || []).find(e => e.item?.path === filePath);
                        const ct = (changeEntry?.changeType || '').toLowerCase();
                        if (ct.includes('rename') && (changeEntry.sourceServerItem || changeEntry.originalPath)) {
                            oldFilePath = changeEntry.sourceServerItem || changeEntry.originalPath;
                        }
                    } catch (e) {
                        console.warn('Could not fetch cumulative changes for path resolution, falling back to path history:', e);
                        oldFilePath = await DiffUtils.getFilePathAtIteration(filePath, newIterationId, oldIterationId, { iterations: allIterations, cache: filePathHistoryCache, getChanges: getIterationChanges });
                    }
                }

                const result = await DiffUtils.getOrComputeFileDiff(filePath, oldCommitId, newCommitId, oldFilePath, { config: currentConfig, cache: fileDiffCache, getFileContent: ADOAPI.getFileContent.bind(ADOAPI), diff: HistogramDiff });
                if (result.oldFetchFailed || result.newFetchFailed) {
                    const side = result.oldFetchFailed ? 'base' : 'new';
                    throw new Error(`Could not load ${side} file content (${result.oldFetchFailed ? oldFilePath : filePath})`);
                }
                const cropped = DiffUtils.cropDiffToRegion(result.diff, startLine, endLine, useRight);

                // Derive start line numbers from the cropped diff entries
                let startOldLine = 1, startNewLine = 1;
                for (const entry of cropped) {
                    if (entry.oldLine !== undefined) { startOldLine = entry.oldLine; break; }
                }
                for (const entry of cropped) {
                    if (entry.newLine !== undefined) { startNewLine = entry.newLine; break; }
                }

                // Build thread range for highlighting
                const threadRanges = [{
                    startLine, endLine,
                    startOffset: startOffset || 0, endOffset: endOffset || 0,
                    useRight, appliesToView: true, inserted: false
                }];

                const diffHtml = DiffUtils.renderDiffLines(cropped, threadRanges, {
                    startOldLine,
                    startNewLine
                });

                previewDiv.innerHTML = `<pre>${diffHtml}</pre>`;
                previewDiv.setAttribute('data-loaded', 'true');
            } catch (error) {
                console.error('Failed to load diff preview:', error);
                previewDiv.innerHTML = `<div style="padding: 12px; color: #a4262c;">Failed to load diff: ${ADOContent.escapeHtml(error.message)}</div>`;
            }
        }

        async function toggleIterationPreview(previewId, filePath, oldIterationId, newIterationId, startLine, endLine, startOffset, endOffset, useRight) {
            const previewDiv = document.getElementById(previewId);
            const headerDiv = previewDiv.previousElementSibling;
            const arrow = headerDiv.querySelector('span:first-child');

            if (previewDiv.classList.contains('show')) {
                previewDiv.classList.remove('show');
                arrow.textContent = '▶';
            } else {
                previewDiv.classList.add('show');
                arrow.textContent = '▼';

                if (!previewDiv.hasAttribute('data-loaded')) {
                    previewDiv.innerHTML = '<div style="padding: 12px; color: #858585;">Loading diff...</div>';
                    await loadDiffPreviewContent(previewDiv, filePath, oldIterationId, newIterationId, startLine, endLine, startOffset, endOffset, useRight);
                }
            }
        }

        function displayResults(prData, threads, iterations, config) {
            const resultsDiv = document.getElementById('results');

            // Count threads by status
            const statusCounts = threads.reduce((acc, thread) => {
                if (thread.isDeleted === true) {
                    acc.deleted = (acc.deleted || 0) + 1;
                } else if (thread.status === undefined) {
                    // Thread has no status field
                    acc.noStatus = (acc.noStatus || 0) + 1;
                } else {
                    // Thread has a status field (including "unknown" as a valid value)
                    const status = thread.status;
                    acc[status] = (acc[status] || 0) + 1;
                }
                return acc;
            }, {});

            // Get active thread counts per author (using all threads, not just filtered)
            const threadCounts = getActiveThreadCounts(allThreads);

            const prUrl = `${config.serverUrl}/${config.organization}/${config.project}/_git/${config.repository}/pullrequest/${prData.pullRequestId}`;

            // Generate status badge for title
            const statusBadgeHtml = ADOUI.renderStatusBadge(prData.status, prData);

            // Generate PR author avatar for title
            let prAuthorAvatarHtml = '';
            if (prData.createdBy?.id) {
                const authorTitle = ADOContent.escapeHtml(prData.createdBy.displayName || 'Unknown');
                const cachedUrl = AvatarLoader.getCached(prData.createdBy.id);
                if (cachedUrl) {
                    prAuthorAvatarHtml = `<span class="avatar-wrapper pr-title-avatar"><img src="${cachedUrl}" alt="${authorTitle}" title="${authorTitle}" class="avatar"></span>`;
                } else {
                    prAuthorAvatarHtml = `<span class="avatar-wrapper pr-title-avatar"><div class="avatar-placeholder" title="${authorTitle}"></div><img data-user-id="${prData.createdBy.id}" alt="${authorTitle}" title="${authorTitle}" class="avatar avatar-pending"></span>`;
                }
            }

            // PR title bar HTML (sticky, rendered outside #results)
            const fileCount = allChangeEntries.length;
            const titleBarHtml = `
                <div class="pr-title-bar">
                    <h2 style="display: flex; justify-content: space-between; align-items: center; gap: 16px;">
                        <span style="display: inline-flex; align-items: center; flex-wrap: wrap; gap: 6px;"><span id="prStatusBadges">${statusBadgeHtml}</span><span id="prStatusActions">${renderPRStatusActions(prData)}</span>${prAuthorAvatarHtml}<span>PR #${prData.pullRequestId}: ${ADOContent.escapeHtml(prData.title)}</span></span>
                        <span style="display: inline-flex; align-items: center; gap: 12px;"><span id="autoCompleteBtnContainer">${renderAutoCompleteButton(prData)}</span><a href="${prUrl}" target="_blank" style="font-size: 14px; color: #0078d4; text-decoration: none; white-space: nowrap;" title="Open PR in Azure DevOps">🔗 View in ADO</a></span>
                    </h2>
                </div>
                <div class="view-tabs">
                    <button class="view-tab${currentView === 'overview' ? ' active' : ''}" data-view="overview" onclick="switchView('overview')">Overview</button>
                    <button class="view-tab${currentView === 'files' ? ' active' : ''}" data-view="files" onclick="switchView('files')">Files (${fileCount})</button>
                </div>
            `;

            // PR header details HTML (non-sticky)
            const headerHtml = `
                <div class="pr-header">
                    <p><strong>Created:</strong> ${ADOUI.formatDate(prData.creationDate)}</p>
                    <p class="branch-info"><strong>Branches:</strong> <code>${prData.sourceRefName?.replace('refs/heads/', '') || 'Unknown'}</code> → <code id="prTargetBranch">${prData.targetRefName?.replace('refs/heads/', '') || 'Unknown'}</code></p>
                    <div class="description-card">
                        <div class="description-card-header">
                            <span>Description</span>
                            <button class="description-edit-btn" id="description-edit-btn" onclick="startEditDescription()" title="Edit description">&#9998;</button>
                        </div>
                        <div class="description-card-content" id="pr-description-content">
                            ${prData.description
                                ? `<div class="pr-description">${ADOContent.processContent(prData.description)}</div>`
                                : '<div class="pr-description" style="color: #a19f9d; font-style: italic;">No description</div>'}
                        </div>
                    </div>
                </div>
            `;

            // Thread list HTML (built separately)
            let threadListHtml = '';

            // Stats HTML (right sidebar)
            const statsHtml = `
                <h4>Threads</h4>
                <div id="threadStatsContainer" class="compact-stats">
                    <span title="Active">💬 <strong>${statusCounts.active || 0}</strong></span>
                    <span title="Resolved" style="color: #107c10;">✅ <strong>${statusCounts.fixed || 0}</strong></span>
                    <span title="Closed" style="color: #605e5c;">🔒 <strong>${statusCounts.closed || 0}</strong></span>
                    ${statusCounts.pending ? `<span title="Pending" style="color: #8a6d3b;">⏱️ <strong>${statusCounts.pending}</strong></span>` : ''}
                    ${statusCounts.wontFix ? `<span title="Won't Fix" style="color: #605e5c;">🚫 <strong>${statusCounts.wontFix}</strong></span>` : ''}
                    ${statusCounts.deleted ? `<span title="Deleted" style="color: #a4262c;">🗑️ <strong>${statusCounts.deleted}</strong></span>` : ''}
                </div>
                <div id="changeStatsContainer">
                ${currentFileChangeStats ? `
                <h4 style="margin-top: 15px;">Change Stats</h4>
                <div id="fileStatsContainer" class="compact-stats">
                    <span>Files</span>
                    <strong style="color: #107c10;" title="Added">+${currentFileChangeStats.added}</strong>
                    <strong style="color: #0078d4;" title="Modified">~${currentFileChangeStats.modified}</strong>
                    <strong style="color: #a4262c;" title="Deleted">-${currentFileChangeStats.deleted}</strong>
                </div>
                <div id="lineStatsContainer" class="compact-stats">
                    <span>Lines</span>
                    <span style="color: #605e5c;">⏳</span>
                    ${getLineStatsMenuHtml()}
                </div>
                <div id="updatesStatsContainer" class="compact-stats">
                    <span>Updates</span>
                    <strong>${iterations.length}</strong>
                </div>
                ` : ''}
                </div>
            `;

            // Reviewers HTML (right sidebar)
            const reviewersHtml = `
                ${renderReviewersSection(prData.reviewers, threadCounts, prData.createdBy?.id)}
                ${renderOtherAuthorsSection(allThreads, prData.reviewers, threadCounts, prData.createdBy?.id)}
            `;

            // Checks HTML (right sidebar)
            const checksHtml = renderChecksSection();

            // Work Items HTML (right sidebar)
            const workItemsHtml = renderWorkItemsSection();

            // Inject right sidebar content
            document.getElementById('rightSidebarStats').innerHTML = statsHtml;
            document.getElementById('rightSidebarReviewers').innerHTML = reviewersHtml;
            document.getElementById('rightSidebarWorkItems').innerHTML = workItemsHtml;
            document.getElementById('rightSidebarChecks').innerHTML = checksHtml;
            document.getElementById('rightSidebar').style.display = '';

            if (threads.length === 0) {
                threadListHtml += '<div class="info">No threads found for this Pull Request.</div>';
            } else {
                threadListHtml += '<div class="thread-container">';

                threads.forEach((thread, index) => {
                    const hasStatus = thread.status !== undefined;
                    const status = thread.status; // Keep actual status value (could be undefined, 'unknown', 'active', etc.)
                    const isThreadDeleted = thread.isDeleted === true;

                    const statusClass = ADOUI.getStatusBadgeClass(status, isThreadDeleted);
                    const statusText = ADOUI.getStatusText(status, isThreadDeleted);

                    const threadId = thread.id;
                    const threadUrl = ADOURL.buildThreadUrl(config, prData.pullRequestId, threadId, thread.threadContext?.filePath);
                    const apiEndpoint = `${config.serverUrl}/${config.organization}/${config.project}/_apis/git/repositories/${config.repository}/pullRequests/${prData.pullRequestId}/threads/${threadId}?api-version=6.0`;

                    const isChecked = selectedThreadIds.has(threadId) ? 'checked' : '';

                    // Check if this is a system thread (first comment is system type)
                    const firstComment = thread.comments && thread.comments[0];
                    const isSystemThread = firstComment && (firstComment.commentType === 'system' || firstComment.commentType === 3);

                    // Build status dropdown (only when not in bulk mode, not deleted, and not a system thread)
                    let statusControl = '';
                    if (!isBulkMode && !isThreadDeleted && !isSystemThread) {
                        if (hasStatus) {
                            // Thread has status: show "Change status:" with current selection and remove button
                            statusControl = `
                                <span class="thread-status-change">
                                    <select onchange="changeThreadStatus('${threadId}', this.value); this.blur();">
                                        <option value="">Change status...</option>
                                        <option value="active" ${status === 'active' ? 'selected' : ''}>Active</option>
                                        <option value="fixed" ${status === 'fixed' ? 'selected' : ''}>Resolved</option>
                                        <option value="closed" ${status === 'closed' ? 'selected' : ''}>Closed</option>
                                        <option value="wontFix" ${status === 'wontFix' ? 'selected' : ''}>Won't Fix</option>
                                        <option value="pending" ${status === 'pending' ? 'selected' : ''}>Pending</option>
                                        <option value="unknown" ${status === 'unknown' ? 'selected' : ''}>Unknown</option>
                                    </select>
                                    <button onclick="removeThreadStatus('${threadId}')" class="btn-secondary" style="margin-left: 5px; padding: 2px 8px; font-size: 12px;" title="Remove status from this thread">✕</button>
                                </span>
                            `;
                        } else {
                            // Thread has no status: show "Try force status:" with no selection
                            statusControl = `
                                <span class="thread-status-change">
                                    <select onchange="changeThreadStatus('${threadId}', this.value); this.blur();">
                                        <option value="" selected>Try force status...</option>
                                        <option value="active">Active</option>
                                        <option value="fixed">Resolved</option>
                                        <option value="closed">Closed</option>
                                        <option value="wontFix">Won't Fix</option>
                                        <option value="pending">Pending</option>
                                        <option value="unknown">Unknown</option>
                                    </select>
                                </span>
                            `;
                        }
                    }

                    // Store thread-level data for first comment integration
                    const threadHeaderData = {
                        isBulkMode,
                        isChecked,
                        threadUrl,
                        apiEndpoint,
                        hasFileContext: !!thread.threadContext,
                        hasStatus,
                        statusClass,
                        statusText,
                        statusControl
                    };

                    threadListHtml += `
                        <div class="thread">
                    `;

                    // Show thread context if it's a code comment
                    // threadContext has file path and line info
                    // pullRequestThreadContext has iteration context
                    if (thread.threadContext) {
                        const ctx = thread.threadContext;

                        // Determine which file location to use (rightFile for new code, leftFile for deleted code)
                        const useRight = !!ctx.rightFileStart;
                        const fileStart = useRight ? ctx.rightFileStart : ctx.leftFileStart;
                        const fileEnd = useRight ? ctx.rightFileEnd : ctx.leftFileEnd;
                        const lineInfo = fileStart ? ` (Line ${fileStart.line}${fileEnd && fileEnd.line !== fileStart.line ? `-${fileEnd.line}` : ''})` : '';

                        // If we have line information, make the file path a collapsible preview header
                        if (ctx.filePath && fileStart) {
                            const firstIterationId = thread.pullRequestThreadContext?.iterationContext?.firstComparingIteration;
                            const secondIterationId = thread.pullRequestThreadContext?.iterationContext?.secondComparingIteration;
                            const startLine = fileStart.line;
                            const endLine = fileEnd ? fileEnd.line : startLine;

                            // Determine base iteration: if first !== second, compare between iterations; otherwise from base (0)
                            const isIterationRange = firstIterationId != null && secondIterationId != null && firstIterationId !== secondIterationId;
                            const oldIterationId = isIterationRange ? firstIterationId : 0;

                            const showDiff = secondIterationId && secondIterationId >= 1;
                            const iterationLabel = showDiff
                                ? ` <span style="color: #605e5c; font-size: 11px;">(${isIterationRange ? `iteration ${firstIterationId}` : 'base'} → iteration ${secondIterationId})</span>`
                                : '';

                            const onclickHandler = showDiff
                                ? `toggleIterationPreview('file-preview-${threadId}', '${ADOContent.escapeJs(ctx.filePath)}', ${oldIterationId}, ${secondIterationId}, ${startLine}, ${endLine}, ${fileStart.offset || 0}, ${fileEnd?.offset || 0}, ${useRight})`
                                : `toggleFilePreview('file-preview-${threadId}', '${ADOContent.escapeJs(ctx.filePath)}', ${startLine}, ${endLine}, null, ${secondIterationId !== undefined ? secondIterationId : 'null'}, ${fileStart.offset || 0}, ${fileEnd?.offset || 0}, ${useRight})`;

                            threadListHtml += `
                                <div class="file-preview">
                                    <div class="file-preview-header" onclick="${onclickHandler}">
                                        <span>▶</span>
                                        <span><strong>File:</strong> ${ADOContent.escapeHtml(ctx.filePath || 'N/A')}${lineInfo}${iterationLabel}${useRight ? '' : ' <span style="color: #a4262c; font-size: 11px;">(deleted)</span>'}</span>
                                    </div>
                                    <div id="file-preview-${threadId}" class="file-preview-content"></div>
                                </div>
                            `;
                        } else {
                            // No line information, just show as regular context
                            threadListHtml += `
                                <div class="thread-context">
                                    <strong>File:</strong> ${ADOContent.escapeHtml(ctx.filePath || 'N/A')}${lineInfo}
                                </div>
                            `;
                        }
                    }

                    // Show all comments in the thread
                    if (thread.comments && thread.comments.length > 0) {
                        let prevCommentIterationId = null;
                        const filePath = thread.threadContext?.filePath || null;
                        const ctx = thread.threadContext;
                        const fileStart = ctx?.rightFileStart || ctx?.leftFileStart;
                        const fileEnd = ctx?.rightFileEnd || ctx?.leftFileEnd;

                        // Sort iterations for calculating iteration contexts
                        const sortedIterations = iterations.length > 0
                            ? [...iterations].sort((a, b) => new Date(a.createdDate) - new Date(b.createdDate))
                            : [];

                        thread.comments.forEach((comment, commentIdx) => {
                            const isFirstComment = commentIdx === 0;

                            // Check if iteration changed since last comment (only for file-based threads)
                            if (filePath && fileStart && sortedIterations.length > 0) {
                                const commentTime = new Date(comment.publishedDate);
                                const lastIterBefore = getLastIterationBeforeTime(sortedIterations, commentTime);
                                const currentIterationId = lastIterBefore ? lastIterBefore.id : sortedIterations[0].id;

                                if (prevCommentIterationId !== null && currentIterationId !== prevCommentIterationId) {
                                    // Iteration changed - insert a diff preview divider
                                    const previewId = `iteration-preview-${threadId}-${commentIdx}`;
                                    const startLine = fileStart.line;
                                    const endLine = fileEnd ? fileEnd.line : startLine;
                                    const iterLineInfo = ` (Line ${startLine}${endLine !== startLine ? `-${endLine}` : ''})`;

                                    threadListHtml += `
                                        <div class="file-preview" style="margin: 12px 0;">
                                            <div class="file-preview-header" onclick="toggleIterationPreview('${previewId}', '${ADOContent.escapeJs(filePath)}', ${prevCommentIterationId}, ${currentIterationId}, ${startLine}, ${endLine}, 0, 0, ${!!ctx?.rightFileStart})">
                                                <span>▶</span>
                                                <span><strong>File changed:</strong> ${ADOContent.escapeHtml(filePath)}${iterLineInfo} <span style="color: #605e5c; font-size: 11px;">(iteration ${prevCommentIterationId} → ${currentIterationId})</span></span>
                                            </div>
                                            <div id="${previewId}" class="file-preview-content"></div>
                                        </div>
                                    `;
                                }

                                prevCommentIterationId = currentIterationId;
                            }

                            // Check if this is a code suggestion
                            const isCodeSuggestion = comment.content?.includes('```suggestion');

                            // Remove suggestion block from content before processing to avoid duplicate display
                            let contentToProcess = comment.content;
                            if (isCodeSuggestion) {
                                contentToProcess = contentToProcess.replace(/```suggestion\n[\s\S]*?\n```/g, '');
                            }

                            let resolvedContent = ADOContent.processContent(contentToProcess);

                            // Check if content is essentially empty (just whitespace or empty code blocks)
                            const contentStripped = resolvedContent.replace(/<pre><code><\/code><\/pre>/g, '').trim();
                            const hasRealContent = contentStripped.length > 0;

                            // Get iteration links for this comment
                            const iterationLinks = getIterationLinksForComment(
                                comment,
                                thread,
                                iterations,
                                config,
                                prData,
                                filePath,
                                isFirstComment
                            );

                            // Check if comment is deleted
                            const isDeleted = comment.isDeleted === true;

                            // Determine comment type
                            const commentType = comment.commentType || 'unknown';
                            let commentTypeLabel = '';
                            let commentClass = '';
                            let commentTypeBadgeClass = '';

                            if (isDeleted) {
                                commentTypeLabel = 'Deleted';
                                commentTypeBadgeClass = 'comment-type-deleted';
                            } else {
                                switch(commentType) {
                                    case 'system':
                                    case 3:
                                        commentTypeLabel = 'System';
                                        commentClass = 'system-comment';
                                        commentTypeBadgeClass = 'comment-type-system';
                                        break;
                                    case 'codeChange':
                                    case 2:
                                        commentTypeLabel = 'Code Change';
                                        commentClass = 'code-change-comment';
                                        commentTypeBadgeClass = 'comment-type-code-change';
                                        break;
                                    case 'text':
                                    case 1:
                                        commentTypeLabel = 'Text';
                                        commentTypeBadgeClass = 'comment-type-text';
                                        break;
                                    default:
                                        commentTypeLabel = 'Unknown';
                                        break;
                                }
                            }

                            // Generate avatar HTML for comment author
                            let commentAvatarHtml = '';
                            if (comment.author?.id) {
                                const authorTitle = ADOContent.escapeHtml(comment.author.displayName || 'Unknown');
                                const isCommentByPRAuthor = comment.author.id === prData.createdBy?.id;
                                const authorBadge = isCommentByPRAuthor ? `<span class="author-badge" title="PR Author"><svg viewBox="0 0 24 24"><path d="M12 2l3.09 6.26L22 9.27l-5 4.87 1.18 6.88L12 17.77l-6.18 3.25L7 14.14 2 9.27l6.91-1.01L12 2z" fill="#323130"/></svg></span>` : '';
                                const cachedUrl = AvatarLoader.getCached(comment.author.id);
                                if (cachedUrl) {
                                    commentAvatarHtml = `<div class="avatar-wrapper"><img src="${cachedUrl}" alt="${authorTitle}" title="${authorTitle}" class="avatar">${authorBadge}</div>`;
                                } else {
                                    commentAvatarHtml = `<div class="avatar-wrapper"><div class="avatar-placeholder" title="${authorTitle}"></div><img data-user-id="${comment.author.id}" alt="${authorTitle}" title="${authorTitle}" class="avatar avatar-pending">${authorBadge}</div>`;
                                }
                            }

                            // Determine if we can show action buttons (not deleted, not system comment)
                            const isSystemComment = commentType === 'system' || commentType === 3;
                            const showCommentActions = !isDeleted && !isSystemComment;
                            const escapedContent = (comment.content || '').replace(/"/g, '&quot;').replace(/</g, '&lt;').replace(/>/g, '&gt;');

                            // Build the comment header - first comment has thread controls after edit/delete
                            const editDeleteButtons = showCommentActions ? `
                                <span class="comment-actions">
                                    <button class="comment-action-btn" onclick="startEditComment(${threadId}, ${comment.id})" title="Edit"><svg viewBox="0 0 24 24"><path d="M3 17.25V21h3.75L17.81 9.94l-3.75-3.75L3 17.25zM20.71 7.04c.39-.39.39-1.02 0-1.41l-2.34-2.34c-.39-.39-1.02-.39-1.41 0l-1.83 1.83 3.75 3.75 1.83-1.83z"/></svg></button>
                                    <button class="comment-action-btn delete" onclick="deleteComment(${threadId}, ${comment.id})" title="Delete"><svg viewBox="0 0 24 24"><path d="M6 19c0 1.1.9 2 2 2h8c1.1 0 2-.9 2-2V7H6v12zM19 4h-3.5l-1-1h-5l-1 1H5v2h14V4z"/></svg></button>
                                </span>
                            ` : '';

                            const threadControls = isFirstComment ? `
                                <span class="thread-controls">
                                    <a href="${threadHeaderData.threadUrl}" target="_blank" class="thread-link" title="Open thread in Azure DevOps (${threadHeaderData.hasFileContext ? 'files tab' : 'overview tab'})">🔗</a>
                                    <a href="${threadHeaderData.apiEndpoint}" target="_blank" class="thread-link" title="Open REST API response (requires authentication)">📡</a>
                                    ${threadHeaderData.hasStatus ? `<span class="badge ${threadHeaderData.statusClass}">${threadHeaderData.statusText}</span>` : ''}
                                    ${threadHeaderData.statusControl}
                                </span>
                            ` : '';

                            const commentHeaderHtml = `
                                <div class="comment-header">
                                    <span class="comment-author-info">
                                        ${isFirstComment && threadHeaderData.isBulkMode ? `<input type="checkbox" class="thread-checkbox" id="thread-checkbox-${threadId}" data-thread-id="${threadId}" ${threadHeaderData.isChecked} onchange="toggleThreadSelection('${threadId}')" style="margin-right: 8px;">` : ''}
                                        ${commentAvatarHtml}
                                        <span class="comment-date">${ADOUI.formatDate(comment.publishedDate)}</span>
                                        ${iterationLinks.completeLink ? `
                                        <span class="code-links">
                                            ${iterationLinks.beforeLink ? `<span class="iteration-range">${iterationLinks.beforeRange}</span><a href="${iterationLinks.beforeLink}" target="_blank" class="comment-link" title="Diff from first update to last update before this comment"><svg viewBox="0 0 24 24"><path d="M20 11H7.83l5.59-5.59L12 4l-8 8 8 8 1.41-1.41L7.83 13H20v-2z"/></svg></a>` : ''}
                                            ${iterationLinks.afterLink ? `<a href="${iterationLinks.afterLink}" target="_blank" class="comment-link" title="Diff from first update after this comment to latest"><svg viewBox="0 0 24 24"><path d="M12 4l-1.41 1.41L16.17 11H4v2h12.17l-5.58 5.59L12 20l8-8-8-8z"/></svg></a><span class="iteration-range">${iterationLinks.afterRange}</span>` : ''}
                                            <a href="${iterationLinks.completeLink}" target="_blank" class="comment-link" title="Complete diff from first to latest update"><svg viewBox="0 0 24 24"><path d="M6.99 11L3 15l3.99 4v-3H14v-2H6.99v-3zM21 9l-3.99-4v3H10v2h7.01v3L21 9z"/></svg></a><span class="iteration-range">${iterationLinks.completeRange}</span>
                                        </span>
                                        ` : ''}
                                        ${isDeleted || commentTypeLabel !== 'Text' ? `<span class="comment-type-badge ${commentTypeBadgeClass}">${commentTypeLabel}</span>` : ''}
                                    </span>
                                    ${editDeleteButtons}
                                    ${threadControls}
                                </div>`;

                            threadListHtml += `
                                <div class="comment ${commentClass}" data-thread-id="${threadId}" data-comment-id="${comment.id}" data-comment-content="${escapedContent}">
                                    ${commentHeaderHtml}
                                    <div class="comment-content-wrapper" id="comment-content-${threadId}-${comment.id}">
                                        ${hasRealContent ? `<div class="comment-content">${resolvedContent}</div>` : ''}
                                    </div>

                                    ${isCodeSuggestion ? `<div id="code-suggestion-${threadId}-${commentIdx}" data-thread-id="${threadId}" data-comment-idx="${commentIdx}"><div style="padding: 12px; color: #858585;">Loading code suggestion...</div></div>` : ''}
                                </div>
                            `;
                        });
                    }

                    // Add reply button at end of thread (only for non-deleted, non-system threads)
                    if (!isThreadDeleted && !isSystemThread) {
                        threadListHtml += `
                            <div class="thread-reply-container">
                                <button class="thread-reply-btn" onclick="showReplyForm(${threadId})" id="reply-btn-${threadId}">Reply</button>
                                <div id="reply-form-${threadId}"></div>
                            </div>
                        `;
                    }

                    threadListHtml += '</div>';
                });

                threadListHtml += '</div>';
            }

            // Update containers separately (new thread form is static, not re-rendered)
            // If containers don't exist (e.g., after showNoPRError), recreate them
            let titleBarContainer = document.getElementById('pr-title-bar-container');
            let headerContainer = document.getElementById('pr-header-container');
            let newThreadContainer = document.getElementById('newThreadContainer');
            let threadListContainer = document.getElementById('thread-list-container');

            if (!headerContainer || !threadListContainer) {
                // Recreate the structure (title bar is a sibling of overviewView in .main-content)
                if (!titleBarContainer) {
                    titleBarContainer = document.createElement('div');
                    titleBarContainer.id = 'pr-title-bar-container';
                    const overviewView = document.getElementById('overviewView');
                    if (overviewView) {
                        overviewView.parentNode.insertBefore(titleBarContainer, overviewView);
                    } else {
                        resultsDiv.parentNode.insertBefore(titleBarContainer, resultsDiv);
                    }
                }
                resultsDiv.innerHTML = `
                    <div id="pr-header-container"></div>
                    <div class="new-thread-container" id="newThreadContainer" style="display: none;">
                        <button class="new-thread-btn" onclick="showNewThreadForm()" id="newThreadBtn">+ New Thread</button>
                        <div id="newThreadFormContainer"></div>
                    </div>
                    <div id="thread-list-container"></div>
                `;
                headerContainer = document.getElementById('pr-header-container');
                newThreadContainer = document.getElementById('newThreadContainer');
                threadListContainer = document.getElementById('thread-list-container');
            }

            titleBarContainer.innerHTML = titleBarHtml;
            document.title = `PR #${prData.pullRequestId}: ${prData.title}`;
            headerContainer.innerHTML = headerHtml;
            newThreadContainer.style.display = '';
            threadListContainer.innerHTML = threadListHtml;

            // Apply files view if restored from URL
            if (currentView === 'files') {
                const overviewView = document.getElementById('overviewView');
                const filesView = document.getElementById('filesView');
                if (overviewView) overviewView.style.display = 'none';
                if (filesView) filesView.classList.add('active');
                if (!fileTreeBuilt) {
                    buildFileTree(allChangeEntries);
                    buildIterationSelector();
                    fileTreeBuilt = true;
                }
            }

            // Load avatars
            AvatarLoader.loadPending();

            // Fetch PR checks and work items asynchronously, then start polling
            fetchAndUpdateChecks(config, prData);
            fetchAndUpdateWorkItems(config, prData.pullRequestId);
            startPRPolling(config);

            // Fetch line stats asynchronously
            fetchLineStatsAsync(config, prData);

            // Asynchronously load code suggestions
            setTimeout(async () => {
                try {
                    const suggestionDivs = resultsDiv.querySelectorAll('[id^="code-suggestion-"]');
                    console.log(`Found ${suggestionDivs.length} code suggestion divs to process`);

                    for (const div of suggestionDivs) {
                        try {
                            const threadId = parseInt(div.dataset.threadId);
                            const commentIdx = parseInt(div.dataset.commentIdx);
                            console.log(`Processing code suggestion for thread ${threadId}, comment ${commentIdx}`);

                            const thread = threads.find(t => t.id === threadId);
                            if (!thread) {
                                console.warn(`Thread ${threadId} not found`);
                                div.innerHTML = '<div style="padding: 12px; color: #a4262c;">Error: Thread not found</div>';
                                continue;
                            }

                            if (!thread.comments || !thread.comments[commentIdx]) {
                                console.warn(`Comment ${commentIdx} not found in thread ${threadId}`);
                                div.innerHTML = '<div style="padding: 12px; color: #a4262c;">Error: Comment not found</div>';
                                continue;
                            }

                            const comment = thread.comments[commentIdx];
                            const suggestionHtml = await renderCodeSuggestion(thread, comment);
                            if (suggestionHtml) {
                                div.innerHTML = suggestionHtml;
                                console.log(`Successfully loaded code suggestion for thread ${threadId}`);
                            } else {
                                console.log(`No suggestion HTML returned for thread ${threadId}`);
                                div.innerHTML = ''; // Remove loading message if no suggestion
                            }
                        } catch (error) {
                            console.error('Error processing individual code suggestion:', error);
                            div.innerHTML = `<div style="padding: 12px; color: #a4262c;">Error loading suggestion: ${ADOContent.escapeHtml(error.message)}</div>`;
                        }
                    }
                } catch (error) {
                    console.error('Error in code suggestion loading:', error);
                }
            }, 0);
        }

        // === FILES VIEW FUNCTIONS ===

        function switchView(view) {
            if (view === currentView) return;
            currentView = view;

            // Toggle active tab
            document.querySelectorAll('.view-tab').forEach(tab => {
                tab.classList.toggle('active', tab.dataset.view === view);
            });

            const overviewView = document.getElementById('overviewView');
            const filesView = document.getElementById('filesView');

            if (view === 'files') {
                if (overviewView) overviewView.style.display = 'none';
                if (filesView) filesView.classList.add('active');

                // Lazily build file tree on first switch
                if (!fileTreeBuilt) {
                    buildFileTree(allChangeEntries);
                    buildIterationSelector();
                    fileTreeBuilt = true;
                }
            } else {
                if (overviewView) overviewView.style.display = '';
                if (filesView) filesView.classList.remove('active');
            }

            // Update URL param
            const url = new URL(window.location);
            if (view === 'files') {
                url.searchParams.set('view', 'files');
            } else {
                url.searchParams.delete('view');
            }
            history.replaceState(null, '', url);
        }

        function setFileViewMode(mode) {
            if (mode === fileViewMode) return;
            fileViewMode = mode;
            // Update buttons
            document.querySelectorAll('.file-view-mode-btn').forEach(btn => {
                btn.classList.toggle('active', btn.dataset.mode === mode);
            });
            if (mode === 'all') {
                buildAllFilesTree();
            } else {
                buildFileTree(allChangeEntries);
            }
        }

        function setDiffDisplayMode(mode) {
            if (mode === fileDiffDisplayMode) return;
            fileDiffDisplayMode = mode;
            localStorage.setItem('fileDiffDisplayMode', mode);
            if (selectedFilePath) refreshInlineThreadsIfNeeded();
        }

        function addFileToTree(root, filePath, changeType, sourceServerItem) {
            const parts = filePath.split('/').filter(p => p);
            if (parts.length === 0) return;
            let current = root;
            for (let i = 0; i < parts.length - 1; i++) {
                const dirName = parts[i];
                if (!current.children.has(dirName)) {
                    const dirPath = '/' + parts.slice(0, i + 1).join('/');
                    current.children.set(dirName, { name: dirName, path: dirPath, children: new Map(), files: [] });
                }
                current = current.children.get(dirName);
            }
            const fileName = parts[parts.length - 1];
            // Avoid duplicates
            if (!current.files.some(f => f.path === filePath)) {
                current.files.push({ name: fileName, path: filePath, changeType, sourceServerItem });
            }
        }

        function stripMarkdown(text) {
            return PRThreadsUtils.stripMarkdown(text);
        }

        function renderThreadSubList(filePath, depth) {
            const threads = threadsByFilePath.get(filePath);
            if (!threads || threads.length === 0) return '';
            // Sort by line number (order of appearance in file), then by offset within the line
            const sorted = [...threads].sort((a, b) => {
                const lineA = a.threadContext?.rightFileStart?.line || a.threadContext?.leftFileStart?.line || 0;
                const lineB = b.threadContext?.rightFileStart?.line || b.threadContext?.leftFileStart?.line || 0;
                if (lineA !== lineB) return lineA - lineB;
                const offsetA = a.threadContext?.rightFileStart?.offset || a.threadContext?.leftFileStart?.offset || 0;
                const offsetB = b.threadContext?.rightFileStart?.offset || b.threadContext?.leftFileStart?.offset || 0;
                return offsetA - offsetB;
            });
            let html = `<div class="file-tree-threads" style="--depth: ${depth}">`;
            for (const thread of sorted) {
                const firstComment = thread.comments?.find(c => c.commentType !== 'system');
                if (!firstComment) continue;
                const author = firstComment.author?.displayName || 'Unknown';
                const content = stripMarkdown(firstComment.content || '');
                const preview = content.length > 60 ? content.substring(0, 60) + '...' : content;
                const statusCls = thread.status || 'active';
                const lineInfo = thread.threadContext?.rightFileStart?.line || thread.threadContext?.leftFileStart?.line;
                const lineLabel = lineInfo ? `L${lineInfo}: ` : '';
                html += `<div class="file-tree-thread" data-thread-id="${thread.id}" onclick="selectFileForDiff('${ADOContent.escapeJs(filePath)}', '${ADOContent.escapeJs(changedFilePaths.has(filePath) ? 'edit' : 'none')}', ${thread.id})">`;
                html += `<span class="thread-status-dot ${ADOContent.escapeHtml(statusCls)}"></span>`;
                html += `<span class="thread-preview">${lineLabel}${ADOContent.escapeHtml(author)}: ${ADOContent.escapeHtml(preview)}</span>`;
                html += '</div>';
            }
            html += '</div>';
            return html;
        }

        function getThreadCountBadge(filePath) {
            const threads = threadsByFilePath.get(filePath);
            if (!threads || threads.length === 0) return '';
            const hasActive = threads.some(t => t.status === 'active' || t.status === undefined);
            return `<span class="file-thread-count${hasActive ? ' has-active' : ''}">${threads.length}</span>`;
        }

        // Propagate hasChanges/hasComments up the tree
        function propagateIndicators(node) {
            let hasChanges = false;
            let hasComments = false;
            for (const file of node.files) {
                if (file.changeType && file.changeType !== 'none') hasChanges = true;
                if (threadsByFilePath.has(file.path)) hasComments = true;
            }
            for (const [, child] of node.children) {
                propagateIndicators(child);
                if (child.hasChanges) hasChanges = true;
                if (child.hasComments) hasComments = true;
            }
            node.hasChanges = hasChanges;
            node.hasComments = hasComments;
        }

        function buildFileTree(changeEntries) {
            const container = document.getElementById('fileTreeContainer');
            const header = document.getElementById('fileTreeHeader');
            if (!container) return;

            // Build tree structure from change entries
            const root = { name: '', path: '', children: new Map(), files: [] };
            let fileCount = 0;

            for (const entry of changeEntries) {
                if (!entry.item?.path || entry.item.gitObjectType === 'tree' || entry.item.path.endsWith('/')) continue;
                addFileToTree(root, entry.item.path, entry.changeType, entry.sourceServerItem);
                fileCount++;
            }

            // In 'commented' mode, also add files that have threads but are not changed
            if (fileViewMode === 'commented') {
                for (const fp of commentedFilePaths) {
                    addFileToTree(root, fp, 'none', null);
                    fileCount++;
                }
            }

            if (fileCount === 0) {
                const label = fileViewMode === 'changed' ? 'No changed files' : 'No files';
                if (header) header.textContent = label;
                container.innerHTML = `<div style="padding: 16px; color: #a19f9d; font-size: 13px;">${label}</div>`;
                return;
            }

            const headerLabel = fileViewMode === 'commented' ? 'Files' : 'Changed Files';
            if (header) header.textContent = `${headerLabel} (${fileCount})`;

            // Collapse single-child directory chains
            function collapseDir(node) {
                for (const [key, child] of node.children) {
                    collapseDir(child);
                }
                while (node.children.size === 1 && node.files.length === 0) {
                    const childNode = node.children.values().next().value;
                    node.name = node.name ? node.name + '/' + childNode.name : childNode.name;
                    node.path = childNode.path;
                    node.children = childNode.children;
                    node.files = childNode.files;
                }
            }

            for (const [key, child] of root.children) {
                collapseDir(child);
            }

            // Propagate indicators
            propagateIndicators(root);

            // Render tree
            let idCounter = 0;
            function renderNode(node, depth) {
                let html = '';
                const sortedDirs = Array.from(node.children.values()).sort((a, b) => a.name.localeCompare(b.name));
                const sortedFiles = node.files.slice().sort((a, b) => a.name.localeCompare(b.name));

                for (const dir of sortedDirs) {
                    const dirId = 'ftd_' + (idCounter++);
                    let indicators = '';
                    if (dir.hasChanges || dir.hasComments) {
                        indicators = '<span class="dir-indicators">';
                        if (dir.hasChanges) indicators += '<span class="dir-indicator-change" title="Contains changes"></span>';
                        if (dir.hasComments) indicators += '<span class="dir-indicator-comment" title="Contains comments"></span>';
                        indicators += '</span>';
                    }
                    html += `<div class="file-tree-dir expanded" id="${dirId}">`;
                    html += `<div class="file-tree-dir-label" style="--depth: ${depth}" onclick="toggleFileTreeDir('${dirId}')">`;
                    html += `<span class="file-tree-toggle">▼</span>`;
                    html += `<span class="file-tree-dir-name">${ADOContent.escapeHtml(dir.name)}</span>`;
                    html += indicators;
                    html += `</div>`;
                    html += `<div class="file-tree-dir-children">`;
                    html += renderNode(dir, depth + 1);
                    html += `</div></div>`;
                }

                for (const file of sortedFiles) {
                    const isCommentOnly = file.changeType === 'none';
                    const indicator = isCommentOnly
                        ? '<span class="file-change-indicator comment">C</span>'
                        : getChangeIndicator(file.changeType);
                    const escapedPath = ADOContent.escapeHtml(file.path);
                    const fileCls = isCommentOnly ? 'file-tree-file no-change' : 'file-tree-file';
                    html += `<div class="${fileCls}" style="--depth: ${depth}" data-path="${escapedPath}" onclick="selectFileForDiff('${ADOContent.escapeJs(file.path)}', '${ADOContent.escapeJs(file.changeType)}')">`;
                    html += indicator;
                    html += `<span class="file-tree-file-name" title="${escapedPath}">${ADOContent.escapeHtml(file.name)}</span>`;
                    html += getThreadCountBadge(file.path);
                    html += `</div>`;
                    html += renderThreadSubList(file.path, depth);
                }

                return html;
            }

            container.innerHTML = renderNode(root, 0);
        }

        function getSourceCommitVersion() {
            const { sourceCommit } = getIterationCommits();
            return sourceCommit ? { version: sourceCommit, versionType: 'commit' } : null;
        }

        async function buildAllFilesTree() {
            const container = document.getElementById('fileTreeContainer');
            const header = document.getElementById('fileTreeHeader');
            if (!container) return;
            if (header) header.textContent = 'All Files';
            container.innerHTML = '<div style="padding: 16px; color: #a19f9d; font-size: 13px;">Loading...</div>';

            try {
                const ver = getSourceCommitVersion();
                // Try cache first (from background preload)
                let items;
                if (repoTreeCache.has('/')) {
                    items = repoTreeCache.get('/');
                } else {
                    const data = await ADOAPI.getRepoItems(currentConfig, '/', ver);
                    items = (data.value || []).filter(item => item.path !== '/');
                    repoTreeCache.set('/', items);
                }
                renderAllFilesLevel(container, items, 0);
            } catch (e) {
                console.error('Failed to load repo tree:', e);
                container.innerHTML = '<div style="padding: 16px; color: #a4262c; font-size: 13px;">Failed to load files</div>';
            }
        }

        function renderAllFilesLevel(container, items, depth) {
            let html = '';
            const dirs = items.filter(i => i.isFolder).sort((a, b) => a.path.localeCompare(b.path));
            const files = items.filter(i => !i.isFolder).sort((a, b) => a.path.localeCompare(b.path));

            for (const dir of dirs) {
                const dirName = dir.path.split('/').filter(p => p).pop() || dir.path;
                const dirId = 'ftda_' + dir.path.replace(/[^a-zA-Z0-9]/g, '_');
                const hasChanges = [...changedFilePaths].some(fp => fp.startsWith(dir.path + '/') || fp.startsWith(dir.path));
                const hasComments = [...threadsByFilePath.keys()].some(fp => fp.startsWith(dir.path + '/') || fp.startsWith(dir.path));
                let indicators = '';
                if (hasChanges || hasComments) {
                    indicators = '<span class="dir-indicators">';
                    if (hasChanges) indicators += '<span class="dir-indicator-change" title="Contains changes"></span>';
                    if (hasComments) indicators += '<span class="dir-indicator-comment" title="Contains comments"></span>';
                    indicators += '</span>';
                }
                html += `<div class="file-tree-dir" id="${dirId}">`;
                html += `<div class="file-tree-dir-label" style="--depth: ${depth}" onclick="expandRepoDir('${ADOContent.escapeJs(dir.path)}', '${dirId}', ${depth})">`;
                html += `<span class="file-tree-toggle">▶</span>`;
                html += `<span class="file-tree-dir-name">${ADOContent.escapeHtml(dirName)}</span>`;
                html += indicators;
                html += `</div>`;
                html += `<div class="file-tree-dir-children"></div>`;
                html += `</div>`;
            }

            for (const file of files) {
                const fileName = file.path.split('/').filter(p => p).pop() || file.path;
                const filePath = file.path;
                const isChanged = changedFilePaths.has(filePath);
                const isCommentedOnly = !isChanged && threadsByFilePath.has(filePath);
                const changeType = isChanged
                    ? (allChangeEntries.find(e => e.item?.path === filePath)?.changeType || 'edit')
                    : (isCommentedOnly ? 'none' : '');
                let indicator = '';
                if (isChanged) indicator = getChangeIndicator(changeType);
                else if (isCommentedOnly) indicator = '<span class="file-change-indicator comment">C</span>';
                const fileCls = isChanged ? 'file-tree-file' : (isCommentedOnly ? 'file-tree-file no-change' : 'file-tree-file no-change');
                const escapedPath = ADOContent.escapeHtml(filePath);
                html += `<div class="${fileCls}" style="--depth: ${depth}" data-path="${escapedPath}" onclick="selectFileForDiff('${ADOContent.escapeJs(filePath)}', '${ADOContent.escapeJs(changeType || 'none')}')">`;
                html += indicator;
                html += `<span class="file-tree-file-name" title="${escapedPath}">${ADOContent.escapeHtml(fileName)}</span>`;
                html += getThreadCountBadge(filePath);
                html += `</div>`;
                html += renderThreadSubList(filePath, depth);
            }

            container.innerHTML = html;
        }

        async function expandRepoDir(dirPath, dirId, depth) {
            const dirEl = document.getElementById(dirId);
            if (!dirEl) return;

            // Toggle if already expanded
            if (dirEl.classList.contains('expanded')) {
                dirEl.classList.remove('expanded');
                const toggle = dirEl.querySelector('.file-tree-toggle');
                if (toggle) toggle.textContent = '▶';
                const children = dirEl.querySelector('.file-tree-dir-children');
                if (children) children.style.display = 'none';
                return;
            }

            dirEl.classList.add('expanded');
            const toggle = dirEl.querySelector('.file-tree-toggle');
            if (toggle) toggle.textContent = '▼';
            const childrenContainer = dirEl.querySelector('.file-tree-dir-children');
            if (!childrenContainer) return;
            childrenContainer.style.display = '';

            // If already loaded, just show
            if (childrenContainer.children.length > 0) return;

            childrenContainer.innerHTML = `<div class="file-tree-dir-loading" style="--depth: ${depth + 1}">Loading...</div>`;

            try {
                let items;
                if (repoTreeCache.has(dirPath)) {
                    items = repoTreeCache.get(dirPath);
                } else {
                    const ver = getSourceCommitVersion();
                    const data = await ADOAPI.getRepoItems(currentConfig, dirPath, ver);
                    // Filter out the directory itself (API returns it as first item)
                    items = (data.value || []).filter(item => item.path !== dirPath);
                    repoTreeCache.set(dirPath, items);
                }
                renderAllFilesLevel(childrenContainer, items, depth + 1);
            } catch (e) {
                childrenContainer.innerHTML = `<div class="file-tree-dir-loading" style="--depth: ${depth + 1}">Failed to load</div>`;
                console.error('Failed to expand directory:', e);
            }
        }

        async function preloadRepoTree() {
            if (repoTreeFullyLoaded) return;
            try {
                const ver = getSourceCommitVersion();
                const data = await ADOAPI.getRepoTree(currentConfig, ver);
                const allItems = data.value || [];
                // Group items by parent directory
                const byParent = new Map();
                for (const item of allItems) {
                    const parts = item.path.split('/');
                    const parentPath = parts.length <= 2 ? '/' : parts.slice(0, -1).join('/');
                    if (item.path === '/') continue;
                    if (!byParent.has(parentPath)) byParent.set(parentPath, []);
                    byParent.get(parentPath).push(item);
                }
                // Merge into cache (don't overwrite manually fetched entries)
                for (const [dir, items] of byParent) {
                    if (!repoTreeCache.has(dir)) {
                        repoTreeCache.set(dir, items);
                    }
                }
                repoTreeFullyLoaded = true;
            } catch (e) {
                console.warn('Background repo tree preload failed:', e);
            }
        }

        function formatIterationDate(dateStr) {
            if (!dateStr) return '';
            const d = new Date(dateStr);
            if (isNaN(d)) return '';
            const now = new Date();
            const months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
            if (d.getFullYear() === now.getFullYear()) {
                return `${months[d.getMonth()]} ${d.getDate()}`;
            }
            return `${months[d.getMonth()]} ${d.getDate()}, ${d.getFullYear()}`;
        }

        function buildIterationSelector() {
            const container = document.getElementById('iterationSelector');
            if (!container) return;

            if (allIterations.length <= 1) {
                container.style.display = 'none';
                return;
            }

            container.style.display = '';
            const hasSel = selectedIterationStart !== null;
            const panelWasOpen = document.getElementById('iterationPanel')?.classList.contains('open') ?? true;
            const chevron = panelWasOpen ? '\u25BE' : '\u25B8';
            const selText = hasSel
                ? (selectedIterationStart === selectedIterationEnd ? `Update ${selectedIterationStart}` : `Updates ${selectedIterationStart}-${selectedIterationEnd}`)
                : 'All';

            let html = '<div class="iteration-selector-bar">';
            html += `<button class="iteration-collapse-toggle" onclick="toggleIterationPanel()">${chevron}</button>`;
            html += '<span class="iteration-selector-label">Updates:</span>';
            html += `<button class="iteration-btn${!hasSel ? ' active' : ''}" onclick="selectIterationAll()">All</button>`;
            html += `<span class="iteration-selection-text">${selText}</span>`;
            html += '</div>';

            html += `<div class="iteration-panel${panelWasOpen ? ' open' : ''}" id="iterationPanel">`;
            const total = allIterations.length;
            for (let i = 1; i <= total; i++) {
                const iter = allIterations[i - 1];
                const inRange = !hasSel || (i >= selectedIterationStart && i <= selectedIterationEnd);
                const isStart = !hasSel ? i === 1 : i === selectedIterationStart;
                const isEnd = !hasSel ? i === total : i === selectedIterationEnd;
                const isEdge = isStart || isEnd;
                let cls = 'iteration-row';
                if (isEdge) cls += ' range-edge';
                else if (inRange) cls += ' in-range';
                if (isStart) cls += ' range-edge-start';
                if (isEnd) cls += ' range-edge-end';

                const date = formatIterationDate(iter.createdDate);
                const commits = iter.commits || [];
                const lastCommitMsg = commits.length > 0
                    ? (commits[commits.length - 1].comment || '').split('\n')[0]
                    : '';

                html += `<div class="${cls}" data-iteration="${i}" onclick="selectIteration(${i})">`;
                html += `<div class="iteration-node-col"><div class="iteration-node"${isEdge ? ` onmousedown="startIterationDrag(event, ${i})"` : ''}></div></div>`;
                html += '<div class="iteration-info">';
                html += `<div class="iteration-info-top"><span class="iteration-number">${i}</span><span class="iteration-date">${date}</span></div>`;
                if (lastCommitMsg) {
                    html += `<div class="iteration-commit">${lastCommitMsg.replace(/</g, '&lt;').replace(/>/g, '&gt;')}</div>`;
                }
                html += '</div></div>';
            }
            html += '</div>';

            container.innerHTML = html;
        }

        function toggleIterationPanel() {
            const panel = document.getElementById('iterationPanel');
            if (!panel) return;
            panel.classList.toggle('open');
            const toggle = document.querySelector('.iteration-collapse-toggle');
            if (toggle) {
                toggle.textContent = panel.classList.contains('open') ? '\u25BE' : '\u25B8';
            }
        }

        function selectIterationAll() {
            if (selectedIterationStart === null) return;
            selectedIterationStart = null;
            selectedIterationEnd = null;
            buildIterationSelector();
            refreshFilesForIterationRange();
        }

        function selectIteration(num) {
            selectedIterationStart = num;
            selectedIterationEnd = num;
            buildIterationSelector();
            refreshFilesForIterationRange();
        }

        // Drag logic for iteration range handles
        let iterationDragState = null;

        function startIterationDrag(event, iterNum) {
            event.preventDefault();
            event.stopPropagation();

            const isStart = iterNum === selectedIterationStart;
            const isEnd = iterNum === selectedIterationEnd;
            // Determine which handle: if both (single selection), decide by drag direction later
            // For now, track both possibilities
            iterationDragState = {
                handle: isStart && isEnd ? 'both' : (isStart ? 'start' : 'end'),
                originalStart: selectedIterationStart,
                originalEnd: selectedIterationEnd,
                anchorIteration: isStart && isEnd ? iterNum : (isStart ? selectedIterationEnd : selectedIterationStart),
                initialY: event.clientY
            };

            document.addEventListener('mousemove', onIterationDrag);
            document.addEventListener('mouseup', endIterationDrag);
        }

        function onIterationDrag(event) {
            if (!iterationDragState) return;

            // Find which iteration row the mouse is closest to
            const rows = document.querySelectorAll('.iteration-row');
            let closestIteration = null;
            let closestDist = Infinity;
            rows.forEach(row => {
                const rect = row.getBoundingClientRect();
                const rowMid = rect.top + rect.height / 2;
                const dist = Math.abs(event.clientY - rowMid);
                if (dist < closestDist) {
                    closestDist = dist;
                    closestIteration = parseInt(row.dataset.iteration);
                }
            });

            if (closestIteration === null) return;

            const state = iterationDragState;
            if (state.handle === 'both') {
                // Decide direction based on initial drag movement
                if (Math.abs(event.clientY - state.initialY) > 5) {
                    if (event.clientY < state.initialY) {
                        state.handle = 'start';
                        state.anchorIteration = state.originalEnd;
                    } else {
                        state.handle = 'end';
                        state.anchorIteration = state.originalStart;
                    }
                } else {
                    return; // Not enough movement yet
                }
            }

            const anchor = state.anchorIteration;
            const newStart = Math.min(anchor, closestIteration);
            const newEnd = Math.max(anchor, closestIteration);

            if (newStart !== selectedIterationStart || newEnd !== selectedIterationEnd) {
                selectedIterationStart = newStart;
                selectedIterationEnd = newEnd;
                // Update visuals without re-fetching data
                updateIterationDropdownVisuals();
            }
        }

        function endIterationDrag() {
            document.removeEventListener('mousemove', onIterationDrag);
            document.removeEventListener('mouseup', endIterationDrag);

            if (!iterationDragState) return;
            const state = iterationDragState;
            iterationDragState = null;

            // Only refresh if the selection actually changed
            if (selectedIterationStart !== state.originalStart || selectedIterationEnd !== state.originalEnd) {
                // Update selection text
                const selText = document.querySelector('.iteration-selection-text');
                if (selText) {
                    const hasSel = selectedIterationStart !== null;
                    selText.textContent = hasSel
                        ? (selectedIterationStart === selectedIterationEnd ? `Update ${selectedIterationStart}` : `Updates ${selectedIterationStart}-${selectedIterationEnd}`)
                        : 'All';
                }
                refreshFilesForIterationRange();
            }
        }

        function updateIterationDropdownVisuals() {
            const rows = document.querySelectorAll('.iteration-row');
            const hasSel = selectedIterationStart !== null;
            const total = allIterations.length;
            rows.forEach(row => {
                const num = parseInt(row.dataset.iteration);
                const inRange = !hasSel || (num >= selectedIterationStart && num <= selectedIterationEnd);
                const isStart = !hasSel ? num === 1 : num === selectedIterationStart;
                const isEnd = !hasSel ? num === total : num === selectedIterationEnd;
                const isEdge = isStart || isEnd;

                row.classList.remove('range-edge', 'in-range', 'range-edge-start', 'range-edge-end');
                if (isEdge) row.classList.add('range-edge');
                else if (inRange) row.classList.add('in-range');
                if (isStart) row.classList.add('range-edge-start');
                if (isEnd) row.classList.add('range-edge-end');

                // Update node: add/remove drag handler
                const node = row.querySelector('.iteration-node');
                if (node) {
                    if (isEdge) {
                        node.onmousedown = (e) => startIterationDrag(e, num);
                        node.style.cursor = 'grab';
                        node.style.width = '16px';
                        node.style.height = '16px';
                    } else {
                        node.onmousedown = null;
                        node.style.cursor = '';
                        node.style.width = '';
                        node.style.height = '';
                    }
                }
            });

            // Update selection text
            const selText = document.querySelector('.iteration-selection-text');
            if (selText) {
                selText.textContent = hasSel
                    ? (selectedIterationStart === selectedIterationEnd ? `Update ${selectedIterationStart}` : `Updates ${selectedIterationStart}-${selectedIterationEnd}`)
                    : 'All';
            }

            // Update All button
            const allBtn = document.querySelector('.iteration-selector .iteration-btn');
            if (allBtn) {
                allBtn.classList.toggle('active', !hasSel);
            }
        }

        async function refreshFilesForIterationRange() {
            fileDiffCache.clear();
            selectedFilePath = null;
            fileTreeBuilt = false;

            // Reset diff panel
            const diffPanel = document.getElementById('fileDiffPanel');
            if (diffPanel) {
                diffPanel.innerHTML = '<div class="file-diff-empty">Select a file to view changes</div>';
            }

            try {
                let compareTo, iterationId;
                if (selectedIterationStart === null) {
                    // "All" mode
                    iterationId = allIterations.length;
                    compareTo = 0;
                } else {
                    iterationId = selectedIterationEnd;
                    compareTo = selectedIterationStart - 1;
                }

                const changesData = await ADOAPI.getPRIterationChanges(currentConfig, currentPRId, iterationId, compareTo);
                allChangeEntries = changesData.changeEntries || [];
                buildThreadsByFilePath(); // Rebuild changed/commented sets

                buildFileTree(allChangeEntries);
                fileTreeBuilt = true;

                // Update header with range info
                const header = document.getElementById('fileTreeHeader');
                if (header) {
                    let label = `Changed Files (${allChangeEntries.filter(e => e.item?.path && e.item.gitObjectType !== 'tree' && !e.item.path.endsWith('/')).length})`;
                    if (selectedIterationStart !== null) {
                        if (selectedIterationStart === selectedIterationEnd) {
                            label += ` — Update ${selectedIterationStart}`;
                        } else {
                            label += ` — Updates ${selectedIterationStart}-${selectedIterationEnd}`;
                        }
                    }
                    header.textContent = label;
                }

                // Update Files tab count
                const filesTabBtn = document.querySelector('.view-tab[data-view="files"]');
                if (filesTabBtn) {
                    const fileCount = allChangeEntries.filter(e => e.item?.path && e.item.gitObjectType !== 'tree' && !e.item.path.endsWith('/')).length;
                    filesTabBtn.textContent = `Files (${fileCount})`;
                }
            } catch (e) {
                console.error('Failed to refresh files for iteration range:', e);
            }
        }

        function getIterationCommits() {
            let baseCommit, sourceCommit;
            if (selectedIterationStart === null || selectedIterationEnd === null) {
                // "All" mode
                baseCommit = currentMergeBase || currentPRData.lastMergeTargetCommit?.commitId;
                sourceCommit = currentPRData.lastMergeSourceCommit?.commitId;
            } else {
                // Iteration range mode — clamp to valid bounds
                const endIdx = Math.min(selectedIterationEnd, allIterations.length) - 1;
                const startIdx = selectedIterationStart - 2;
                sourceCommit = allIterations[endIdx]?.sourceRefCommit?.commitId;
                if (selectedIterationStart <= 1 || startIdx < 0) {
                    baseCommit = currentMergeBase || currentPRData.lastMergeTargetCommit?.commitId;
                } else {
                    baseCommit = allIterations[startIdx]?.sourceRefCommit?.commitId;
                }
            }
            return { baseCommit, sourceCommit };
        }

        function toggleFileTreeDir(dirId) {
            const dir = document.getElementById(dirId);
            if (!dir) return;
            dir.classList.toggle('expanded');
            const toggle = dir.querySelector('.file-tree-toggle');
            if (toggle) {
                toggle.textContent = dir.classList.contains('expanded') ? '▼' : '▶';
            }
        }

        function getChangeIndicator(changeType) {
            const ct = changeType.toLowerCase();
            if (ct.includes('add')) {
                return '<span class="file-change-indicator add">A</span>';
            } else if (ct.includes('delete')) {
                return '<span class="file-change-indicator delete">D</span>';
            } else if (ct.includes('rename')) {
                return '<span class="file-change-indicator rename">R</span>';
            } else {
                return '<span class="file-change-indicator edit">M</span>';
            }
        }

        async function selectFileForDiff(filePath, changeType, scrollToThreadId) {
            // If same file already displayed and we just need to scroll to a thread, skip re-render
            if (scrollToThreadId && selectedFilePath === filePath && document.querySelector(`.inline-thread[data-thread-id="${scrollToThreadId}"]`)) {
                scrollToThread(scrollToThreadId);
                updateThreadNav(scrollToThreadId);
                return;
            }

            // Clear any thread/hunk focus from previous selection
            clearThreadFocus();
            currentHunkIndex = -1;

            // Highlight selected file in tree
            document.querySelectorAll('.file-tree-file.selected').forEach(el => el.classList.remove('selected'));
            const fileEl = document.querySelector(`.file-tree-file[data-path="${CSS.escape(filePath)}"]`);
            if (fileEl) fileEl.classList.add('selected');

            selectedFilePath = filePath;

            const diffPanel = document.getElementById('fileDiffPanel');
            if (!diffPanel) return;

            // Show loading
            diffPanel.innerHTML = '<div class="file-diff-loading">Loading diff...</div>';

            try {
                const ct = changeType.toLowerCase();

                // Find the change entry for source info
                const changeEntry = allChangeEntries.find(e => e.item?.path === filePath);
                const sourceServerItem = changeEntry?.sourceServerItem || changeEntry?.originalPath;

                // Determine commits based on iteration range
                const { baseCommit, sourceCommit } = getIterationCommits();

                if (!sourceCommit) {
                    diffPanel.innerHTML = '<div class="file-diff-error">Cannot determine commits for diff comparison.</div>';
                    return;
                }

                // Non-changed file: show as read-only content (no diff)
                if (ct === 'none' || ct === '') {
                    const content = await ADOAPI.getFileContent(currentConfig, filePath, { version: sourceCommit, versionType: 'commit' });
                    if (selectedFilePath !== filePath) return;
                    const lines = content.split('\n');
                    let bodyHtml = '';
                    for (let i = 0; i < lines.length; i++) {
                        bodyHtml += `<tr><td style="padding: 0 8px; color: #a19f9d; text-align: right; user-select: none; min-width: 40px;">${i + 1}</td><td style="padding: 0 8px; white-space: pre-wrap; word-break: break-all;">${ADOContent.escapeHtml(lines[i])}</td></tr>`;
                    }
                    diffPanel.innerHTML = `
                        <div class="file-diff-header">
                            <span class="file-diff-path">${ADOContent.escapeHtml(filePath.split('/').pop())}</span>
                            <span style="font-size: 12px; color: #a19f9d;">(read-only view)</span>
                        </div>
                        <div class="file-diff-body"><table style="border-collapse: collapse; width: 100%; font-family: monospace; font-size: 12px;">${bodyHtml}</table></div>`;
                    return;
                }

                if (!baseCommit) {
                    diffPanel.innerHTML = '<div class="file-diff-error">Cannot determine base commit for diff comparison.</div>';
                    return;
                }

                let oldCommitId, newCommitId, oldFilePath;
                if (ct.includes('add')) {
                    oldCommitId = null;
                    newCommitId = sourceCommit;
                    oldFilePath = null;
                } else if (ct.includes('delete')) {
                    oldCommitId = baseCommit;
                    newCommitId = null;
                    oldFilePath = null;
                } else {
                    oldCommitId = baseCommit;
                    newCommitId = sourceCommit;
                    oldFilePath = sourceServerItem || filePath;
                }

                const result = await DiffUtils.getOrComputeFileDiff(filePath, oldCommitId, newCommitId, oldFilePath, { config: currentConfig, cache: fileDiffCache, getFileContent: ADOAPI.getFileContent.bind(ADOAPI), diff: HistogramDiff });
                if (selectedFilePath !== filePath) return;

                renderFileDiff(filePath, changeType, result.diff, result.addedCount, result.removedCount, sourceServerItem);
                updateHunkNav();
                updateThreadNav(scrollToThreadId);
                if (scrollToThreadId) scrollToThread(scrollToThreadId);
            } catch (error) {
                console.error('Failed to load file diff:', error);
                if (selectedFilePath === filePath) {
                    diffPanel.innerHTML = `<div class="file-diff-error">Failed to load diff: ${ADOContent.escapeHtml(error.message)}</div>`;
                }
            }
        }

        function renderInlineThread(thread, appliesToView = true) {
            const threadId = thread.id;
            const status = thread.status;
            const isThreadDeleted = thread.isDeleted === true;
            const statusClass = ADOUI.getStatusBadgeClass(status, isThreadDeleted);
            const statusText = ADOUI.getStatusText(status, isThreadDeleted);
            const hasStatus = status !== undefined;

            const firstComment = thread.comments && thread.comments[0];
            const isSystemThread = firstComment && (firstComment.commentType === 'system' || firstComment.commentType === 3);

            // Thread iteration info
            const threadIter = thread.pullRequestThreadContext?.iterationContext?.secondComparingIteration;

            // Status dropdown (same logic as overview)
            let statusControl = '';
            if (!isThreadDeleted && !isSystemThread) {
                if (hasStatus) {
                    statusControl = `
                        <span class="thread-status-change">
                            <select onchange="changeThreadStatus('${threadId}', this.value); this.blur();">
                                <option value="">Change status...</option>
                                <option value="active" ${status === 'active' ? 'selected' : ''}>Active</option>
                                <option value="fixed" ${status === 'fixed' ? 'selected' : ''}>Resolved</option>
                                <option value="closed" ${status === 'closed' ? 'selected' : ''}>Closed</option>
                                <option value="wontFix" ${status === 'wontFix' ? 'selected' : ''}>Won't Fix</option>
                                <option value="pending" ${status === 'pending' ? 'selected' : ''}>Pending</option>
                                <option value="unknown" ${status === 'unknown' ? 'selected' : ''}>Unknown</option>
                            </select>
                            <button onclick="removeThreadStatus('${threadId}')" class="btn-secondary" style="margin-left: 5px; padding: 2px 8px; font-size: 12px;" title="Remove status">&times;</button>
                        </span>
                    `;
                } else {
                    statusControl = `
                        <span class="thread-status-change">
                            <select onchange="changeThreadStatus('${threadId}', this.value); this.blur();">
                                <option value="" selected>Set status...</option>
                                <option value="active">Active</option>
                                <option value="fixed">Resolved</option>
                                <option value="closed">Closed</option>
                                <option value="wontFix">Won't Fix</option>
                                <option value="pending">Pending</option>
                                <option value="unknown">Unknown</option>
                            </select>
                        </span>
                    `;
                }
            }

            // Collapsed by default for resolved/closed threads or threads from different iterations
            const isResolved = status === 'fixed' || status === 'closed' || status === 'wontFix';
            const collapsedClass = (isResolved || !appliesToView) ? ' collapsed' : '';
            const outdatedClass = !appliesToView ? ' inline-thread-outdated' : '';

            // Line info
            const ctx = thread.threadContext;
            const fileStart = ctx?.rightFileStart || ctx?.leftFileStart;
            const fileEnd = ctx?.rightFileEnd || ctx?.leftFileEnd;
            const lineLabel = fileStart ? `L${fileStart.line}${fileEnd && fileEnd.line !== fileStart.line ? '-' + fileEnd.line : ''}` : '';

            const commentCount = thread.comments ? thread.comments.filter(c => c.commentType !== 'system' && c.commentType !== 3 && !c.isDeleted).length : 0;

            let html = `<div class="inline-thread${collapsedClass}${outdatedClass}" data-thread-id="${threadId}">`;
            html += `<div class="inline-thread-header">`;
            if (hasStatus) html += `<span class="badge ${statusClass}" style="padding: 1px 6px; font-size: 10px;">${statusText}</span>`;
            if (!appliesToView) html += `<span style="color: #a19f9d; font-size: 10px; font-style: italic;">from update ${threadIter}</span>`;
            if (commentCount > 1) html += `<span style="color: #8a8886; font-size: 11px;">${commentCount} comments</span>`;
            if (statusControl) html += statusControl;
            html += `<span style="margin-left: auto; cursor: pointer; color: #605e5c; font-size: 14px;" onclick="toggleInlineThread(${threadId})" title="Collapse thread">&times;</span>`;
            html += `</div>`;

            // Comments
            if (thread.comments && thread.comments.length > 0) {
                for (const comment of thread.comments) {
                    if (comment.isDeleted) continue;
                    const isSystem = comment.commentType === 'system' || comment.commentType === 3;
                    if (isSystem) continue;

                    const resolvedContent = ADOContent.processContent(comment.content || '');
                    const escapedRaw = (comment.content || '').replace(/"/g, '&quot;').replace(/</g, '&lt;').replace(/>/g, '&gt;');

                    // Avatar
                    let avatarHtml = '';
                    if (comment.author?.id) {
                        const authorTitle = ADOContent.escapeHtml(comment.author.displayName || 'Unknown');
                        const cachedUrl = AvatarLoader.getCached(comment.author.id);
                        if (cachedUrl) {
                            avatarHtml = `<div class="avatar-wrapper"><img src="${cachedUrl}" alt="${authorTitle}" title="${authorTitle}" class="avatar"></div>`;
                        } else {
                            avatarHtml = `<div class="avatar-wrapper"><div class="avatar-placeholder" title="${authorTitle}"></div><img data-user-id="${comment.author.id}" alt="${authorTitle}" title="${authorTitle}" class="avatar avatar-pending"></div>`;
                        }
                    }

                    const showActions = !comment.isDeleted && !isSystem;
                    const editDeleteBtns = showActions ? `
                        <span class="comment-actions">
                            <button class="comment-action-btn" onclick="startInlineEditComment(${threadId}, ${comment.id})" title="Edit"><svg viewBox="0 0 24 24"><path d="M3 17.25V21h3.75L17.81 9.94l-3.75-3.75L3 17.25zM20.71 7.04c.39-.39.39-1.02 0-1.41l-2.34-2.34c-.39-.39-1.02-.39-1.41 0l-1.83 1.83 3.75 3.75 1.83-1.83z"/></svg></button>
                            <button class="comment-action-btn delete" onclick="deleteInlineComment(${threadId}, ${comment.id})" title="Delete"><svg viewBox="0 0 24 24"><path d="M6 19c0 1.1.9 2 2 2h8c1.1 0 2-.9 2-2V7H6v12zM19 4h-3.5l-1-1h-5l-1 1H5v2h14V4z"/></svg></button>
                        </span>
                    ` : '';

                    html += `
                        <div class="comment" data-thread-id="${threadId}" data-comment-id="${comment.id}" data-comment-content="${escapedRaw}">
                            <div class="comment-header">
                                <span class="comment-author-info">
                                    ${avatarHtml}
                                    <span style="font-weight: 600; font-size: 12px;">${ADOContent.escapeHtml(comment.author?.displayName || 'Unknown')}</span>
                                    <span class="comment-date">${ADOUI.formatDate(comment.publishedDate)}</span>
                                </span>
                                ${editDeleteBtns}
                            </div>
                            <div class="comment-content-wrapper" id="inline-comment-content-${threadId}-${comment.id}">
                                <div class="comment-content">${resolvedContent}</div>
                            </div>
                        </div>
                    `;
                }
            }

            // Reply button and form
            if (!isThreadDeleted && !isSystemThread) {
                html += `
                    <div class="thread-reply-container">
                        <button class="thread-reply-btn" onclick="showInlineReplyForm(${threadId})" id="inline-reply-btn-${threadId}">Reply</button>
                        <div id="inline-reply-form-${threadId}"></div>
                    </div>
                `;
            }

            html += `</div>`;
            return html;
        }

        function setupSbsScrollSync(diffPanel) {
            const body = diffPanel.querySelector('.file-diff-body');
            if (!body) return;
            const panes = body.querySelectorAll('.sbs-left, .sbs-right');
            if (panes.length === 0) return;

            // Measure the max content overflow across all panes
            let maxScrollWidth = 0;
            let paneClientWidth = 0;
            for (const pane of panes) {
                if (pane.scrollWidth > maxScrollWidth) maxScrollWidth = pane.scrollWidth;
                if (pane.clientWidth > paneClientWidth) paneClientWidth = pane.clientWidth;
            }

            // No overflow — no scrollbar needed
            if (maxScrollWidth <= paneClientWidth) return;

            // Build custom scrollbar (no native overlay issues)
            const track = document.createElement('div');
            track.className = 'sbs-scroll-track';
            const thumb = document.createElement('div');
            thumb.className = 'sbs-scroll-thumb';
            track.appendChild(thumb);
            body.appendChild(track);

            const scrollRange = maxScrollWidth - paneClientWidth;
            const trackWidth = track.clientWidth;
            const thumbWidth = Math.max(30, trackWidth * (paneClientWidth / maxScrollWidth));
            thumb.style.width = thumbWidth + 'px';
            const maxThumbLeft = trackWidth - thumbWidth;

            let currentOffset = 0;
            const contents = body.querySelectorAll('.diff-lines-sbs .diff-content');

            function applyScroll(ratio) {
                ratio = Math.max(0, Math.min(1, ratio));
                currentOffset = ratio * scrollRange;
                thumb.style.left = (ratio * maxThumbLeft) + 'px';
                for (const el of contents) {
                    el.style.transform = `translateX(-${currentOffset}px)`;
                }
            }

            // Drag thumb
            let dragging = false, dragStartX = 0, dragStartLeft = 0;
            thumb.addEventListener('mousedown', (e) => {
                dragging = true;
                dragStartX = e.clientX;
                dragStartLeft = parseFloat(thumb.style.left) || 0;
                thumb.classList.add('dragging');
                e.preventDefault();
            });
            document.addEventListener('mousemove', (e) => {
                if (!dragging) return;
                const dx = e.clientX - dragStartX;
                const newLeft = Math.max(0, Math.min(maxThumbLeft, dragStartLeft + dx));
                applyScroll(maxThumbLeft > 0 ? newLeft / maxThumbLeft : 0);
            });
            document.addEventListener('mouseup', () => {
                if (dragging) {
                    dragging = false;
                    thumb.classList.remove('dragging');
                }
            });

            // Click on track to jump
            track.addEventListener('mousedown', (e) => {
                if (e.target === thumb) return;
                const rect = track.getBoundingClientRect();
                const clickX = e.clientX - rect.left - thumbWidth / 2;
                applyScroll(maxThumbLeft > 0 ? clickX / maxThumbLeft : 0);
            });

            // Shift+wheel to scroll horizontally
            const scrollArea = body.querySelector('.diff-scroll-area');
            if (scrollArea) {
                scrollArea.addEventListener('wheel', (e) => {
                    if (!e.shiftKey) return;
                    e.preventDefault();
                    const delta = e.deltaY || e.deltaX;
                    const newOffset = currentOffset + delta;
                    applyScroll(scrollRange > 0 ? newOffset / scrollRange : 0);
                }, { passive: false });
            }
        }

        function renderFileDiff(filePath, changeType, diff, addedCount, removedCount, sourceServerItem) {
            const diffPanel = document.getElementById('fileDiffPanel');
            if (!diffPanel) return;

            const indicator = getChangeIndicator(changeType);
            const ct = changeType.toLowerCase();

            let renameInfo = '';
            if (ct.includes('rename') && sourceServerItem) {
                renameInfo = `<div class="file-diff-rename-info">Renamed from ${ADOContent.escapeHtml(sourceServerItem)}</div>`;
            }

            const inlineActive = fileDiffDisplayMode === 'inline' ? ' active' : '';
            const sbsActive = fileDiffDisplayMode === 'side-by-side' ? ' active' : '';

            let headerHtml = `
                <div class="file-diff-header">
                    ${indicator}
                    <span class="file-diff-path">${ADOContent.escapeHtml(filePath)}</span>
                    <div class="diff-display-mode-bar">
                        <button class="file-view-mode-btn${inlineActive}" onclick="setDiffDisplayMode('inline')">Inline</button>
                        <button class="file-view-mode-btn${sbsActive}" onclick="setDiffDisplayMode('side-by-side')">Side by Side</button>
                    </div>
                    <div class="file-diff-stats">
                        <span class="stat-added">+${addedCount}</span>
                        <span class="stat-removed">-${removedCount}</span>
                    </div>
                    <div class="hunk-nav" id="hunkNav" style="display:none;">
                        <button class="hunk-nav-btn" id="hunkNavPrev" onclick="jumpToPrevHunk()" title="Previous change (Alt+Left)">&#9650;</button>
                        <span class="hunk-nav-label" id="hunkNavLabel"></span>
                        <button class="hunk-nav-btn" id="hunkNavNext" onclick="jumpToNextHunk()" title="Next change (Alt+Right)">&#9660;</button>
                    </div>
                    <div class="thread-nav" id="threadNav" style="display:none;">
                        <button class="thread-nav-btn" id="threadNavPrev" onclick="jumpToPrevThread()" title="Previous thread (Alt+Up)">&#9650;</button>
                        <span class="thread-nav-label" id="threadNavLabel"></span>
                        <button class="thread-nav-btn" id="threadNavNext" onclick="jumpToNextThread()" title="Next thread (Alt+Down)">&#9660;</button>
                    </div>
                    ${renameInfo}
                </div>
            `;

            // Gather threads for this file, sorted by start line
            const fileThreads = (threadsByFilePath.get(filePath) || []).filter(thread => {
                if (thread.isDeleted) return false;
                if (!thread.threadContext) return false;
                const hasRealComment = thread.comments?.some(c => c.commentType !== 'system' && c.commentType !== 3);
                return hasRealComment;
            }).sort((a, b) => {
                const aLine = a.threadContext.rightFileStart?.line || a.threadContext.leftFileStart?.line || 0;
                const bLine = b.threadContext.rightFileStart?.line || b.threadContext.leftFileStart?.line || 0;
                return aLine - bLine;
            });

            // Determine the iteration range currently being viewed
            const viewIterStart = selectedIterationStart ?? 1;
            const viewIterEnd = selectedIterationEnd ?? (allIterations.length || 1);

            // Build thread range info with iteration applicability
            const threadRanges = fileThreads.map(thread => DiffUtils.buildThreadRange(thread, viewIterStart, viewIterEnd));

            // Helper: get gutter avatars for threads starting at this line
            function getLinePrefix(newLineNum, oldLineNum) {
                let html = '';
                for (const tr of threadRanges) {
                    const lineNum = tr.useRight ? newLineNum : oldLineNum;
                    if (lineNum == null || lineNum !== tr.startLine) continue;
                    if (tr.useRight && oldLineNum != null && newLineNum == null) continue;
                    if (!tr.useRight && newLineNum != null && oldLineNum == null) continue;

                    const thread = tr.thread;
                    const status = thread.status;
                    const isResolved = status === 'fixed' || status === 'closed' || status === 'wontFix';
                    const isCollapsed = isResolved || !tr.appliesToView;

                    const firstRealComment = thread.comments?.find(c => c.commentType !== 'system' && c.commentType !== 3 && !c.isDeleted);
                    const authorName = ADOContent.escapeHtml(firstRealComment?.author?.displayName || '?');
                    const cachedUrl = firstRealComment?.author?.id ? AvatarLoader.getCached(firstRealComment.author.id) : null;

                    const avatarInner = cachedUrl
                        ? `<img src="${cachedUrl}" alt="${authorName}" title="${authorName}: click to expand thread">`
                        : `<div class="gutter-avatar-placeholder" title="${authorName}: click to expand thread"><svg viewBox="0 0 24 24"><path d="M20 2H4c-1.1 0-2 .9-2 2v18l4-4h14c1.1 0 2-.9 2-2V4c0-1.1-.9-2-2-2zm0 14H6l-2 2V4h16v12z"/></svg></div>`;

                    // Visible when collapsed, hidden when expanded
                    const displayStyle = isCollapsed ? '' : ' style="display:none"';
                    const sideClass = fileDiffDisplayMode === 'side-by-side' ? (tr.useRight ? ' gutter-right' : ' gutter-left') : '';
                    html += `<div class="diff-gutter-avatar${sideClass}" data-thread-id="${thread.id}" onclick="toggleInlineThread(${thread.id})"${displayStyle}>${avatarInner}</div>`;
                }
                return html;
            }

            // Helper: get inline thread widgets to insert after this line
            function getLineSuffix(newLineNum, oldLineNum) {
                let html = '';
                if (fileDiffDisplayMode === 'side-by-side') {
                    const leftThreads = [];
                    const rightThreads = [];
                    for (const tr of threadRanges) {
                        if (tr.inserted) continue;
                        const lineNum = tr.useRight ? newLineNum : oldLineNum;
                        if (lineNum != null && lineNum >= tr.endLine) {
                            tr.inserted = true;
                            const threadHtml = renderInlineThread(tr.thread, tr.appliesToView);
                            if (tr.useRight) rightThreads.push(threadHtml);
                            else leftThreads.push(threadHtml);
                        }
                    }
                    // Pair left and right threads into shared rows
                    const maxLen = Math.max(leftThreads.length, rightThreads.length);
                    for (let j = 0; j < maxLen; j++) {
                        const left = j < leftThreads.length
                            ? `<div class="sbs-thread-side sbs-thread-left">${leftThreads[j]}</div>`
                            : `<div class="sbs-thread-spacer sbs-thread-left"></div>`;
                        const right = j < rightThreads.length
                            ? `<div class="sbs-thread-side">${rightThreads[j]}</div>`
                            : `<div class="sbs-thread-spacer"></div>`;
                        html += `<div class="sbs-thread-row">${left}${right}</div>`;
                    }
                } else {
                    for (const tr of threadRanges) {
                        if (tr.inserted) continue;
                        const lineNum = tr.useRight ? newLineNum : oldLineNum;
                        if (lineNum != null && lineNum >= tr.endLine) {
                            tr.inserted = true;
                            html += renderInlineThread(tr.thread, tr.appliesToView);
                        }
                    }
                }
                return html;
            }

            // Render diff lines with highlighting and inline threads
            let diffHtml;
            if (fileDiffDisplayMode === 'side-by-side') {
                diffHtml = DiffUtils.renderDiffLinesSideBySide(diff, threadRanges, { getLinePrefix, getLineSuffix });
            } else {
                diffHtml = DiffUtils.renderDiffLines(diff, threadRanges, { getLinePrefix, getLineSuffix });
            }

            // Insert any remaining threads that weren't placed (e.g. beyond end of diff)
            if (fileDiffDisplayMode === 'side-by-side') {
                const leftRemaining = [];
                const rightRemaining = [];
                for (const tr of threadRanges) {
                    if (tr.inserted) continue;
                    const threadHtml = renderInlineThread(tr.thread, tr.appliesToView);
                    if (tr.useRight) rightRemaining.push(threadHtml);
                    else leftRemaining.push(threadHtml);
                }
                const maxLen = Math.max(leftRemaining.length, rightRemaining.length);
                for (let j = 0; j < maxLen; j++) {
                    const left = j < leftRemaining.length
                        ? `<div class="sbs-thread-side sbs-thread-left">${leftRemaining[j]}</div>`
                        : `<div class="sbs-thread-spacer sbs-thread-left"></div>`;
                    const right = j < rightRemaining.length
                        ? `<div class="sbs-thread-side">${rightRemaining[j]}</div>`
                        : `<div class="sbs-thread-spacer"></div>`;
                    diffHtml += `<div class="sbs-thread-row">${left}${right}</div>`;
                }
            } else {
                for (const tr of threadRanges) {
                    if (!tr.inserted) {
                        diffHtml += renderInlineThread(tr.thread, tr.appliesToView);
                    }
                }
            }

            const sbsClass = fileDiffDisplayMode === 'side-by-side' ? ' diff-lines-sbs' : '';
            diffPanel.innerHTML = `
                ${headerHtml}
                <div class="file-diff-body">
                    <div class="diff-scroll-area">
                        <div class="diff-lines${sbsClass}">${diffHtml}</div>
                    </div>
                </div>
            `;

            // Trigger avatar loading for inline threads
            AvatarLoader.loadPending();

            // Set up horizontal scroll sync for SBS mode
            if (fileDiffDisplayMode === 'side-by-side') {
                setupSbsScrollSync(diffPanel);
            }
        }

        // File tree panel resize functionality
        (function initFileTreeResize() {
            const resizeHandle = document.getElementById('fileTreeResizeHandle');
            const panel = document.querySelector('.file-tree-panel');
            if (!resizeHandle || !panel) return;
            let isResizing = false;
            let startX = 0;
            let startWidth = 0;

            resizeHandle.addEventListener('mousedown', (e) => {
                isResizing = true;
                startX = e.clientX;
                startWidth = panel.offsetWidth;
                document.body.style.cursor = 'col-resize';
                document.body.style.userSelect = 'none';
                e.preventDefault();
            });

            document.addEventListener('mousemove', (e) => {
                if (!isResizing) return;
                const diff = e.clientX - startX;
                const newWidth = startWidth + diff;
                if (newWidth >= 200 && newWidth <= 500) {
                    panel.style.width = newWidth + 'px';
                }
            });

            document.addEventListener('mouseup', () => {
                if (isResizing) {
                    isResizing = false;
                    document.body.style.cursor = '';
                    document.body.style.userSelect = '';
                }
            });
        })();

        // Restore view from URL on load
        (function restoreViewFromURL() {
            const params = new URLSearchParams(window.location.search);
            if (params.get('view') === 'files') {
                // Will be applied after PR loads — just set the variable
                currentView = 'files';
            }
        })();

        // Left sidebar resize functionality
        (function initLeftSidebarResize() {
            const resizeHandle = document.getElementById('resizeHandle');
            const sidebar = document.querySelector('.left-sidebar');
            let isResizing = false;
            let startX = 0;
            let startWidth = 0;

            resizeHandle.addEventListener('mousedown', (e) => {
                isResizing = true;
                startX = e.clientX;
                startWidth = sidebar.offsetWidth;
                document.body.style.cursor = 'col-resize';
                document.body.style.userSelect = 'none';
                e.preventDefault();
            });

            document.addEventListener('mousemove', (e) => {
                if (!isResizing) return;

                const diff = e.clientX - startX;
                const newWidth = startWidth + diff;

                // Apply min/max constraints
                if (newWidth >= 200 && newWidth <= 600) {
                    sidebar.style.width = newWidth + 'px';
                }
            });

            document.addEventListener('mouseup', () => {
                if (isResizing) {
                    isResizing = false;
                    document.body.style.cursor = '';
                    document.body.style.userSelect = '';
                }
            });
        })();

        // Right sidebar resize functionality
        (function initRightSidebarResize() {
            const resizeHandle = document.getElementById('resizeHandleRight');
            const sidebar = document.getElementById('rightSidebar');
            let isResizing = false;
            let startX = 0;
            let startWidth = 0;

            resizeHandle.addEventListener('mousedown', (e) => {
                isResizing = true;
                startX = e.clientX;
                startWidth = sidebar.offsetWidth;
                document.body.style.cursor = 'col-resize';
                document.body.style.userSelect = 'none';
                e.preventDefault();
            });

            document.addEventListener('mousemove', (e) => {
                if (!isResizing) return;

                // Note: direction is reversed (dragging left increases width)
                const diff = startX - e.clientX;
                const newWidth = startWidth + diff;

                // Apply min/max constraints
                if (newWidth >= 200 && newWidth <= 500) {
                    sidebar.style.width = newWidth + 'px';
                }
            });

            document.addEventListener('mouseup', () => {
                if (isResizing) {
                    isResizing = false;
                    document.body.style.cursor = '';
                    document.body.style.userSelect = '';
                }
            });
        })();
    </script>

    <!-- PR Action Modal -->
    <div class="modal-overlay" id="prActionModal">
        <div class="modal-content" style="max-width: 500px;">
            <div class="modal-header">
                <h3 id="prActionModalTitle">PR Action</h3>
                <button class="modal-close" onclick="closePRActionModal()">&times;</button>
            </div>
            <div id="prActionModalBody"></div>
            <div class="pr-action-modal-footer" id="prActionModalFooter"></div>
        </div>
    </div>
</body>
</html>
