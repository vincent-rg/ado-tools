<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Azure DevOps PR Threads Viewer</title>
    <link rel="stylesheet" href="common.css">
    <style>
        .container.wide {
            padding: 0;
        }

        /* Sidebar layout */
        .page-layout {
            display: flex;
            gap: 0;
            height: calc(100vh - 50px);
        }

        .sidebar {
            width: 280px;
            min-width: 200px;
            max-width: 400px;
            background: #edebe9;
            border-radius: 0;
            padding: 20px;
            overflow-y: auto;
            flex-shrink: 0;
            position: relative;
        }

        .resize-handle {
            position: absolute;
            right: 0;
            top: 0;
            bottom: 0;
            width: 8px;
            cursor: col-resize;
            background: transparent;
            transition: background 0.2s;
        }

        .resize-handle:hover {
            background: rgba(0, 120, 212, 0.2);
        }

        .main-content {
            flex: 1;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        .results-container {
            flex: 1;
            overflow-y: auto;
            background: #f9f8f7;
        }

        /* Filter section styling */
        .filter-section {
            margin-bottom: 20px;
        }

        .filter-section:last-child {
            margin-bottom: 0;
        }

        .filter-section h4 {
            margin-bottom: 10px;
            margin-top: 0;
            color: #323130;
            font-size: 14px;
        }

        .filter-section select {
            width: 100%;
            padding: 8px;
            border: 1px solid #d1d1d1;
            border-radius: 0;
            background: white;
        }

        .filter-section input[type="text"] {
            width: 100%;
            padding: 8px;
            border: 1px solid #d1d1d1;
            border-radius: 0;
            font-size: 14px;
            box-sizing: border-box;
        }

        .filter-section input[type="text"]:focus {
            outline: none;
            border-color: #0078d4;
        }

        /* Status chips for vertical layout */
        .status-chips-vertical {
            display: flex;
            flex-direction: column;
            gap: 6px;
        }

        .status-chip {
            padding: 6px 12px;
            border: 1px solid #d1d1d1;
            border-radius: 0;
            background: white;
            color: #323130;
            font-size: 13px;
            cursor: pointer;
            transition: all 0.2s;
            user-select: none;
            text-align: left;
        }

        .status-chip:hover {
            border-color: #0078d4;
            background: #f3f9fd;
        }

        .status-chip.selected {
            background: #0078d4;
            color: white;
            border-color: #0078d4;
        }

        .checkbox-label {
            display: flex;
            align-items: center;
            padding: 8px;
            background: white;
            border-radius: 0;
            cursor: pointer;
            transition: background 0.2s;
            margin-top: 8px;
        }

        .checkbox-label:hover {
            background: #e1f3ff;
        }

        .checkbox-label input[type="checkbox"] {
            margin-right: 8px;
        }

        .filter-actions {
            display: flex;
            gap: 10px;
            margin-top: 20px;
        }

        .thread-count {
            font-size: 13px;
            color: #605e5c;
            margin-top: 15px;
            padding-top: 15px;
            border-top: 1px solid #d1d1d1;
        }

        /* PR info bar */
        .pr-info {
            background: #f9f8f7;
            padding: 15px;
            border-radius: 0;
            margin-bottom: 20px;
            display: flex;
            gap: 20px;
        }

        .pr-info-main {
            flex: 1;
            min-width: 0;
        }

        .pr-info-sidebar {
            flex: 0 0 auto;
            min-width: 200px;
            max-width: 280px;
        }

        .pr-info-sidebar .avatars-section {
            margin-top: 0;
        }

        .pr-info-sidebar .avatars-section + .avatars-section {
            margin-top: 10px;
        }

        .thread-container {
            margin-bottom: 30px;
            padding: 20px;
            background: #f9f8f7;
        }

        .thread {
            border: 1px solid #e1dfdd;
            border-radius: 0;
            margin-bottom: 20px;
            overflow: hidden;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }

        .thread.compact-view .comment {
            padding: 8px 15px;
        }

        .thread.compact-view .comment-content {
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            max-width: 100%;
        }

        .thread.compact-view .comment-header {
            margin-bottom: 4px;
        }

        .thread.compact-view .thread-context,
        .thread.compact-view .raw-json-container {
            display: none;
        }

        .thread.compact-view .comment-content pre,
        .thread.compact-view .comment-content code,
        .thread.compact-view .comment-content img {
            display: none;
        }

        .thread-status-change {
            display: inline-flex;
            align-items: center;
            gap: 8px;
            margin-left: 10px;
        }

        .thread-status-change select {
            padding: 4px 8px;
            border: 1px solid #d1d1d1;
            border-radius: 0;
            font-size: 12px;
            background: white;
        }

        .thread-checkbox {
            margin-right: 10px;
        }

        .bulk-actions {
            background: #fff4ce;
            border-left: 4px solid #ffb900;
            padding: 15px;
            border-radius: 0;
            margin-bottom: 20px;
            display: none;
        }

        .bulk-actions.show {
            display: block;
        }

        .bulk-actions-buttons {
            display: flex;
            gap: 10px;
            align-items: center;
            flex-wrap: wrap;
            margin-top: 10px;
        }

        .bulk-actions-buttons select {
            padding: 8px;
            border: 1px solid #d1d1d1;
            border-radius: 0;
        }

        .thread-header {
            background: #ffffff;
            padding: 10px 15px;
            font-weight: 600;
            color: #323130;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .comment {
            padding: 12px 15px;
            border-bottom: 1px solid #edebe9;
            background: #ffffff;
        }

        .comment:last-child {
            border-bottom: none;
        }

        .comment.system-comment {
            background: #f8f8f8;
            border-left: 3px solid #a19f9d;
        }

        .comment.code-change-comment {
            background: #fff9e6;
            border-left: 3px solid #ffb900;
        }

        .comment-type-badge {
            display: inline-block;
            padding: 2px 8px;
            border-radius: 12px;
            font-size: 11px;
            font-weight: 600;
            margin-left: 8px;
            text-transform: uppercase;
        }

        .comment-type-system {
            background: #e1dfdd;
            color: #605e5c;
        }

        .comment-type-code-change {
            background: #fff4ce;
            color: #8a6d3b;
        }

        .comment-type-text {
            background: #e1f3ff;
            color: #004578;
        }

        .comment-type-deleted {
            background: #fde7e9;
            color: #a4262c;
        }

        .comment-header {
            margin-bottom: 8px;
        }

        .comment-author-info {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .comment-author-info .avatar-wrapper {
            --avatar-size: 28px;
        }

        .comment-date {
            color: #605e5c;
            font-size: 13px;
        }

        .comment-link {
            text-decoration: none;
            margin-left: 8px;
            display: inline-flex;
            align-items: center;
        }

        .comment-link svg {
            width: 16px;
            height: 16px;
            fill: #0078d4;
        }

        .comment-link:hover svg {
            filter: drop-shadow(0 0 3px #0078d4);
        }

        .code-links {
            display: flex;
            align-items: center;
        }

        .iteration-range {
            font-size: 11px;
            color: #605e5c;
            margin-left: 8px;
        }

        .comment-content {
            color: #323130;
            white-space: pre-wrap;
            word-wrap: break-word;
        }

        .comment-content strong {
            font-weight: 700;
            color: #323130;
        }

        .comment-content em {
            font-style: italic;
            color: #323130;
        }

        .comment-content a {
            color: #0078d4;
            text-decoration: none;
        }

        .comment-content a:hover {
            text-decoration: underline;
        }

        .comment-content img {
            max-width: 100%;
            height: auto;
            border: 1px solid #d1d1d1;
            border-radius: 0;
            margin: 5px 5px 5px 0;
            display: inline-block;
            vertical-align: middle;
        }

        .thread-context {
            background: #fff4ce;
            padding: 8px 12px;
            margin-bottom: 10px;
            border-left: 3px solid #ffb900;
            font-size: 13px;
        }

        .file-preview {
            background: #f8f8f8;
            border: 1px solid #d1d1d1;
            border-radius: 0;
        }

        .file-preview-header {
            padding: 8px 12px;
            background: #fff4ce;
            border-left: 3px solid #ffb900;
            cursor: pointer;
            font-size: 13px;
            color: #323130;
            font-weight: normal;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .file-preview-header:hover {
            background: #ffecb3;
        }

        .file-preview-header span:first-child {
            color: #0078d4;
            font-weight: 600;
        }

        .file-preview-content {
            display: none;
            padding: 0;
            max-height: 400px;
            overflow-y: auto;
        }

        .file-preview-content.show {
            display: block;
        }

        .file-preview-content pre {
            margin: 0;
            padding: 12px;
            background: #f8f8f8;
            color: #323130;
            font-family: 'Consolas', 'Monaco', 'Courier New', monospace;
            font-size: 12px;
            line-height: 1.5;
            overflow-x: auto;
        }

        .file-preview-line {
            display: flex;
            gap: 10px;
        }

        .file-preview-line-number {
            color: #999;
            text-align: right;
            min-width: 40px;
            user-select: none;
        }

        .file-preview-line-content {
            flex: 1;
        }

        /* Diff styles */
        .diff-line {
            display: flex;
            font-family: 'Consolas', 'Monaco', 'Courier New', monospace;
            font-size: 12px;
            line-height: 1.5;
        }

        .diff-line-number {
            color: #6e7681;
            text-align: right;
            min-width: 35px;
            padding: 0 8px;
            user-select: none;
            background: rgba(0, 0, 0, 0.05);
        }

        .diff-indicator {
            width: 20px;
            text-align: center;
            font-weight: bold;
            user-select: none;
        }

        .diff-content {
            flex: 1;
            padding-left: 8px;
            white-space: pre;
        }

        .diff-unchanged {
            background: #f6f8fa;
            color: #24292f;
        }

        .diff-added {
            background: #e6ffec;
            color: #1a7f37;
        }

        .diff-added .diff-indicator {
            color: #1a7f37;
        }

        .diff-removed {
            background: #ffebe9;
            color: #cf222e;
        }

        .diff-removed .diff-indicator {
            color: #cf222e;
        }

        .api-link {
            color: #0078d4;
            text-decoration: none;
            font-size: 12px;
            font-family: monospace;
            background: #f9f8f7;
            padding: 4px 8px;
            border-radius: 0;
            display: inline-block;
            margin-top: 5px;
        }

        .api-link:hover {
            background: #e1dfdd;
            text-decoration: underline;
        }

        /* Reviewer/Author avatars section */
        .avatars-section {
            margin-top: 15px;
            padding: 12px;
            background: #f8f8f8;
            border-radius: 0;
        }

        .avatars-section h4 {
            margin: 0 0 10px 0;
            font-size: 14px;
            color: #323130;
        }

        .avatars-section .avatars-container {
            gap: 8px;
        }

        .avatars-section .avatar-wrapper {
            --avatar-size: 36px;
        }

        .avatars-section .avatar,
        .avatars-section .avatar-fallback,
        .avatars-section .avatar-placeholder {
            border-width: 2px;
            border-color: #e1dfdd;
        }

        /* Vote badges */
        .vote-badge {
            position: absolute;
            bottom: -3px;
            right: -3px;
            width: 16px;
            height: 16px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 10px;
            font-weight: bold;
            color: white;
            border: 2px solid white;
            z-index: 5;
        }

        .vote-badge.vote-approved {
            background: #107c10;
        }

        .vote-badge.vote-approved-suggestions {
            background: #498205;
        }

        .vote-badge.vote-wait {
            background: #d83b01;
        }

        .vote-badge.vote-rejected {
            background: #a4262c;
        }

        .vote-badge.vote-no-vote {
            background: #8a8886;
        }

        /* Thread count badge */
        .thread-badge {
            position: absolute;
            top: -5px;
            right: -5px;
            min-width: 18px;
            height: 18px;
            border-radius: 50%;
            background: #d83b01;
            color: white;
            font-size: 11px;
            font-weight: bold;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 0 4px;
            border: 2px solid white;
            z-index: 5;
        }

        .avatar-wrapper:hover .vote-badge,
        .avatar-wrapper:hover .thread-badge,
        .avatar-wrapper:hover .author-badge {
            transform: scale(1.15);
            z-index: 11;
        }

        /* PR Author badge */
        .author-badge {
            position: absolute;
            top: -5px;
            left: -5px;
            width: 18px;
            height: 18px;
            border-radius: 50%;
            background: #ffb900;
            display: flex;
            align-items: center;
            justify-content: center;
            border: 1px solid white;
            z-index: 5;
        }

        .author-badge svg {
            width: 10px;
            height: 10px;
        }

        .comment-author-info .author-badge {
            width: 12px;
            height: 12px;
            top: -3px;
            left: -3px;
        }

        .comment-author-info .author-badge svg {
            width: 7px;
            height: 7px;
        }

        /* PR title avatar */
        .pr-title-avatar {
            --avatar-size: 28px;
            vertical-align: middle;
            margin-right: 8px;
        }

        /* Branch info */
        .branch-info {
            margin: 8px 0;
        }

        .branch-info code {
            background: #f9f8f7;
            padding: 2px 6px;
            border-radius: 0;
            font-family: monospace;
            font-size: 13px;
        }

        /* Checks section */
        .checks-section {
            margin-top: 15px;
            padding: 12px;
            background: #f8f8f8;
            border-radius: 0;
        }

        .checks-section h4 {
            margin: 0 0 12px 0;
            font-size: 14px;
            color: #323130;
        }

        .checks-loading {
            color: #605e5c;
            font-size: 13px;
        }

        .check-group {
            margin-bottom: 12px;
        }

        .check-group:last-child {
            margin-bottom: 0;
        }

        .check-group-header {
            font-weight: 600;
            font-size: 13px;
            margin-bottom: 6px;
            padding: 4px 8px;
            border-radius: 0;
            background: #e1dfdd;
            color: #323130;
        }

        .check-group-header.status-indicator-error {
            background: #fde7e9;
            color: #d13438;
        }

        .check-group-header.status-indicator-pending {
            background: #e1f3ff;
            color: #0078d4;
        }

        .check-list {
            list-style: none;
            margin: 0;
            padding: 0;
        }

        .check-item {
            display: flex;
            align-items: flex-start;
            gap: 6px;
            padding: 4px 0;
            font-size: 12px;
            color: #323130;
            border-bottom: 1px solid #edebe9;
        }

        .check-item:last-child {
            border-bottom: none;
        }

        .check-item code {
            font-size: 11px;
            background: #fff;
            padding: 2px 6px;
            border-radius: 0;
            word-break: break-all;
        }

        .check-item a {
            color: #0078d4;
            text-decoration: none;
        }

        .check-item a:hover {
            text-decoration: underline;
        }

        .check-icon {
            flex-shrink: 0;
            width: 14px;
            text-align: center;
        }

        .check-item.status-indicator-success .check-icon {
            color: #107c10;
        }

        .check-item.status-indicator-error .check-icon {
            color: #d13438;
        }

        .check-item.status-indicator-pending .check-icon {
            color: #0078d4;
        }

        .check-item.status-indicator-expired {
            background-color: rgba(202, 140, 0, 0.1);
        }

        .check-item.status-indicator-not-triggered {
            background-color: rgba(138, 136, 134, 0.1);
        }

        .check-item-note {
            font-size: 12px;
            color: #605e5c;
            font-style: italic;
            padding: 4px 0;
        }

        .check-extra {
            color: #8a6d3b;
            font-size: 11px;
            font-style: italic;
        }

        /* Build status SVG icons */
        .build-status-icon {
            vertical-align: middle;
        }

        .build-status-running {
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            from { transform: rotate(0deg); }
            to { transform: rotate(360deg); }
        }

        .queue-build-btn {
            background: transparent;
            border: none;
            padding: 0;
            margin-left: auto;
            cursor: pointer;
            flex-shrink: 0;
            display: flex;
            align-items: center;
            justify-content: center;
            outline: none;
            -webkit-appearance: none;
            appearance: none;
        }

        .queue-build-btn:hover,
        .queue-build-btn:focus,
        .queue-build-btn:active {
            background: transparent;
            outline: none;
            box-shadow: none;
        }

        .queue-build-btn:hover svg {
            filter: drop-shadow(0 0 3px #0078d4);
        }

        .queue-build-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        /* Right sidebar */
        .right-sidebar {
            width: 300px;
            min-width: 200px;
            max-width: 500px;
            background: #edebe9;
            padding: 20px;
            overflow-y: auto;
            flex-shrink: 0;
            position: relative;
        }

        /* Left-edge resize handle for right sidebar */
        .resize-handle-left {
            position: absolute;
            left: 0;
            top: 0;
            bottom: 0;
            width: 8px;
            cursor: col-resize;
            background: transparent;
            transition: background 0.2s;
        }

        .resize-handle-left:hover {
            background: rgba(0, 120, 212, 0.2);
        }

        /* Vertical stats layout for right sidebar */
        .right-sidebar .stats {
            flex-direction: column;
            gap: 8px;
        }

        .right-sidebar .stat {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 8px 12px;
            background: white;
        }

        .right-sidebar .stat-value {
            font-size: 18px;
            order: 2;
        }

        .right-sidebar .stat-label {
            font-size: 13px;
            order: 1;
        }

        /* PR header in middle column */
        .pr-header {
            background: #f9f8f7;
            padding: 20px;
        }

        /* Description card */
        .description-card {
            border: 1px solid #e1dfdd;
            margin-top: 15px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }

        .description-card-header {
            padding: 10px 15px;
            font-weight: 600;
            font-size: 14px;
            color: #323130;
            background: white;
        }

        .description-card-content {
            padding: 15px;
            background: white;
        }

        .description-card-content .pr-description {
            white-space: pre-wrap;
        }

        /* Right sidebar section styling */
        .right-sidebar-section {
            margin-bottom: 20px;
        }

        .right-sidebar-section:last-child {
            margin-bottom: 0;
        }

        .right-sidebar-section h4 {
            margin: 0 0 10px 0;
            color: #323130;
            font-size: 14px;
            font-weight: 600;
        }

        /* Compact stats (inline) */
        .compact-stats {
            display: flex;
            gap: 12px;
            align-items: center;
            font-size: 14px;
            padding: 8px 12px;
            background: white;
            margin-bottom: 8px;
        }

        .compact-stats:last-child {
            margin-bottom: 0;
        }

        .compact-stats span {
            cursor: default;
        }
    </style>
</head>
<body>
    <div class="container wide">
        <div style="display: flex; justify-content: space-between; align-items: center; margin: 0; padding: 8px 8px; border-radius: 0;">
            <div>
                <h1 style="font-size: 1.3em; margin: 0;">üí¨ PR Threads Viewer</h1>
            </div>
            <div style="display: flex; gap: 10px;">
                <a href="ado-pr-list.html" onclick="const url = sessionStorage.getItem('prListReturnUrl'); if (url) { window.location.href = url; return false; } return true;" style="color: #0078d4; text-decoration: none; font-size: 14px;">üìã PR List</a>
                <a href="index.html" style="color: #0078d4; text-decoration: none; font-size: 14px;">üè† Home</a>
                <a href="ado-settings.html" style="color: #0078d4; text-decoration: none; font-size: 14px;">‚öôÔ∏è Settings</a>
            </div>
        </div>

        <div class="page-layout">
            <!-- Left Sidebar with Filters -->
            <div class="sidebar left-sidebar" id="threadFilters" style="display: none;">
                <div class="resize-handle" id="resizeHandle"></div>
                <h3 style="margin-top: 0; margin-bottom: 20px;">Filters</h3>

                <div class="filter-section">
                    <h4>Thread Status</h4>
                    <div class="status-chips-vertical">
                        <button class="status-chip selected" data-status="active" onclick="toggleStatusChip(this)">Active</button>
                        <button class="status-chip selected" data-status="fixed" onclick="toggleStatusChip(this)">Resolved</button>
                        <button class="status-chip selected" data-status="closed" onclick="toggleStatusChip(this)">Closed</button>
                        <button class="status-chip selected" data-status="wontFix" onclick="toggleStatusChip(this)">Won't Fix</button>
                        <button class="status-chip selected" data-status="pending" onclick="toggleStatusChip(this)">Pending</button>
                        <button class="status-chip" data-status="unknown" onclick="toggleStatusChip(this)">Unknown</button>
                        <button class="status-chip" data-status="noStatus" onclick="toggleStatusChip(this)">No status</button>
                    </div>
                    <label class="checkbox-label">
                        <input type="checkbox" id="showDeleted" onchange="applyThreadFilters()">
                        Show deleted threads
                    </label>
                </div>

                <div class="filter-section">
                    <h4>Thread Author</h4>
                    <select id="threadAuthorFilter" onchange="applyThreadFilters()">
                        <option value="">All authors</option>
                    </select>
                </div>

                <div class="filter-section">
                    <h4>Comments by User</h4>
                    <select id="commentAuthorFilter" onchange="applyThreadFilters()">
                        <option value="">All users</option>
                    </select>
                </div>

                <div class="filter-section">
                    <h4>Search in Comments</h4>
                    <input type="text" id="searchFilter" placeholder="Search text..." oninput="applyThreadFilters()">
                </div>

                <div class="filter-section">
                    <h4>View Options</h4>
                    <button id="viewToggle" onclick="toggleView()" class="btn-secondary" style="width: 100%; margin-bottom: 8px;">
                        Switch to Compact
                    </button>
                    <button id="bulkModeToggle" onclick="toggleBulkMode()" class="btn-secondary" style="width: 100%;">
                        Enable Bulk Selection
                    </button>
                </div>

                <div class="thread-count">
                    Showing <span id="filteredCount">0</span> of <span id="totalCount">0</span> threads
                </div>
            </div>

            <!-- Main Content -->
            <div class="main-content">
                <div id="bulkActions" class="bulk-actions">
                    <strong>Bulk Thread Selection Mode Active</strong>
                    <p style="margin: 10px 0 0 0; font-size: 14px; color: #605e5c;">Select threads using checkboxes, then change their status below. Filters are disabled in bulk mode.</p>
                    <div class="bulk-actions-buttons">
                        <button onclick="selectAllThreads()" class="btn-secondary">Select All</button>
                        <button onclick="deselectAllThreads()" class="btn-secondary">Deselect All</button>
                        <span style="margin-left: 10px; color: #323130;">Selected: <strong id="selectedCount">0</strong> threads</span>
                        <div style="margin-left: auto; display: flex; gap: 10px; align-items: center;">
                            <label for="bulkStatusSelect" style="margin: 0;">Change selected to:</label>
                            <select id="bulkStatusSelect">
                                <option value="">Select status...</option>
                                <option value="active">Active</option>
                                <option value="fixed">Resolved</option>
                                <option value="closed">Closed</option>
                                <option value="wontFix">Won't Fix</option>
                                <option value="pending">Pending</option>
                            </select>
                            <button onclick="applyBulkStatusChange()" class="btn-primary">Apply Changes</button>
                        </div>
                    </div>
                </div>


                <div class="config-section" id="configSection" style="display: none;">
                    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px;">
                        <h3 style="margin: 0;">Configuration</h3>
                    </div>

                    <details id="advancedConfig">
                        <summary style="cursor: pointer; color: #0078d4; font-weight: 600;">üîß Advanced Configuration</summary>
                        <div style="margin-top: 15px;">
                            <div class="form-group">
                                <label for="serverUrl">Azure DevOps Server URL</label>
                                <input type="text" id="serverUrl" placeholder="https://your-ado-server.com" />
                            </div>
                            <div class="form-group">
                                <label for="organization">Organization/Collection</label>
                                <input type="text" id="organization" placeholder="DefaultCollection" />
                            </div>
                            <div class="form-group">
                                <label for="project">Project Name</label>
                                <input type="text" id="project" placeholder="MyProject" />
                            </div>
                            <div class="form-group">
                                <label for="repository">Repository Name</label>
                                <input type="text" id="repository" placeholder="MyRepo" />
                            </div>
                        </div>
                    </details>

                    <button id="loadButton" onclick="loadPRThreads()">Load PR Threads</button>
                    <div id="configStatus" style="margin-top: 10px; font-size: 12px; color: #605e5c;"></div>
                </div>

                <div class="results-container">
                    <div id="results"></div>
                </div>
            </div>

            <!-- Right Sidebar with Stats, Reviewers, Checks -->
            <div class="sidebar right-sidebar" id="rightSidebar" style="display: none;">
                <div class="resize-handle resize-handle-left" id="resizeHandleRight"></div>
                <div id="rightSidebarStats" class="right-sidebar-section"></div>
                <div id="rightSidebarReviewers" class="right-sidebar-section"></div>
                <div id="rightSidebarChecks" class="right-sidebar-section"></div>
            </div>
        </div>
    </div>

    <script src="common.js"></script>
    <script src="diff.js"></script>
    <script>
        let currentPRId = null;
        let allThreads = [];
        let allIterations = [];
        let currentPRData = null;
        let currentConfig = null;
        let currentFileChangeStats = null;
        let isCompactView = false;
        let isBulkMode = false;
        let selectedThreadIds = new Set();
        let isRestoringFromURL = false;
        let urlProject = null;  // Saved from initial URL
        let urlRepo = null;     // Saved from initial URL

        // Cache for iteration changes and file path history
        let iterationChangesCache = new Map(); // iterationId ‚Üí changes array
        let filePathHistoryCache = new Map();  // filePath ‚Üí Map<iterationId, pathAtIteration>

        /**
         * Get changes for an iteration (cached)
         */
        async function getIterationChanges(iterationId) {
            if (iterationChangesCache.has(iterationId)) {
                return iterationChangesCache.get(iterationId);
            }
            try {
                const data = await ADOAPI.getPRIterationChanges(currentConfig, currentPRId, iterationId);
                const changes = data.changeEntries || [];
                iterationChangesCache.set(iterationId, changes);
                return changes;
            } catch (e) {
                console.warn(`Failed to fetch changes for iteration ${iterationId}:`, e);
                iterationChangesCache.set(iterationId, []);
                return [];
            }
        }

        /**
         * Build file path history across iterations
         * Returns Map<iterationId, filePath> showing path at each iteration
         */
        async function buildFilePathHistory(filePath, knownIterationId) {
            // Check cache first
            const cacheKey = `${filePath}@${knownIterationId}`;
            if (filePathHistoryCache.has(cacheKey)) {
                return filePathHistoryCache.get(cacheKey);
            }

            const sortedIterations = [...allIterations].sort((a, b) => a.id - b.id);
            const pathHistory = new Map();

            // Find index of known iteration
            const knownIndex = sortedIterations.findIndex(it => it.id === knownIterationId);
            if (knownIndex === -1) {
                // Fallback: use same path for all
                for (const it of sortedIterations) {
                    pathHistory.set(it.id, filePath);
                }
                filePathHistoryCache.set(cacheKey, pathHistory);
                return pathHistory;
            }

            // Set known iteration path
            pathHistory.set(knownIterationId, filePath);

            // Walk backwards from known iteration to first
            let currentPath = filePath;
            for (let i = knownIndex; i >= 0; i--) {
                const iteration = sortedIterations[i];
                const changes = await getIterationChanges(iteration.id);

                // Check if file was renamed TO currentPath in this iteration
                for (const change of changes) {
                    const changeType = change.changeType || '';
                    if (changeType.includes('rename') && change.item?.path === currentPath && change.sourceServerItem) {
                        // Before this iteration, file was at sourceServerItem
                        currentPath = change.sourceServerItem;
                        break;
                    }
                }
                pathHistory.set(iteration.id, currentPath);
            }

            // Walk forwards from known iteration to last
            currentPath = filePath;
            for (let i = knownIndex + 1; i < sortedIterations.length; i++) {
                const iteration = sortedIterations[i];
                const changes = await getIterationChanges(iteration.id);

                // Check if file was renamed FROM currentPath in this iteration
                for (const change of changes) {
                    const changeType = change.changeType || '';
                    if (changeType.includes('rename') && change.sourceServerItem === currentPath && change.item?.path) {
                        // After this iteration, file is at item.path
                        currentPath = change.item.path;
                        break;
                    }
                }
                pathHistory.set(iteration.id, currentPath);
            }

            // Cache under all path+iteration combinations for lookup from any path
            for (const [iterationId, pathAtIteration] of pathHistory) {
                const altCacheKey = `${pathAtIteration}@${iterationId}`;
                if (!filePathHistoryCache.has(altCacheKey)) {
                    filePathHistoryCache.set(altCacheKey, pathHistory);
                }
            }

            return pathHistory;
        }

        /**
         * Get file path at a specific iteration
         */
        async function getFilePathAtIteration(filePath, knownIterationId, targetIterationId) {
            const history = await buildFilePathHistory(filePath, knownIterationId);
            return history.get(targetIterationId) || filePath;
        }

        function calculateFileChangeStats(changeEntries) {
            const stats = {
                totalFiles: 0,
                added: 0,
                modified: 0,
                deleted: 0,
                renamed: 0
            };

            changeEntries.forEach(entry => {
                stats.totalFiles++;
                const changeType = entry.changeType;
                // changeType can be: add, edit, delete, rename, etc.
                // It can also be a combination like "edit, rename"
                if (changeType.includes('add')) {
                    stats.added++;
                } else if (changeType.includes('delete')) {
                    stats.deleted++;
                } else if (changeType.includes('rename') && !changeType.includes('edit')) {
                    stats.renamed++;
                } else if (changeType.includes('edit')) {
                    stats.modified++;
                }
            });

            return stats;
        }

        function getLineStatsCacheKey(config, prId, iterationCount) {
            return `line-stats-${config.organization}-${config.project}-${config.repository}-${prId}-${iterationCount}`;
        }

        function getCachedLineStats(cacheKey) {
            try {
                const cached = localStorage.getItem(cacheKey);
                if (cached) {
                    return JSON.parse(cached);
                }
            } catch (e) {
                console.warn('Failed to read line stats cache:', e);
            }
            return null;
        }

        function setCachedLineStats(cacheKey, stats) {
            try {
                localStorage.setItem(cacheKey, JSON.stringify(stats));
            } catch (e) {
                console.warn('Failed to cache line stats:', e);
            }
        }

        function computeLineDiff(oldContent, newContent) {
            // Use histogram diff for accurate line stats
            return HistogramDiff.stats(oldContent, newContent);
        }

        async function fetchFileContent(config, path, commitId) {
            try {
                const url = `${config.serverUrl}/${config.organization}/${config.project}/_apis/git/repositories/${config.repository}/items?path=${encodeURIComponent(path)}&versionDescriptor.version=${commitId}&versionDescriptor.versionType=commit&api-version=6.0`;
                const response = await fetch(url, {
                    headers: { 'Authorization': `Basic ${btoa(':' + config.pat)}` }
                });
                if (!response.ok) return null;
                return await response.text();
            } catch (e) {
                return null;
            }
        }

        async function fetchLineStatsViaInternalAPI(config, prData, changes) {
            const baseCommit = prData.lastMergeTargetCommit?.commitId;
            const targetCommit = prData.lastMergeSourceCommit?.commitId;
            const repositoryId = prData.repository?.id;

            if (!baseCommit || !targetCommit || !repositoryId) {
                return null;
            }

            // Get file paths from changes
            const filePaths = changes
                .filter(e => e.item?.path)
                .map(e => e.item.path);

            if (filePaths.length === 0) {
                return { added: 0, removed: 0 };
            }

            // Call internal API
            const diffData = await ADOAPI.getFileDiffs(config, repositoryId, baseCommit, targetCommit, filePaths);
            console.log('Internal API response:', diffData);

            // Parse response and sum line counts
            let added = 0, removed = 0;
            const fileDiffs = diffData?.dataProviders?.['ms.vss-code-web.file-diff-data-provider']?.fileDiffs || [];

            for (const fileDiff of fileDiffs) {
                for (const block of (fileDiff.lineDiffBlocks || [])) {
                    const changeType = block.changeType;
                    // changeType: 0 = none, 1 = add, 2 = delete, 3 = edit (need to verify)
                    if (changeType === 1) {
                        added += block.modifiedLinesCount || 0;
                    } else if (changeType === 2) {
                        removed += block.originalLinesCount || 0;
                    } else if (changeType === 3) {
                        // For edits, count both sides
                        added += block.modifiedLinesCount || 0;
                        removed += block.originalLinesCount || 0;
                    }
                }
            }

            return { added, removed };
        }

        async function fetchLineStatsViaLocalDiff(config, prData, changes) {
            const baseCommit = prData.lastMergeTargetCommit?.commitId;
            const targetCommit = prData.lastMergeSourceCommit?.commitId;

            let totalAdded = 0;
            let totalRemoved = 0;

            // Process files
            for (const change of changes) {
                const newPath = change.item?.path;
                if (!newPath) continue;

                const changeType = change.changeType || '';
                // For renames, sourceServerItem contains the old path
                const oldPath = change.sourceServerItem || newPath;

                if (changeType.includes('add')) {
                    const content = await fetchFileContent(config, newPath, targetCommit);
                    if (content) {
                        totalAdded += content.split('\n').length;
                    }
                } else if (changeType.includes('delete')) {
                    const content = await fetchFileContent(config, oldPath, baseCommit);
                    if (content) {
                        totalRemoved += content.split('\n').length;
                    }
                } else if (changeType.includes('edit') || changeType.includes('rename')) {
                    const [oldContent, newContent] = await Promise.all([
                        fetchFileContent(config, oldPath, baseCommit),
                        fetchFileContent(config, newPath, targetCommit)
                    ]);
                    const diff = computeLineDiff(oldContent, newContent);
                    totalAdded += diff.added;
                    totalRemoved += diff.removed;
                }
            }

            return { added: totalAdded, removed: totalRemoved };
        }

        async function fetchLineStatsAsync(config, prData) {
            const iterationCount = allIterations.length;
            const cacheKey = getLineStatsCacheKey(config, prData.pullRequestId, iterationCount);

            // Check cache first (validate that values are numbers, not null)
            const cached = getCachedLineStats(cacheKey);
            if (cached && typeof cached.added === 'number' && typeof cached.removed === 'number') {
                console.log('Line stats from cache:', cached);
                updateLineStatsDisplay(cached.added, cached.removed);
                return;
            }

            // Need to compute - show loading
            updateLineStatsLoading();

            try {
                const baseCommit = prData.lastMergeTargetCommit?.commitId;
                const targetCommit = prData.lastMergeSourceCommit?.commitId;

                if (!baseCommit || !targetCommit) {
                    hideLineStatsLoading();
                    return;
                }

                // Get the file changes from iteration 1
                const changesData = await ADOAPI.getPRIterationChanges(config, prData.pullRequestId, 1);
                const changes = changesData.changeEntries || [];

                if (changes.length === 0) {
                    updateLineStatsDisplay(0, 0);
                    return;
                }

                let stats = null;

                // Try internal API first
                try {
                    stats = await fetchLineStatsViaInternalAPI(config, prData, changes);
                    if (stats) {
                        console.log('Line stats via internal API:', stats);
                    }
                } catch (e) {
                    console.warn('Internal API failed, falling back to local diff:', e);
                }

                // Fall back to local diff if internal API failed
                if (!stats) {
                    console.log('Using local diff computation...');
                    stats = await fetchLineStatsViaLocalDiff(config, prData, changes);
                    console.log('Line stats via local diff:', stats);
                }

                setCachedLineStats(cacheKey, stats);
                updateLineStatsDisplay(stats.added, stats.removed);

            } catch (e) {
                console.warn('Failed to compute line stats:', e);
                hideLineStatsLoading();
            }
        }

        function hideLineStatsLoading() {
            const container = document.getElementById('lineStatsContainer');
            if (container) {
                container.innerHTML = '';
            }
        }

        function updateLineStatsLoading() {
            const container = document.getElementById('lineStatsContainer');
            if (!container) return;
            container.innerHTML = `
                <span>Lines</span>
                <span style="color: #605e5c;">‚è≥</span>
            `;
        }

        function updateLineStatsDisplay(added, removed) {
            const container = document.getElementById('lineStatsContainer');
            if (!container) return;

            container.innerHTML = `
                <span>Lines</span>
                <strong style="color: #107c10;" title="Added">+${added}</strong>
                <strong style="color: #a4262c;" title="Removed">-${removed}</strong>
            `;
        }

        function getActiveThreadCounts(threads) {
            const counts = {};
            threads.forEach(thread => {
                if (thread.isDeleted) return;
                const status = thread.status;
                if (status === 'active' || status === 'Active' || status === 1) {
                    const firstComment = thread.comments && thread.comments[0];
                    const commentType = firstComment?.commentType;
                    // Only count threads with real comments (text type)
                    const isRealComment = commentType === 1 || commentType === 'text';
                    const authorId = firstComment?.author?.id;
                    if (authorId && isRealComment) {
                        counts[authorId] = (counts[authorId] || 0) + 1;
                    }
                }
            });
            return counts;
        }

        function renderAvatarWithBadges(user, vote, threadCount, isPRAuthor = false) {
            const initials = user.displayName.split(' ').map(n => n[0]).join('').substring(0, 2).toUpperCase();
            const displayName = ADOContent.escapeHtml(user.displayName);

            // Vote info
            let voteClass = '';
            let voteText = '';
            let voteIcon = '';
            if (vote !== undefined) {
                switch (vote) {
                    case 10:
                        voteClass = 'vote-approved';
                        voteText = 'Approved';
                        voteIcon = '‚úì';
                        break;
                    case 5:
                        voteClass = 'vote-approved-suggestions';
                        voteText = 'Approved with suggestions';
                        voteIcon = '‚úì';
                        break;
                    case -5:
                        voteClass = 'vote-wait';
                        voteText = 'Waiting for author';
                        voteIcon = '!';
                        break;
                    case -10:
                        voteClass = 'vote-rejected';
                        voteText = 'Rejected';
                        voteIcon = '‚úó';
                        break;
                    default:
                        voteClass = 'vote-no-vote';
                        voteText = 'No vote';
                }
            }

            const title = vote !== undefined ? `${displayName} - ${voteText}` : displayName;

            let avatarHtml;
            if (user.id) {
                const cachedUrl = AvatarLoader.getCached(user.id);
                if (cachedUrl) {
                    avatarHtml = `<img src="${cachedUrl}" alt="${title}" title="${title}" class="avatar">`;
                } else {
                    avatarHtml = `<div class="avatar-placeholder" title="${title}"></div><img data-user-id="${user.id}" alt="${title}" title="${title}" class="avatar avatar-pending">`;
                }
            } else {
                avatarHtml = `<div class="avatar-fallback" title="${title}">${initials}</div>`;
            }

            // Vote badge (bottom-left)
            let voteBadgeHtml = '';
            if (voteIcon) {
                voteBadgeHtml = `<span class="vote-badge ${voteClass}">${voteIcon}</span>`;
            }

            // Thread count badge (top-right)
            let threadBadgeHtml = '';
            if (threadCount && threadCount > 0) {
                threadBadgeHtml = `<span class="thread-badge" title="${threadCount} active thread${threadCount > 1 ? 's' : ''}">${threadCount}</span>`;
            }

            // PR Author badge (top-left)
            let authorBadgeHtml = '';
            if (isPRAuthor) {
                authorBadgeHtml = `<span class="author-badge" title="PR Author"><svg viewBox="0 0 24 24"><path d="M12 2l3.09 6.26L22 9.27l-5 4.87 1.18 6.88L12 17.77l-6.18 3.25L7 14.14 2 9.27l6.91-1.01L12 2z" fill="#323130"/></svg></span>`;
            }

            return `<div class="avatar-wrapper" data-user-id="${user.id || ''}">${avatarHtml}${voteBadgeHtml}${threadBadgeHtml}${authorBadgeHtml}</div>`;
        }

        function renderReviewersSection(reviewers, threadCounts, prAuthorId) {
            if (!reviewers || reviewers.length === 0) {
                return '';
            }

            // Separate required and optional reviewers
            const requiredReviewers = reviewers.filter(r => r.isRequired);
            const optionalReviewers = reviewers.filter(r => !r.isRequired);

            let html = '';

            if (requiredReviewers.length > 0) {
                const requiredAvatarsHtml = requiredReviewers.map(r => {
                    const count = threadCounts[r.id] || 0;
                    return renderAvatarWithBadges(r, r.vote, count, r.id === prAuthorId);
                }).join('');

                html += `
                    <div class="avatars-section">
                        <h4>Required Reviewers</h4>
                        <div class="avatars-container">${requiredAvatarsHtml}</div>
                    </div>
                `;
            }

            if (optionalReviewers.length > 0) {
                const optionalAvatarsHtml = optionalReviewers.map(r => {
                    const count = threadCounts[r.id] || 0;
                    return renderAvatarWithBadges(r, r.vote, count, r.id === prAuthorId);
                }).join('');

                html += `
                    <div class="avatars-section">
                        <h4>Optional Reviewers</h4>
                        <div class="avatars-container">${optionalAvatarsHtml}</div>
                    </div>
                `;
            }

            return html;
        }

        function renderOtherAuthorsSection(threads, reviewers, threadCounts, prAuthorId) {
            // Get all unique thread authors who are not reviewers
            // Only include authors with at least one "real" comment (not system/codeChange)
            const reviewerIds = new Set((reviewers || []).map(r => r.id));
            const otherAuthors = new Map();

            threads.forEach(thread => {
                if (thread.isDeleted) return;
                const firstComment = thread.comments && thread.comments[0];
                const author = firstComment?.author;
                const commentType = firstComment?.commentType;

                // Skip system (3/'system') and codeChange (2/'codeChange') comments
                const isRealComment = commentType === 1 || commentType === 'text';

                if (author && author.id && isRealComment && !reviewerIds.has(author.id) && !otherAuthors.has(author.id)) {
                    otherAuthors.set(author.id, author);
                }
            });

            if (otherAuthors.size === 0) {
                return '';
            }

            const avatarsHtml = Array.from(otherAuthors.values()).map(author => {
                const count = threadCounts[author.id] || 0;
                return renderAvatarWithBadges(author, undefined, count, author.id === prAuthorId);
            }).join('');

            return `
                <div class="avatars-section">
                    <h4>Other Thread Authors</h4>
                    <div class="avatars-container">${avatarsHtml}</div>
                </div>
            `;
        }

        // Checks (statuses, policies, conflicts) caching and polling
        let prChecksData = null;
        let checksPollingInterval = null;
        const CHECKS_POLL_INTERVAL = 15000; // 15 seconds

        async function fetchPRChecks(config, prData) {
            const projectId = prData.repository?.project?.id || config.project;
            prChecksData = await ChecksFormatter.fetchPRChecks(
                config,
                config.project,
                config.repository,
                prData.pullRequestId,
                projectId,
                prData.mergeStatus
            );
            updateChecksDisplay();
        }

        function startChecksPolling(config, prData) {
            if (checksPollingInterval) return; // Already polling

            checksPollingInterval = setInterval(async () => {
                if (document.hidden) return; // Don't poll if tab is hidden
                await fetchPRChecks(config, prData);
            }, CHECKS_POLL_INTERVAL);
        }

        function stopChecksPolling() {
            if (checksPollingInterval) {
                clearInterval(checksPollingInterval);
                checksPollingInterval = null;
            }
        }

        // Refresh checks when tab becomes visible
        document.addEventListener('visibilitychange', () => {
            if (!document.hidden && currentPRData) {
                const config = ADOConfig.get();
                if (config) fetchPRChecks(config, currentPRData);
            }
        });

        // Cleanup on page unload
        window.addEventListener('beforeunload', stopChecksPolling);

        function updateChecksDisplay() {
            const container = document.getElementById('rightSidebarChecks');
            if (!container) return;

            container.innerHTML = renderChecksSection();

            // Attach click handlers for queue build buttons
            container.querySelectorAll('.queue-build-btn').forEach(btn => {
                btn.addEventListener('click', async (e) => {
                    const evaluationId = btn.dataset.evaluationId;
                    if (!evaluationId || !currentPRData) return;

                    btn.disabled = true;
                    btn.textContent = '‚è≥';

                    try {
                        const config = ADOConfig.get();
                        await ADOAPI.requeuePolicyEvaluation(config, config.project, evaluationId);

                        // Refresh checks after queueing
                        await fetchPRChecks(config, currentPRData);
                    } catch (err) {
                        alert(`Failed to queue build: ${err.message}`);
                        btn.disabled = false;
                        btn.textContent = '‚ñ∂';
                    }
                });
            });
        }

        // Use shared utilities from common.js
        const getStatusIcon = ChecksFormatter.getIcon.bind(ChecksFormatter);
        const getStatusClass = ChecksFormatter.getClass.bind(ChecksFormatter);

        function renderChecksSection() {
            if (!prChecksData) {
                return `
                    <div class="checks-section">
                        <h4>Checks</h4>
                        <div class="checks-loading">Loading...</div>
                    </div>
                `;
            }

            const sections = [];
            const { statuses, policies, conflicts, mergeStatus } = prChecksData;

            // Merge conflicts section
            if (mergeStatus === 'conflicts') {
                let conflictHtml = '<div class="check-group"><div class="check-group-header status-indicator-error">‚ö†Ô∏è Merge Conflicts</div>';
                if (conflicts.length > 0) {
                    conflictHtml += '<ul class="check-list">';
                    conflicts.forEach(c => {
                        const path = c.conflictPath || c.filePath || c.sourceFilePath || c.targetFilePath || c.path || 'Unknown file';
                        conflictHtml += `<li class="check-item"><code>${ADOContent.escapeHtml(path)}</code></li>`;
                    });
                    conflictHtml += '</ul>';
                } else {
                    conflictHtml += '<div class="check-item-note">Unable to load conflict details</div>';
                }
                conflictHtml += '</div>';
                sections.push(conflictHtml);
            } else if (mergeStatus && mergeStatus !== 'succeeded' && mergeStatus !== 'notSet') {
                // Other merge issues
                let mergeText = '';
                switch (mergeStatus) {
                    case 'rejectedByPolicy': mergeText = 'üö´ Rejected by policy'; break;
                    case 'queued': mergeText = '‚è≥ Merge queued'; break;
                    case 'failure': mergeText = '‚ùå Merge failed'; break;
                }
                if (mergeText) {
                    sections.push(`<div class="check-group"><div class="check-group-header ${getStatusClass(mergeStatus)}">${mergeText}</div></div>`);
                }
            }

            // Status checks section - use improved deduplication from common.js
            const statusList = ChecksFormatter.getLatestStatuses(statuses);
            if (statusList.length > 0) {
                const failed = statusList.filter(s => s.state === 'failed' || s.state === 'error');
                const pending = statusList.filter(s => s.state === 'pending' || !s.state);
                const succeeded = statusList.filter(s => s.state === 'succeeded');

                let checksHtml = '<div class="check-group"><div class="check-group-header">üìä Status Checks</div><ul class="check-list">';

                // Show failed first, then pending, then succeeded
                [...failed, ...pending, ...succeeded].forEach(s => {
                    const info = ChecksFormatter.formatStatus(s);
                    const icon = getStatusIcon(s.state || 'pending');
                    const cls = getStatusClass(s.state || 'pending');
                    const desc = s.description ? ` - ${ADOContent.escapeHtml(s.description)}` : '';

                    if (info.url) {
                        checksHtml += `<li class="check-item ${cls}"><span class="check-icon">${icon}</span> <a href="${ADOContent.escapeHtml(info.url)}" target="_blank" rel="noopener">${ADOContent.escapeHtml(info.name)}</a>${desc}</li>`;
                    } else {
                        checksHtml += `<li class="check-item ${cls}"><span class="check-icon">${icon}</span> ${ADOContent.escapeHtml(info.name)}${desc}</li>`;
                    }
                });

                checksHtml += '</ul></div>';
                sections.push(checksHtml);
            }

            // Build policies section - separate with SVG icons
            const buildPolicies = policies.filter(p => ChecksFormatter.isBuildPolicy(p));
            if (buildPolicies.length > 0) {
                // Sort by state: failed, expired, notTriggered, running, queued, succeeded
                const stateOrder = { failed: 0, expired: 1, notTriggered: 2, running: 3, queued: 4, succeeded: 5 };
                const sorted = buildPolicies.sort((a, b) => {
                    const stateA = ChecksFormatter.getBuildState(a);
                    const stateB = ChecksFormatter.getBuildState(b);
                    return (stateOrder[stateA] ?? 5) - (stateOrder[stateB] ?? 5);
                });

                let buildHtml = '<div class="check-group"><div class="check-group-header">üîß Builds</div><ul class="check-list">';

                sorted.forEach(p => {
                    const state = ChecksFormatter.getBuildState(p);
                    const icon = ChecksFormatter.getBuildStatusSvg(state, 14);
                    const stateClasses = { expired: 'status-indicator-expired', notTriggered: 'status-indicator-not-triggered' };
                    const cls = stateClasses[state] || getStatusClass(p.status);
                    const { label, extra } = ChecksFormatter.formatPolicy(p);
                    const extraHtml = extra ? ` <span class="check-extra">${extra}</span>` : '';

                    // Queue button for builds that can be queued/requeued
                    const canQueue = ['notTriggered', 'failed', 'succeeded', 'expired'].includes(state);
                    const evaluationId = p.evaluationId;
                    let queueBtn = '';
                    if (canQueue && evaluationId) {
                        const tooltip = state === 'notTriggered' ? 'Queue build' : 'Requeue build';
                        queueBtn = `<button class="queue-build-btn" data-evaluation-id="${evaluationId}" title="${tooltip}"><svg height="16" viewBox="0 0 32 32" width="16"><circle cx="16" cy="16" r="16" fill="#0078d4"/><path d="M12 9v14l12-7z" fill="#fff"/></svg></button>`;
                    }

                    buildHtml += `<li class="check-item ${cls}"><span class="check-icon">${icon}</span> ${ADOContent.escapeHtml(label)}${extraHtml}${queueBtn}</li>`;
                });

                buildHtml += '</ul></div>';
                sections.push(buildHtml);
            }

            // Non-build policy evaluations section
            const nonBuildPolicies = policies.filter(p => !ChecksFormatter.isBuildPolicy(p));
            if (nonBuildPolicies.length > 0) {
                const rejected = nonBuildPolicies.filter(e => e.status === 'rejected');
                const running = nonBuildPolicies.filter(e => e.status === 'running' || e.status === 'queued');
                const approved = nonBuildPolicies.filter(e => e.status === 'approved');

                let policyHtml = '<div class="check-group"><div class="check-group-header">üìã Policies</div><ul class="check-list">';

                // Show rejected first, then running, then approved
                [...rejected, ...running, ...approved].forEach(p => {
                    const icon = getStatusIcon(p.status);
                    const cls = getStatusClass(p.status);
                    const { label, extra } = ChecksFormatter.formatPolicy(p);
                    const extraHtml = extra ? ` <span class="check-extra">${extra}</span>` : '';

                    policyHtml += `<li class="check-item ${cls}"><span class="check-icon">${icon}</span> ${ADOContent.escapeHtml(label)}${extraHtml}</li>`;
                });

                policyHtml += '</ul></div>';
                sections.push(policyHtml);
            }

            if (sections.length === 0) {
                return '';
            }

            return `
                <div class="checks-section">
                    <h4>Checks</h4>
                    ${sections.join('')}
                </div>
            `;
        }

        // Parse URL parameters on load
        window.addEventListener('DOMContentLoaded', () => {
            const urlParams = ADOURL.getParams();
            currentPRId = urlParams.get('prId') || urlParams.get('id');
            urlProject = urlParams.get('project');
            urlRepo = urlParams.get('repo');

            // Load saved configuration from localStorage
            const savedConfig = ADOConfig.get();
            if (savedConfig) {
                document.getElementById('serverUrl').value = savedConfig.serverUrl || '';
                document.getElementById('organization').value = savedConfig.organization || '';
                // Use URL params if provided, otherwise fall back to saved config
                document.getElementById('project').value = urlProject || savedConfig.project || '';
                document.getElementById('repository').value = urlRepo || savedConfig.repository || '';
            }

            // Auto-load or show config
            if (currentPRId) {
                // Auto-load if config is valid (repo can come from URL or saved config)
                const hasRepo = urlRepo || (savedConfig && savedConfig.repository);
                if (savedConfig && ADOConfig.isValid(savedConfig) && hasRepo) {
                    setTimeout(() => loadPRThreads(), 100);
                } else {
                    // Show config section if settings are missing
                    document.getElementById('configSection').style.display = 'block';
                    const statusDiv = document.getElementById('configStatus');
                    statusDiv.innerHTML = '‚ö†Ô∏è Some settings are missing. <a href="ado-settings.html" style="color: #0078d4;">Configure in Settings</a> or use Advanced Configuration below.';
                    statusDiv.style.color = '#8a6d3b';
                }
            } else {
                showNoPRError();
            }
        });

        function showNoPRError() {
            document.getElementById('results').innerHTML = `
                <div class="warning">
                    <strong>‚ö†Ô∏è No Pull Request specified</strong><br>
                    Please navigate from the <a href="ado-pr-list.html" style="color: #0078d4; font-weight: 600;">PR List page</a>
                    or provide a PR ID in the URL (e.g., ?prId=123).
                </div>
            `;
        }

        // URL parameter helpers
        function getURLParams() {
            const params = new URLSearchParams(window.location.search);
            const statusParam = params.get('status');
            return {
                prId: params.get('prId') || params.get('id') || null,
                status: statusParam ? (statusParam === 'none' ? [] : statusParam.split(',')) : null,
                showDeleted: params.get('showDeleted') !== null ? params.get('showDeleted') === 'true' : null,
                author: params.get('author') || null,
                commentAuthor: params.get('commentAuthor') || null,
                search: params.get('search') || null,
                view: params.get('view') || null
            };
        }

        function updateURL() {
            if (isRestoringFromURL) return;

            const params = new URLSearchParams();

            // PR ID
            if (currentPRId) {
                params.set('prId', currentPRId);
            }

            // Preserve project and repo from original URL
            if (urlProject) params.set('project', urlProject);
            if (urlRepo) params.set('repo', urlRepo);

            // Thread status filters
            // Always include status parameter to preserve chip selection state (even if none selected)
            const selectedStatuses = getSelectedThreadStatuses();
            params.set('status', selectedStatuses.length > 0 ? selectedStatuses.join(',') : 'none');

            // Show deleted checkbox
            const showDeleted = document.getElementById('showDeleted').checked;
            if (showDeleted) {  // Only add to URL if checked (default is unchecked)
                params.set('showDeleted', 'true');
            }

            // Author filter
            const author = document.getElementById('threadAuthorFilter').value;
            if (author) {
                params.set('author', author);
            }

            // Comment author filter
            const commentAuthor = document.getElementById('commentAuthorFilter').value;
            if (commentAuthor) {
                params.set('commentAuthor', commentAuthor);
            }

            // Search filter
            const search = document.getElementById('searchFilter').value.trim();
            if (search) {
                params.set('search', search);
            }

            // View mode
            if (isCompactView) {  // Only add to URL if compact (default is detailed)
                params.set('view', 'compact');
            }

            const newURL = params.toString() ? `${window.location.pathname}?${params.toString()}` : window.location.pathname;
            history.replaceState(null, '', newURL);
        }

        function restoreFiltersFromURL() {
            const urlParams = getURLParams();
            isRestoringFromURL = true;

            try {
                // Restore status chips
                // If status param exists in URL (even if empty/none), restore that selection
                // If status param is missing, keep HTML defaults
                if (urlParams.status !== null) {
                    // First deselect all status chips
                    document.querySelectorAll('.sidebar .status-chip').forEach(chip => {
                        chip.classList.remove('selected');
                    });

                    // Then select only the ones in the URL (if any)
                    urlParams.status.forEach(status => {
                        const chip = document.querySelector(`.sidebar .status-chip[data-status="${status}"]`);
                        if (chip) {
                            chip.classList.add('selected');
                        }
                    });
                }

                // Restore showDeleted checkbox
                if (urlParams.showDeleted !== null) {
                    document.getElementById('showDeleted').checked = urlParams.showDeleted;
                }

                // Restore author filter
                if (urlParams.author) {
                    const authorSelect = document.getElementById('threadAuthorFilter');
                    // Check if the option exists (it might not be populated yet)
                    const option = Array.from(authorSelect.options).find(opt => opt.value === urlParams.author);
                    if (option) {
                        authorSelect.value = urlParams.author;
                    }
                }

                // Restore comment author filter
                if (urlParams.commentAuthor) {
                    const commentAuthorSelect = document.getElementById('commentAuthorFilter');
                    const option = Array.from(commentAuthorSelect.options).find(opt => opt.value === urlParams.commentAuthor);
                    if (option) {
                        commentAuthorSelect.value = urlParams.commentAuthor;
                    }
                }

                // Restore search filter
                if (urlParams.search) {
                    document.getElementById('searchFilter').value = urlParams.search;
                }

                // Restore view mode
                if (urlParams.view === 'compact' && !isCompactView) {
                    toggleView();
                }
            } finally {
                isRestoringFromURL = false;
            }

            // Apply filters to show the filtered results
            applyThreadFilters();
        }

        async function loadPRThreads() {
            const savedConfig = ADOConfig.get() || {};
            const formConfig = ADOConfig.getFromForm({});
            const urlParams = ADOURL.getParams();

            // Priority: URL params > form values > saved config
            const config = {
                serverUrl: formConfig.serverUrl || savedConfig.serverUrl,
                organization: formConfig.organization || savedConfig.organization,
                project: urlParams.get('project') || formConfig.project || savedConfig.project,
                repository: urlParams.get('repo') || formConfig.repository || savedConfig.repository,
                pat: savedConfig.pat
            };

            // Validation
            if (!currentPRId) {
                showNoPRError();
                return;
            }

            if (!ADOConfig.isValid(config) || !config.repository) {
                ADOUI.showError('results', 'Please fill in all fields. PAT must be configured in <a href="ado-settings.html" style="color: #0078d4;">Settings</a>.');
                document.getElementById('configSection').style.display = 'block';
                return;
            }

            // Save configuration (only base settings, not project/repo which may come from URL)
            ADOConfig.save({
                serverUrl: config.serverUrl,
                organization: config.organization,
                pat: config.pat,
                project: savedConfig.project || config.project,
                repository: savedConfig.repository || config.repository
            });

            ADOUI.showLoading('results', 'Loading PR threads...');

            // Reset checks data for new PR
            prChecksData = null;

            try {
                // Clear caches for new PR
                iterationChangesCache.clear();
                filePathHistoryCache.clear();

                // Fetch PR details, threads, and iterations in parallel
                const [prData, threadsData, iterationsData] = await Promise.all([
                    ADOAPI.getPR(config, currentPRId),
                    ADOAPI.getPRThreads(config, currentPRId),
                    ADOAPI.getPRIterations(config, currentPRId)
                ]);

                allThreads = threadsData.value || [];
                allIterations = iterationsData.value || [];
                currentPRData = prData;
                currentConfig = config;

                // Fetch file change stats from the first iteration (shows all changes from base)
                let fileChangeStats = null;
                if (allIterations.length > 0) {
                    try {
                        const changesData = await ADOAPI.getPRIterationChanges(config, currentPRId, 1);
                        fileChangeStats = calculateFileChangeStats(changesData.changeEntries || []);
                    } catch (e) {
                        console.warn('Failed to fetch file change stats:', e);
                    }
                }
                currentFileChangeStats = fileChangeStats;

                // Debug: Log unique status values found in threads
                const uniqueStatuses = new Set(allThreads.map(t => t.status));
                console.log('Loaded threads. Unique status values found:', Array.from(uniqueStatuses));
                console.log('Sample threads with their statuses:', allThreads.slice(0, 5).map(t => ({ id: t.id, status: t.status })));

                // Collect and resolve identities
                await ADOIdentity.collectAndResolveFromThreads(allThreads, config.serverUrl, config.organization, config.pat);

                // Show filters
                document.getElementById('threadFilters').style.display = 'block';

                // Populate author filter
                populateAuthorFilter();

                // Restore filters from URL (if any) and apply
                restoreFiltersFromURL();

            } catch (error) {
                ADOUI.showError('results', error.message);
            }
        }

        function populateAuthorFilter() {
            const threadAuthorFilter = document.getElementById('threadAuthorFilter');
            const commentAuthorFilter = document.getElementById('commentAuthorFilter');
            const threadAuthors = new Set();
            const allCommentAuthors = new Set();

            allThreads.forEach(thread => {
                if (thread.comments && thread.comments.length > 0) {
                    // Collect first comment authors for thread author filter
                    const firstComment = thread.comments[0];
                    if (firstComment.author && firstComment.author.displayName) {
                        threadAuthors.add(firstComment.author.displayName);
                    }

                    // Collect all comment authors for comment author filter
                    thread.comments.forEach(comment => {
                        if (comment.author && comment.author.displayName) {
                            allCommentAuthors.add(comment.author.displayName);
                        }
                    });
                }
            });

            // Populate thread author filter
            let threadAuthorHtml = '<option value="">All authors</option>';
            Array.from(threadAuthors).sort().forEach(author => {
                threadAuthorHtml += `<option value="${ADOContent.escapeHtml(author)}">${ADOContent.escapeHtml(author)}</option>`;
            });
            threadAuthorFilter.innerHTML = threadAuthorHtml;

            // Populate comment author filter
            let commentAuthorHtml = '<option value="">All users</option>';
            Array.from(allCommentAuthors).sort().forEach(author => {
                commentAuthorHtml += `<option value="${ADOContent.escapeHtml(author)}">${ADOContent.escapeHtml(author)}</option>`;
            });
            commentAuthorFilter.innerHTML = commentAuthorHtml;
        }

        function applyThreadFilters() {
            const showDeleted = document.getElementById('showDeleted').checked;
            const selectedStatuses = getSelectedThreadStatuses();
            const selectedAuthor = document.getElementById('threadAuthorFilter').value;
            const selectedCommentAuthor = document.getElementById('commentAuthorFilter').value;
            const searchText = document.getElementById('searchFilter').value.trim();

            const filtered = allThreads.filter(thread => {
                // Deleted filter
                if (!showDeleted && thread.isDeleted === true) {
                    return false;
                }

                // Status filter
                // Distinguish between undefined (no status) and "unknown" (actual status value)
                if (selectedStatuses.length > 0) {
                    if (thread.status === undefined) {
                        // Thread has no status field
                        if (!selectedStatuses.includes('noStatus')) {
                            return false;
                        }
                    } else {
                        // Thread has a status field
                        // Lowercase both the thread status and selected statuses for comparison
                        // (selectedStatuses contains camelCase values like 'wontFix', 'active', etc.)
                        const status = thread.status.toLowerCase();
                        const selectedStatusesLower = selectedStatuses.map(s => s.toLowerCase());
                        if (!selectedStatusesLower.includes(status)) {
                            return false;
                        }
                    }
                }

                // Author filter (first comment author)
                if (selectedAuthor) {
                    if (!thread.comments || thread.comments.length === 0) {
                        return false;
                    }
                    const firstComment = thread.comments[0];
                    if (!firstComment.author || firstComment.author.displayName !== selectedAuthor) {
                        return false;
                    }
                }

                // Comment author filter (any comment from selected user)
                if (selectedCommentAuthor) {
                    if (!thread.comments || thread.comments.length === 0) {
                        return false;
                    }
                    const hasCommentFromUser = thread.comments.some(comment =>
                        comment.author && comment.author.displayName === selectedCommentAuthor
                    );
                    if (!hasCommentFromUser) {
                        return false;
                    }
                }

                // Search filter (search in all comment content)
                if (searchText) {
                    if (!thread.comments || thread.comments.length === 0) {
                        return false;
                    }
                    const searchLower = searchText.toLowerCase();
                    const hasMatchingContent = thread.comments.some(comment =>
                        comment.content && comment.content.toLowerCase().includes(searchLower)
                    );
                    if (!hasMatchingContent) {
                        return false;
                    }
                }

                return true;
            });

            // Update counts
            document.getElementById('totalCount').textContent = allThreads.length;
            document.getElementById('filteredCount').textContent = filtered.length;

            // Display filtered threads
            displayResults(currentPRData, filtered, allIterations, currentConfig);

            // Update URL with current filter state
            updateURL();
        }

        function toggleStatusChip(button) {
            button.classList.toggle('selected');
            applyThreadFilters();
        }

        function getSelectedThreadStatuses() {
            const selectedChips = document.querySelectorAll('.sidebar .status-chip.selected');
            return Array.from(selectedChips).map(chip => {
                // Return original camelCase value (e.g., 'wontFix', 'noStatus', 'active')
                // This preserves the exact data-status attribute value for URL persistence
                return chip.dataset.status;
            });
        }

        function toggleView() {
            isCompactView = !isCompactView;
            const button = document.getElementById('viewToggle');
            button.textContent = isCompactView ? 'Switch to Detailed' : 'Switch to Compact';

            // Re-apply filters to refresh display
            applyThreadFilters();
        }

        function toggleBulkMode() {
            isBulkMode = !isBulkMode;
            selectedThreadIds.clear();

            const button = document.getElementById('bulkModeToggle');
            const bulkActions = document.getElementById('bulkActions');
            const filters = document.querySelectorAll('.sidebar .filter-section');

            if (isBulkMode) {
                button.textContent = 'Disable Bulk Selection';
                button.classList.remove('btn-secondary');
                button.classList.add('btn-primary');
                bulkActions.classList.add('show');

                // Disable filters in bulk mode
                filters.forEach(row => {
                    const inputs = row.querySelectorAll('input, select');
                    inputs.forEach(input => input.disabled = true);
                });
            } else {
                button.textContent = 'Enable Bulk Selection';
                button.classList.remove('btn-primary');
                button.classList.add('btn-secondary');
                bulkActions.classList.remove('show');

                // Enable filters
                filters.forEach(row => {
                    const inputs = row.querySelectorAll('input, select');
                    inputs.forEach(input => input.disabled = false);
                });
            }

            // Refresh display to show/hide checkboxes
            applyThreadFilters();
        }

        function toggleThreadSelection(threadId) {
            if (selectedThreadIds.has(threadId)) {
                selectedThreadIds.delete(threadId);
            } else {
                selectedThreadIds.add(threadId);
            }

            // Update selected count
            document.getElementById('selectedCount').textContent = selectedThreadIds.size;

            // Update checkbox state
            const checkbox = document.getElementById(`thread-checkbox-${threadId}`);
            if (checkbox) {
                checkbox.checked = selectedThreadIds.has(threadId);
            }
        }

        function selectAllThreads() {
            selectedThreadIds.clear();

            // Get all visible thread IDs
            const checkboxes = document.querySelectorAll('.thread-checkbox');
            checkboxes.forEach(checkbox => {
                const threadId = checkbox.dataset.threadId;
                selectedThreadIds.add(threadId);
                checkbox.checked = true;
            });

            document.getElementById('selectedCount').textContent = selectedThreadIds.size;
        }

        function deselectAllThreads() {
            selectedThreadIds.clear();

            const checkboxes = document.querySelectorAll('.thread-checkbox');
            checkboxes.forEach(checkbox => {
                checkbox.checked = false;
            });

            document.getElementById('selectedCount').textContent = 0;
        }

        async function changeThreadStatus(threadId, newStatus) {
            if (!currentConfig || !currentPRId || !newStatus) return;

            try {
                console.log(`Attempting to change thread ${threadId} status to: ${newStatus}`);
                const updatedThread = await ADOAPI.updateThreadStatus(currentConfig, currentPRId, threadId, newStatus);
                console.log(`API returned status:`, updatedThread.status);
                console.log(`Full updated thread:`, updatedThread);

                // Update local thread data with response from API
                // Note: threadId from onclick is a string, but thread.id is a number
                const thread = allThreads.find(t => t.id == threadId);
                if (thread && updatedThread) {
                    const oldStatus = thread.status;
                    thread.status = updatedThread.status;
                    thread.properties = updatedThread.properties;
                    console.log(`Updated local thread from ${oldStatus} to ${thread.status}`);
                } else {
                    console.warn(`Could not find thread ${threadId} in allThreads to update locally`);
                }

                // Refresh display to show updated badge
                applyThreadFilters();

                return true;
            } catch (error) {
                console.error(`Failed to update thread status:`, error);
                alert(`Failed to update thread status: ${error.message}\n\nNote: This requires a PAT with "Code (Write)" permissions.`);
                return false;
            }
        }

        async function removeThreadStatus(threadId) {
            if (!currentConfig || !currentPRId) return;

            const confirmed = confirm('Are you sure you want to remove the status from this thread?');
            if (!confirmed) return;

            try {
                console.log(`Attempting to remove status from thread ${threadId}`);
                const updatedThread = await ADOAPI.removeThreadStatus(currentConfig, currentPRId, threadId);
                console.log(`API returned after removing status:`, updatedThread);

                // Update local thread data with response from API
                // Note: threadId from onclick is a string, but thread.id is a number
                const thread = allThreads.find(t => t.id == threadId);
                if (thread && updatedThread) {
                    thread.status = updatedThread.status;
                    thread.properties = updatedThread.properties;
                    console.log(`Removed status from thread, new status:`, thread.status);
                } else {
                    console.warn(`Could not find thread ${threadId} in allThreads to update locally`);
                }

                // Refresh display
                applyThreadFilters();

                return true;
            } catch (error) {
                console.error(`Failed to remove thread status:`, error);
                alert(`Failed to remove thread status: ${error.message}\n\nNote: This requires a PAT with "Code (Write)" permissions.`);
                return false;
            }
        }

        async function applyBulkStatusChange() {
            const newStatus = document.getElementById('bulkStatusSelect').value;

            if (!newStatus) {
                alert('Please select a status to apply.');
                return;
            }

            if (selectedThreadIds.size === 0) {
                alert('Please select at least one thread.');
                return;
            }

            const statusLabels = {
                'active': 'Active',
                'fixed': 'Resolved',
                'closed': 'Closed',
                'wontFix': "Won't Fix",
                'pending': 'Pending'
            };
            const statusLabel = statusLabels[newStatus] || newStatus;

            const confirmed = confirm(`Are you sure you want to change ${selectedThreadIds.size} thread(s) to "${statusLabel}"?`);
            if (!confirmed) return;

            ADOUI.showLoading('results', `Updating ${selectedThreadIds.size} thread(s)...`);

            let successCount = 0;
            let failCount = 0;

            for (const threadId of selectedThreadIds) {
                const success = await changeThreadStatus(threadId, newStatus);
                if (success) {
                    successCount++;
                } else {
                    failCount++;
                }
            }

            // Clear selection and refresh
            selectedThreadIds.clear();
            document.getElementById('selectedCount').textContent = 0;
            document.getElementById('bulkStatusSelect').value = '';

            applyThreadFilters();

            if (failCount === 0) {
                alert(`Successfully updated ${successCount} thread(s).`);
            } else {
                alert(`Updated ${successCount} thread(s) successfully.\n${failCount} thread(s) failed to update.`);
            }
        }

        // Use histogram diff for region diffs
        function computeRegionDiff(oldLines, newLines) {
            return HistogramDiff.diffLines(oldLines, newLines);
        }

        function getLastIterationBeforeTime(sortedIterations, time) {
            for (let i = sortedIterations.length - 1; i >= 0; i--) {
                if (new Date(sortedIterations[i].createdDate) < time) {
                    return sortedIterations[i];
                }
            }
            return null;
        }

        function getIterationLinksForComment(comment, thread, iterations, config, prData, filePath, isFirstComment = false) {
            const commentId = comment.id;
            const discussionId = thread.id;

            if (!iterations || iterations.length === 0) {
                return { beforeLink: null, afterLink: null, completeLink: null };
            }

            const sortedIterations = [...iterations].sort((a, b) =>
                new Date(a.createdDate) - new Date(b.createdDate)
            );

            const commentTime = new Date(comment.publishedDate);
            const latestIteration = sortedIterations[sortedIterations.length - 1];

            // For the first comment, use the thread's secondComparingIteration (what ADO recorded)
            // For subsequent comments, calculate based on timestamp
            let targetIterationId;
            if (isFirstComment) {
                targetIterationId = thread.pullRequestThreadContext?.iterationContext?.secondComparingIteration;
            }
            // Fallback to timestamp-based if not first comment or not available
            if (targetIterationId === null || targetIterationId === undefined) {
                const lastBefore = getLastIterationBeforeTime(sortedIterations, commentTime);
                targetIterationId = lastBefore ? lastBefore.id : sortedIterations[0].id;
            }

            // Check if there are iterations after this comment
            const hasIterationsAfter = targetIterationId < latestIteration.id;

            let beforeLink = null;
            let afterLink = null;
            let completeLink = null;
            let beforeRange = null;
            let afterRange = null;
            let completeRange = null;

            const baseUrl = `${config.serverUrl}/${config.organization}/${config.project}/_git/${config.repository}/pullrequest/${prData.pullRequestId}`;
            const pathParam = filePath ? `&path=${encodeURIComponent(filePath)}` : '';
            const commentParams = `&discussionId=${discussionId}&commentId=${commentId}`;

            const formatRange = (start, end) => start === end ? `${start}` : `${start}..${end}`;

            // Only show before/after links if there are iterations after (otherwise it's same as complete)
            if (hasIterationsAfter) {
                beforeLink = `${baseUrl}?_a=files${pathParam}&iteration=${targetIterationId}&base=0${commentParams}`;
                beforeRange = formatRange(1, targetIterationId);

                afterLink = `${baseUrl}?_a=files${pathParam}&iteration=${latestIteration.id}&base=${targetIterationId}${commentParams}`;
                afterRange = formatRange(targetIterationId + 1, latestIteration.id);
            }

            completeLink = `${baseUrl}?_a=files${pathParam}&iteration=${latestIteration.id}&base=0${commentParams}`;
            completeRange = formatRange(1, latestIteration.id);

            return { beforeLink, afterLink, completeLink, beforeRange, afterRange, completeRange };
        }

        async function renderCodeSuggestion(thread, comment) {
            console.log('renderCodeSuggestion called for thread:', thread.id);

            // Extract suggestion from comment content
            const suggestionMatch = comment.content?.match(/```suggestion\n([\s\S]*?)\n```/);
            if (!suggestionMatch) {
                console.log('No suggestion match found in comment content');
                return null;
            }

            const suggestion = suggestionMatch[1];
            console.log('Found suggestion:', suggestion);

            const ctx = thread.threadContext;

            // For code suggestions, we use rightFileStart (the target/new code location)
            // leftFileStart is only for diffs that show both old and new code
            if (!ctx || !ctx.rightFileStart || !currentConfig || !thread.pullRequestThreadContext) {
                console.log('Missing required context:', {
                    hasCtx: !!ctx,
                    hasRightFileStart: !!ctx?.rightFileStart,
                    hasLeftFileStart: !!ctx?.leftFileStart,
                    hasCurrentConfig: !!currentConfig,
                    hasPullRequestThreadContext: !!thread.pullRequestThreadContext
                });
                return null;
            }

            try {
                console.log('Fetching file content for code suggestion...');
                // Get the iteration to fetch the original code
                const iterationId = thread.pullRequestThreadContext.iterationContext?.secondComparingIteration;
                let iteration;

                if (iterationId !== null && iterationId !== undefined) {
                    iteration = allIterations.find(it => it.id === iterationId);
                }

                if (!iteration) {
                    iteration = allIterations[allIterations.length - 1];
                }

                const commitId = iteration?.sourceRefCommit?.commitId || currentPRData.lastMergeSourceCommit?.commitId;
                if (!commitId) {
                    throw new Error('Could not determine commit version');
                }

                // Fetch the file content
                const fileContent = await ADOAPI.getFileContent(currentConfig, ctx.filePath, {
                    version: commitId,
                    versionType: 'commit'
                });

                // Extract the original lines and character offsets
                // For code suggestions, use rightFileStart (the location in the new/target code)
                const lines = fileContent.split('\n');
                const startLine = ctx.rightFileStart.line;
                const endLine = ctx.rightFileEnd ? ctx.rightFileEnd.line : startLine;
                const startOffset = ctx.rightFileStart.offset || 0;
                const endOffset = ctx.rightFileEnd?.offset || 0;

                // Adjust offsets (ADO uses 1-based, JavaScript uses 0-based)
                const adjustedStartOffset = Math.max(0, startOffset - 1);
                const adjustedEndOffset = Math.max(0, endOffset - 1);

                console.log(`Extracting lines ${startLine}-${endLine} with offsets ${startOffset}-${endOffset} from file`);

                // Extract the full original lines
                const fullOriginalLines = lines.slice(startLine - 1, endLine).join('\n');

                // Extract the portion being changed (using character offsets)
                let originalChangedText = '';
                let prefixText = '';
                let suffixText = '';

                if (startLine === endLine) {
                    // Single line change
                    const line = lines[startLine - 1] || '';
                    prefixText = line.substring(0, adjustedStartOffset);
                    originalChangedText = line.substring(adjustedStartOffset, adjustedEndOffset);
                    suffixText = line.substring(adjustedEndOffset);
                } else {
                    // Multi-line change
                    const firstLine = lines[startLine - 1] || '';
                    const lastLine = lines[endLine - 1] || '';
                    const middleLines = lines.slice(startLine, endLine - 1);

                    prefixText = firstLine.substring(0, adjustedStartOffset);
                    originalChangedText = firstLine.substring(adjustedStartOffset);
                    if (middleLines.length > 0) {
                        originalChangedText += '\n' + middleLines.join('\n');
                    }
                    originalChangedText += '\n' + lastLine.substring(0, adjustedEndOffset);
                    suffixText = lastLine.substring(adjustedEndOffset);
                }

                // Build the diff view (light theme) with full line context
                let html = '<div style="background: #f8f8f8; color: #323130; padding: 12px; margin-top: 8px; border-radius: 0; border: 1px solid #d1d1d1; font-family: \'Consolas\', \'Monaco\', \'Courier New\', monospace; font-size: 12px;">';
                html += '<div style="color: #8a6d3b; font-weight: 600; margin-bottom: 8px;">üí° Code change suggestion</div>';
                html += '<div style="border: 1px solid #d1d1d1; border-radius: 0; overflow: hidden; background: white;">';

                // Original line(s) with changed part highlighted
                const originalWithHighlight = ADOContent.escapeHtml(prefixText) +
                    `<strong style="background: #ffc0cb; font-weight: 700;">${ADOContent.escapeHtml(originalChangedText)}</strong>` +
                    ADOContent.escapeHtml(suffixText);

                const originalLinesArray = originalWithHighlight.split('\n');
                originalLinesArray.forEach(line => {
                    html += `<div style="background: #ffeef0; padding: 2px 8px; border-left: 2px solid #d73a49;"><span style="color: #d73a49; font-weight: 600;">- </span>${line}</div>`;
                });

                // Suggested line(s) with changed part highlighted
                const suggestedWithHighlight = ADOContent.escapeHtml(prefixText) +
                    `<strong style="background: #c3f0c8; font-weight: 700;">${ADOContent.escapeHtml(suggestion)}</strong>` +
                    ADOContent.escapeHtml(suffixText);

                const suggestedLinesArray = suggestedWithHighlight.split('\n');
                suggestedLinesArray.forEach(line => {
                    html += `<div style="background: #e6ffed; padding: 2px 8px; border-left: 2px solid #28a745;"><span style="color: #28a745; font-weight: 600;">+ </span>${line}</div>`;
                });

                html += '</div></div>';
                return html;
            } catch (error) {
                console.error('Failed to render code suggestion:', error);
                return `<div style="background: #f8f8f8; color: #323130; padding: 12px; margin-top: 8px; border-radius: 0; border: 1px solid #d1d1d1; font-family: 'Consolas', 'Monaco', 'Courier New', monospace; font-size: 12px;">
                    <div style="color: #8a6d3b; font-weight: 600; margin-bottom: 8px;">üí° Code change suggestion</div>
                    <div style="color: #605e5c; font-size: 11px;">Could not load suggestion details. Click the iteration links above or "View in ADO" to see the code diff.</div>
                </div>`;
            }
        }

        async function loadFilePreviewContent(previewDiv, filePath, iterationId, startLine, endLine, startOffset, endOffset) {
            if (previewDiv.hasAttribute('data-loaded')) return;

            try {
                let iteration = allIterations.find(it => it.id === iterationId);
                if (!iteration) {
                    iteration = allIterations[allIterations.length - 1];
                }

                const commitId = iteration?.sourceRefCommit?.commitId || currentPRData.lastMergeSourceCommit?.commitId;
                if (!commitId) {
                    throw new Error('Could not determine commit version');
                }

                const fileContent = await ADOAPI.getFileContent(currentConfig, filePath, {
                    version: commitId,
                    versionType: 'commit'
                });

                const lines = fileContent.split('\n');
                const contextLines = 5;
                const startIdx = Math.max(0, startLine - contextLines - 1);
                const endIdx = Math.min(lines.length, endLine + contextLines);

                let html = '<pre>';
                for (let i = startIdx; i < endIdx; i++) {
                    const lineNum = i + 1;
                    const rawLine = lines[i] || '';
                    const isInRange = lineNum >= startLine && lineNum <= endLine;

                    let lineContentHtml;
                    if (isInRange && startOffset !== undefined && endOffset !== undefined) {
                        const adjustedStartOffset = Math.max(0, startOffset - 1);
                        const adjustedEndOffset = Math.max(0, endOffset - 1);

                        if (lineNum === startLine && lineNum === endLine) {
                            const before = ADOContent.escapeHtml(rawLine.substring(0, adjustedStartOffset));
                            const highlighted = ADOContent.escapeHtml(rawLine.substring(adjustedStartOffset, adjustedEndOffset));
                            const after = ADOContent.escapeHtml(rawLine.substring(adjustedEndOffset));
                            lineContentHtml = `${before}<mark style="background: #ffe082; color: #000000; font-weight: 600;">${highlighted}</mark>${after}`;
                        } else if (lineNum === startLine) {
                            const before = ADOContent.escapeHtml(rawLine.substring(0, adjustedStartOffset));
                            const highlighted = ADOContent.escapeHtml(rawLine.substring(adjustedStartOffset));
                            lineContentHtml = `${before}<mark style="background: #ffe082; color: #000000; font-weight: 600;">${highlighted}</mark>`;
                        } else if (lineNum === endLine) {
                            const highlighted = ADOContent.escapeHtml(rawLine.substring(0, adjustedEndOffset));
                            const after = ADOContent.escapeHtml(rawLine.substring(adjustedEndOffset));
                            lineContentHtml = `<mark style="background: #ffe082; color: #000000; font-weight: 600;">${highlighted}</mark>${after}`;
                        } else {
                            lineContentHtml = `<mark style="background: #ffe082; color: #000000; font-weight: 600;">${ADOContent.escapeHtml(rawLine)}</mark>`;
                        }
                    } else {
                        lineContentHtml = ADOContent.escapeHtml(rawLine);
                    }

                    html += `<div class="file-preview-line"><span class="file-preview-line-number">${lineNum}</span><span class="file-preview-line-content">${lineContentHtml}</span></div>`;
                }
                html += '</pre>';

                previewDiv.innerHTML = html;
                previewDiv.setAttribute('data-loaded', 'true');
            } catch (error) {
                console.error('Failed to load file preview:', error);
                previewDiv.innerHTML = `<div style="padding: 12px; color: #a4262c;">Failed to load file preview: ${ADOContent.escapeHtml(error.message)}</div>`;
            }
        }

        async function toggleFilePreview(previewId, filePath, startLine, endLine, firstIterationId, secondIterationId, startOffset, endOffset, useRight = true) {
            const previewDiv = document.getElementById(previewId);
            const headerDiv = previewDiv.previousElementSibling;
            const arrow = headerDiv.querySelector('span:first-child');

            if (previewDiv.classList.contains('show')) {
                previewDiv.classList.remove('show');
                arrow.textContent = '‚ñ∂';
            } else {
                previewDiv.classList.add('show');
                arrow.textContent = '‚ñº';

                if (!previewDiv.hasAttribute('data-loaded')) {
                    previewDiv.innerHTML = '<div style="padding: 12px; color: #858585;">Loading...</div>';

                    // Determine iteration: prefer secondIterationId for right side, firstIterationId for left
                    const iterationId = useRight
                        ? (secondIterationId ?? firstIterationId)
                        : (firstIterationId ?? secondIterationId);

                    await loadFilePreviewContent(previewDiv, filePath, iterationId, startLine, endLine, startOffset, endOffset);
                }
            }
        }

        async function loadDiffPreviewContent(previewDiv, filePath, oldIterationId, newIterationId, startLine, endLine) {
            if (previewDiv.hasAttribute('data-loaded')) return;

            try {
                // Get new iteration
                const newIteration = allIterations.find(it => it.id === newIterationId);
                if (!newIteration) {
                    throw new Error('Could not find iteration data');
                }

                const newCommitId = newIteration.sourceRefCommit?.commitId;
                if (!newCommitId) {
                    throw new Error('Could not determine commit versions');
                }

                // For oldIterationId === 0, use base commit (merge target)
                let oldCommitId;
                let oldFilePath;

                if (oldIterationId === 0) {
                    // Compare against base branch
                    oldCommitId = currentPRData.lastMergeTargetCommit?.commitId;
                    if (!oldCommitId) {
                        throw new Error('Could not determine base commit');
                    }
                    // For base comparison, file path is the same (or we'd need to track across base)
                    oldFilePath = filePath;
                } else {
                    const oldIteration = allIterations.find(it => it.id === oldIterationId);
                    if (!oldIteration) {
                        throw new Error('Could not find old iteration data');
                    }
                    oldCommitId = oldIteration.sourceRefCommit?.commitId;
                    if (!oldCommitId) {
                        throw new Error('Could not determine old commit version');
                    }
                    // Get file path at old iteration (handles renames)
                    oldFilePath = await getFilePathAtIteration(filePath, newIterationId, oldIterationId);
                }

                const newFilePath = filePath; // newIterationId is our known iteration

                // Fetch both file versions in parallel
                const [oldContent, newContent] = await Promise.all([
                    ADOAPI.getFileContent(currentConfig, oldFilePath, { version: oldCommitId, versionType: 'commit' }).catch(() => ''),
                    ADOAPI.getFileContent(currentConfig, newFilePath, { version: newCommitId, versionType: 'commit' })
                ]);

                const oldLines = oldContent.split('\n');
                const newLines = newContent.split('\n');

                // Compute diff for the region around the comment
                const contextLines = 5;
                const regionStart = Math.max(0, startLine - contextLines - 1);
                const regionEnd = Math.min(Math.max(oldLines.length, newLines.length), endLine + contextLines);

                // Get lines in the region for diffing
                const oldRegion = oldLines.slice(regionStart, Math.min(oldLines.length, regionEnd));
                const newRegion = newLines.slice(regionStart, Math.min(newLines.length, regionEnd));

                const diff = computeRegionDiff(oldRegion, newRegion);

                // Render diff
                let html = '<pre>';
                let oldLineNum = regionStart + 1;
                let newLineNum = regionStart + 1;

                for (const entry of diff) {
                    const escapedContent = ADOContent.escapeHtml(entry.content);

                    if (entry.type === 'unchanged') {
                        html += `<div class="diff-line diff-unchanged"><span class="diff-line-number">${oldLineNum}</span><span class="diff-line-number">${newLineNum}</span><span class="diff-indicator"> </span><span class="diff-content">${escapedContent}</span></div>`;
                        oldLineNum++;
                        newLineNum++;
                    } else if (entry.type === 'removed') {
                        html += `<div class="diff-line diff-removed"><span class="diff-line-number">${oldLineNum}</span><span class="diff-line-number"></span><span class="diff-indicator">‚àí</span><span class="diff-content">${escapedContent}</span></div>`;
                        oldLineNum++;
                    } else if (entry.type === 'added') {
                        html += `<div class="diff-line diff-added"><span class="diff-line-number"></span><span class="diff-line-number">${newLineNum}</span><span class="diff-indicator">+</span><span class="diff-content">${escapedContent}</span></div>`;
                        newLineNum++;
                    }
                }
                html += '</pre>';

                previewDiv.innerHTML = html;
                previewDiv.setAttribute('data-loaded', 'true');
            } catch (error) {
                console.error('Failed to load diff preview:', error);
                previewDiv.innerHTML = `<div style="padding: 12px; color: #a4262c;">Failed to load diff: ${ADOContent.escapeHtml(error.message)}</div>`;
            }
        }

        async function toggleIterationPreview(previewId, filePath, oldIterationId, newIterationId, startLine, endLine) {
            const previewDiv = document.getElementById(previewId);
            const headerDiv = previewDiv.previousElementSibling;
            const arrow = headerDiv.querySelector('span:first-child');

            if (previewDiv.classList.contains('show')) {
                previewDiv.classList.remove('show');
                arrow.textContent = '‚ñ∂';
            } else {
                previewDiv.classList.add('show');
                arrow.textContent = '‚ñº';

                if (!previewDiv.hasAttribute('data-loaded')) {
                    previewDiv.innerHTML = '<div style="padding: 12px; color: #858585;">Loading diff...</div>';
                    await loadDiffPreviewContent(previewDiv, filePath, oldIterationId, newIterationId, startLine, endLine);
                }
            }
        }

        function displayResults(prData, threads, iterations, config) {
            const resultsDiv = document.getElementById('results');

            // Count threads by status
            const statusCounts = threads.reduce((acc, thread) => {
                if (thread.isDeleted === true) {
                    acc.deleted = (acc.deleted || 0) + 1;
                } else if (thread.status === undefined) {
                    // Thread has no status field
                    acc.noStatus = (acc.noStatus || 0) + 1;
                } else {
                    // Thread has a status field (including "unknown" as a valid value)
                    const status = thread.status;
                    acc[status] = (acc[status] || 0) + 1;
                }
                return acc;
            }, {});

            // Get active thread counts per author (using all threads, not just filtered)
            const threadCounts = getActiveThreadCounts(allThreads);

            const prUrl = `${config.serverUrl}/${config.organization}/${config.project}/_git/${config.repository}/pullrequest/${prData.pullRequestId}`;

            // Generate status badge for title
            const statusBadgeClass = `badge-${prData.status}`;
            const statusLabel = prData.status.charAt(0).toUpperCase() + prData.status.slice(1);
            const draftBadge = prData.isDraft ? ' <span class="badge badge-draft">Draft</span>' : '';
            const statusBadgeHtml = `<span class="badge ${statusBadgeClass}">${statusLabel}</span>${draftBadge}`;

            // Generate PR author avatar for title
            let prAuthorAvatarHtml = '';
            if (prData.createdBy?.id) {
                const authorTitle = ADOContent.escapeHtml(prData.createdBy.displayName || 'Unknown');
                const cachedUrl = AvatarLoader.getCached(prData.createdBy.id);
                if (cachedUrl) {
                    prAuthorAvatarHtml = `<span class="avatar-wrapper pr-title-avatar"><img src="${cachedUrl}" alt="${authorTitle}" title="${authorTitle}" class="avatar"></span>`;
                } else {
                    prAuthorAvatarHtml = `<span class="avatar-wrapper pr-title-avatar"><div class="avatar-placeholder" title="${authorTitle}"></div><img data-user-id="${prData.createdBy.id}" alt="${authorTitle}" title="${authorTitle}" class="avatar avatar-pending"></span>`;
                }
            }

            // PR Header HTML (middle column)
            let html = `
                <div class="pr-header">
                    <h2 style="display: flex; justify-content: space-between; align-items: center; gap: 16px;">
                        <span>${statusBadgeHtml} ${prAuthorAvatarHtml}PR #${prData.pullRequestId}: ${ADOContent.escapeHtml(prData.title)}</span>
                        <a href="${prUrl}" target="_blank" style="font-size: 14px; color: #0078d4; text-decoration: none; white-space: nowrap;" title="Open PR in Azure DevOps">üîó View in ADO</a>
                    </h2>
                    <p><strong>Created:</strong> ${ADOUI.formatDate(prData.creationDate)}</p>
                    <p class="branch-info"><strong>Branches:</strong> <code>${prData.sourceRefName?.replace('refs/heads/', '') || 'Unknown'}</code> ‚Üí <code>${prData.targetRefName?.replace('refs/heads/', '') || 'Unknown'}</code></p>
                    ${prData.description ? `
                    <div class="description-card">
                        <div class="description-card-header">Description</div>
                        <div class="description-card-content">
                            <div class="pr-description">${ADOContent.processContent(prData.description)}</div>
                        </div>
                    </div>
                    ` : ''}
                </div>
            `;

            // Stats HTML (right sidebar)
            const statsHtml = `
                <h4>Threads</h4>
                <div class="compact-stats">
                    <span title="Active">üí¨ <strong>${statusCounts.active || 0}</strong></span>
                    <span title="Resolved" style="color: #107c10;">‚úÖ <strong>${statusCounts.fixed || 0}</strong></span>
                    <span title="Closed" style="color: #605e5c;">üîí <strong>${statusCounts.closed || 0}</strong></span>
                    ${statusCounts.pending ? `<span title="Pending" style="color: #8a6d3b;">‚è±Ô∏è <strong>${statusCounts.pending}</strong></span>` : ''}
                    ${statusCounts.wontFix ? `<span title="Won't Fix" style="color: #605e5c;">üö´ <strong>${statusCounts.wontFix}</strong></span>` : ''}
                    ${statusCounts.deleted ? `<span title="Deleted" style="color: #a4262c;">üóëÔ∏è <strong>${statusCounts.deleted}</strong></span>` : ''}
                </div>
                ${currentFileChangeStats ? `
                <h4 style="margin-top: 15px;">Change Stats</h4>
                <div class="compact-stats">
                    <span>Files</span>
                    <strong style="color: #107c10;" title="Added">+${currentFileChangeStats.added}</strong>
                    <strong style="color: #0078d4;" title="Modified">~${currentFileChangeStats.modified}</strong>
                    <strong style="color: #a4262c;" title="Deleted">-${currentFileChangeStats.deleted}</strong>
                </div>
                <div id="lineStatsContainer" class="compact-stats">
                    <span>Lines</span>
                    <span style="color: #605e5c;">‚è≥</span>
                </div>
                <div class="compact-stats">
                    <span>Updates</span>
                    <strong>${iterations.length}</strong>
                </div>
                ` : ''}
            `;

            // Reviewers HTML (right sidebar)
            const reviewersHtml = `
                ${renderReviewersSection(prData.reviewers, threadCounts, prData.createdBy?.id)}
                ${renderOtherAuthorsSection(allThreads, prData.reviewers, threadCounts, prData.createdBy?.id)}
            `;

            // Checks HTML (right sidebar)
            const checksHtml = renderChecksSection();

            // Inject right sidebar content
            document.getElementById('rightSidebarStats').innerHTML = statsHtml;
            document.getElementById('rightSidebarReviewers').innerHTML = reviewersHtml;
            document.getElementById('rightSidebarChecks').innerHTML = checksHtml;
            document.getElementById('rightSidebar').style.display = '';

            if (threads.length === 0) {
                html += '<div class="info">No threads found for this Pull Request.</div>';
            } else {
                html += '<div class="thread-container">';

                threads.forEach((thread, index) => {
                    const hasStatus = thread.status !== undefined;
                    const status = thread.status; // Keep actual status value (could be undefined, 'unknown', 'active', etc.)
                    const isThreadDeleted = thread.isDeleted === true;

                    const statusClass = ADOUI.getStatusBadgeClass(status, isThreadDeleted);
                    const statusText = ADOUI.getStatusText(status, isThreadDeleted);

                    const threadId = thread.id;
                    const threadUrl = ADOURL.buildThreadUrl(config, prData.pullRequestId, threadId, thread.threadContext?.filePath);
                    const apiEndpoint = `${config.serverUrl}/${config.organization}/${config.project}/_apis/git/repositories/${config.repository}/pullRequests/${prData.pullRequestId}/threads/${threadId}?api-version=6.0`;

                    const compactClass = isCompactView ? 'compact-view' : '';
                    const isChecked = selectedThreadIds.has(threadId) ? 'checked' : '';

                    // Build status dropdown (only when not in bulk mode and not deleted)
                    let statusControl = '';
                    if (!isBulkMode && !isThreadDeleted) {
                        if (hasStatus) {
                            // Thread has status: show "Change status:" with current selection and remove button
                            statusControl = `
                                <span class="thread-status-change">
                                    <select onchange="changeThreadStatus('${threadId}', this.value); this.blur();">
                                        <option value="">Change status...</option>
                                        <option value="active" ${status === 'active' ? 'selected' : ''}>Active</option>
                                        <option value="fixed" ${status === 'fixed' ? 'selected' : ''}>Resolved</option>
                                        <option value="closed" ${status === 'closed' ? 'selected' : ''}>Closed</option>
                                        <option value="wontFix" ${status === 'wontFix' ? 'selected' : ''}>Won't Fix</option>
                                        <option value="pending" ${status === 'pending' ? 'selected' : ''}>Pending</option>
                                        <option value="unknown" ${status === 'unknown' ? 'selected' : ''}>Unknown</option>
                                    </select>
                                    <button onclick="removeThreadStatus('${threadId}')" class="btn-secondary" style="margin-left: 5px; padding: 2px 8px; font-size: 12px;" title="Remove status from this thread">‚úï</button>
                                </span>
                            `;
                        } else {
                            // Thread has no status: show "Try force status:" with no selection
                            statusControl = `
                                <span class="thread-status-change">
                                    <select onchange="changeThreadStatus('${threadId}', this.value); this.blur();">
                                        <option value="" selected>Try force status...</option>
                                        <option value="active">Active</option>
                                        <option value="fixed">Resolved</option>
                                        <option value="closed">Closed</option>
                                        <option value="wontFix">Won't Fix</option>
                                        <option value="pending">Pending</option>
                                        <option value="unknown">Unknown</option>
                                    </select>
                                </span>
                            `;
                        }
                    }

                    html += `
                        <div class="thread ${compactClass}">
                            <div class="thread-header">
                                <span>
                                    ${isBulkMode ? `<input type="checkbox" class="thread-checkbox" id="thread-checkbox-${threadId}" data-thread-id="${threadId}" ${isChecked} onchange="toggleThreadSelection('${threadId}')">` : ''}
                                    Thread #${index + 1}
                                    <a href="${threadUrl}" target="_blank" style="font-size: 13px; margin-left: 8px; color: #0078d4; text-decoration: none;" title="Open thread in Azure DevOps (${thread.threadContext ? 'files tab' : 'overview tab'})">üîó</a>
                                </span>
                                <span>
                                    <button class="raw-json-toggle" onclick="ADOUI.toggleRawJson('thread-${index}')">View Raw JSON</button>
                                    ${hasStatus ? `<span class="badge ${statusClass}">${statusText}</span>` : ''}
                                    ${statusControl}
                                </span>
                            </div>
                    `;

                    // Add raw JSON container
                    const jsonString = JSON.stringify(thread, null, 2);
                    html += `
                        <div id="thread-${index}" class="raw-json-container">
                            <div style="margin-bottom: 10px; color: #9cdcfe;">
                                <strong>API Endpoint:</strong><br>
                                <a href="${apiEndpoint}" target="_blank" class="api-link" title="Open in new tab (requires authentication)">${apiEndpoint}</a>
                            </div>
                            <pre>${ADOContent.escapeHtml(jsonString)}</pre>
                        </div>
                    `;

                    // Show thread context if it's a code comment
                    // threadContext has file path and line info
                    // pullRequestThreadContext has iteration context
                    if (thread.threadContext) {
                        const ctx = thread.threadContext;

                        // Determine which file location to use (rightFile for new code, leftFile for deleted code)
                        const useRight = !!ctx.rightFileStart;
                        const fileStart = useRight ? ctx.rightFileStart : ctx.leftFileStart;
                        const fileEnd = useRight ? ctx.rightFileEnd : ctx.leftFileEnd;
                        const lineInfo = fileStart ? ` (Line ${fileStart.line}${fileEnd && fileEnd.line !== fileStart.line ? `-${fileEnd.line}` : ''})` : '';

                        // If we have line information, make the file path a collapsible preview header
                        if (ctx.filePath && fileStart) {
                            const secondIterationId = thread.pullRequestThreadContext?.iterationContext?.secondComparingIteration;
                            const startLine = fileStart.line;
                            const endLine = fileEnd ? fileEnd.line : startLine;

                            // First file preview: always show diff from base (0) to secondIterationId
                            const showDiff = secondIterationId && secondIterationId >= 1;
                            const iterationLabel = showDiff
                                ? ` <span style="color: #605e5c; font-size: 11px;">(base ‚Üí iteration ${secondIterationId})</span>`
                                : '';

                            // Always compare from base (0) to the thread's iteration context
                            const onclickHandler = showDiff
                                ? `toggleIterationPreview('file-preview-${threadId}', '${ADOContent.escapeJs(ctx.filePath)}', 0, ${secondIterationId}, ${startLine}, ${endLine})`
                                : `toggleFilePreview('file-preview-${threadId}', '${ADOContent.escapeJs(ctx.filePath)}', ${startLine}, ${endLine}, null, ${secondIterationId !== undefined ? secondIterationId : 'null'}, ${fileStart.offset || 0}, ${fileEnd?.offset || 0}, ${useRight})`;

                            html += `
                                <div class="file-preview">
                                    <div class="file-preview-header" onclick="${onclickHandler}">
                                        <span>‚ñ∂</span>
                                        <span><strong>File:</strong> ${ADOContent.escapeHtml(ctx.filePath || 'N/A')}${lineInfo}${iterationLabel}${useRight ? '' : ' <span style="color: #a4262c; font-size: 11px;">(deleted)</span>'}</span>
                                    </div>
                                    <div id="file-preview-${threadId}" class="file-preview-content"></div>
                                </div>
                            `;
                        } else {
                            // No line information, just show as regular context
                            html += `
                                <div class="thread-context">
                                    <strong>File:</strong> ${ADOContent.escapeHtml(ctx.filePath || 'N/A')}${lineInfo}
                                </div>
                            `;
                        }
                    }

                    // Show all comments in the thread
                    if (thread.comments && thread.comments.length > 0) {
                        let prevCommentIterationId = null;
                        const filePath = thread.threadContext?.filePath || null;
                        const ctx = thread.threadContext;
                        const fileStart = ctx?.rightFileStart || ctx?.leftFileStart;
                        const fileEnd = ctx?.rightFileEnd || ctx?.leftFileEnd;

                        // Sort iterations for calculating iteration contexts
                        const sortedIterations = iterations.length > 0
                            ? [...iterations].sort((a, b) => new Date(a.createdDate) - new Date(b.createdDate))
                            : [];

                        thread.comments.forEach((comment, commentIdx) => {
                            const isFirstComment = commentIdx === 0;

                            // Check if iteration changed since last comment (only for file-based threads)
                            if (filePath && fileStart && sortedIterations.length > 0) {
                                const commentTime = new Date(comment.publishedDate);
                                const lastIterBefore = getLastIterationBeforeTime(sortedIterations, commentTime);
                                const currentIterationId = lastIterBefore ? lastIterBefore.id : sortedIterations[0].id;

                                if (prevCommentIterationId !== null && currentIterationId !== prevCommentIterationId) {
                                    // Iteration changed - insert a diff preview divider
                                    const previewId = `iteration-preview-${threadId}-${commentIdx}`;
                                    const startLine = fileStart.line;
                                    const endLine = fileEnd ? fileEnd.line : startLine;
                                    const iterLineInfo = ` (Line ${startLine}${endLine !== startLine ? `-${endLine}` : ''})`;

                                    html += `
                                        <div class="file-preview" style="margin: 12px 0;">
                                            <div class="file-preview-header" onclick="toggleIterationPreview('${previewId}', '${ADOContent.escapeJs(filePath)}', ${prevCommentIterationId}, ${currentIterationId}, ${startLine}, ${endLine})">
                                                <span>‚ñ∂</span>
                                                <span><strong>File changed:</strong> ${ADOContent.escapeHtml(filePath)}${iterLineInfo} <span style="color: #605e5c; font-size: 11px;">(iteration ${prevCommentIterationId} ‚Üí ${currentIterationId})</span></span>
                                            </div>
                                            <div id="${previewId}" class="file-preview-content"></div>
                                        </div>
                                    `;
                                }

                                prevCommentIterationId = currentIterationId;
                            }

                            // Check if this is a code suggestion
                            const isCodeSuggestion = comment.content?.includes('```suggestion');

                            // Remove suggestion block from content before processing to avoid duplicate display
                            let contentToProcess = comment.content;
                            if (isCodeSuggestion) {
                                contentToProcess = contentToProcess.replace(/```suggestion\n[\s\S]*?\n```/g, '');
                            }

                            let resolvedContent = ADOContent.processContent(contentToProcess);

                            // Check if content is essentially empty (just whitespace or empty code blocks)
                            const contentStripped = resolvedContent.replace(/<pre><code><\/code><\/pre>/g, '').trim();
                            const hasRealContent = contentStripped.length > 0;

                            // Get iteration links for this comment
                            const iterationLinks = getIterationLinksForComment(
                                comment,
                                thread,
                                iterations,
                                config,
                                prData,
                                filePath,
                                isFirstComment
                            );

                            // Check if comment is deleted
                            const isDeleted = comment.isDeleted === true;

                            // Determine comment type
                            const commentType = comment.commentType || 'unknown';
                            let commentTypeLabel = '';
                            let commentClass = '';
                            let commentTypeBadgeClass = '';

                            if (isDeleted) {
                                commentTypeLabel = 'Deleted';
                                commentTypeBadgeClass = 'comment-type-deleted';
                            } else {
                                switch(commentType) {
                                    case 'system':
                                    case 3:
                                        commentTypeLabel = 'System';
                                        commentClass = 'system-comment';
                                        commentTypeBadgeClass = 'comment-type-system';
                                        break;
                                    case 'codeChange':
                                    case 2:
                                        commentTypeLabel = 'Code Change';
                                        commentClass = 'code-change-comment';
                                        commentTypeBadgeClass = 'comment-type-code-change';
                                        break;
                                    case 'text':
                                    case 1:
                                        commentTypeLabel = 'Text';
                                        commentTypeBadgeClass = 'comment-type-text';
                                        break;
                                    default:
                                        commentTypeLabel = 'Unknown';
                                        break;
                                }
                            }

                            // Generate avatar HTML for comment author
                            let commentAvatarHtml = '';
                            if (comment.author?.id) {
                                const authorTitle = ADOContent.escapeHtml(comment.author.displayName || 'Unknown');
                                const isCommentByPRAuthor = comment.author.id === prData.createdBy?.id;
                                const authorBadge = isCommentByPRAuthor ? `<span class="author-badge" title="PR Author"><svg viewBox="0 0 24 24"><path d="M12 2l3.09 6.26L22 9.27l-5 4.87 1.18 6.88L12 17.77l-6.18 3.25L7 14.14 2 9.27l6.91-1.01L12 2z" fill="#323130"/></svg></span>` : '';
                                const cachedUrl = AvatarLoader.getCached(comment.author.id);
                                if (cachedUrl) {
                                    commentAvatarHtml = `<div class="avatar-wrapper"><img src="${cachedUrl}" alt="${authorTitle}" title="${authorTitle}" class="avatar">${authorBadge}</div>`;
                                } else {
                                    commentAvatarHtml = `<div class="avatar-wrapper"><div class="avatar-placeholder" title="${authorTitle}"></div><img data-user-id="${comment.author.id}" alt="${authorTitle}" title="${authorTitle}" class="avatar avatar-pending">${authorBadge}</div>`;
                                }
                            }

                            html += `
                                <div class="comment ${commentClass}">
                                    <div class="comment-header">
                                        <span class="comment-author-info">
                                            ${commentAvatarHtml}
                                            <span class="comment-date">${ADOUI.formatDate(comment.publishedDate)}</span>
                                            ${iterationLinks.completeLink ? `
                                            <span class="code-links">
                                                ${iterationLinks.beforeLink ? `<span class="iteration-range">${iterationLinks.beforeRange}</span><a href="${iterationLinks.beforeLink}" target="_blank" class="comment-link" title="Diff from first update to last update before this comment"><svg viewBox="0 0 24 24"><path d="M20 11H7.83l5.59-5.59L12 4l-8 8 8 8 1.41-1.41L7.83 13H20v-2z"/></svg></a>` : ''}
                                                ${iterationLinks.afterLink ? `<a href="${iterationLinks.afterLink}" target="_blank" class="comment-link" title="Diff from first update after this comment to latest"><svg viewBox="0 0 24 24"><path d="M12 4l-1.41 1.41L16.17 11H4v2h12.17l-5.58 5.59L12 20l8-8-8-8z"/></svg></a><span class="iteration-range">${iterationLinks.afterRange}</span>` : ''}
                                                <a href="${iterationLinks.completeLink}" target="_blank" class="comment-link" title="Complete diff from first to latest update"><svg viewBox="0 0 24 24"><path d="M6.99 11L3 15l3.99 4v-3H14v-2H6.99v-3zM21 9l-3.99-4v3H10v2h7.01v3L21 9z"/></svg></a><span class="iteration-range">${iterationLinks.completeRange}</span>
                                            </span>
                                            ` : ''}
                                            ${isDeleted || commentTypeLabel !== 'Text' ? `<span class="comment-type-badge ${commentTypeBadgeClass}">${commentTypeLabel}</span>` : ''}
                                        </span>
                                    </div>
                                    ${hasRealContent ? `<div class="comment-content">${resolvedContent}</div>` : ''}

                                    ${isCodeSuggestion ? `<div id="code-suggestion-${threadId}-${commentIdx}" data-thread-id="${threadId}" data-comment-idx="${commentIdx}"><div style="padding: 12px; color: #858585;">Loading code suggestion...</div></div>` : ''}
                                </div>
                            `;
                        });
                    }

                    html += '</div>';
                });

                html += '</div>';
            }

            resultsDiv.innerHTML = html;

            // Load avatars
            AvatarLoader.loadPending();

            // Fetch PR checks (statuses, policies) asynchronously and start polling
            fetchPRChecks(config, prData);
            startChecksPolling(config, prData);

            // Fetch line stats asynchronously
            fetchLineStatsAsync(config, prData);

            // Asynchronously load code suggestions
            setTimeout(async () => {
                try {
                    const suggestionDivs = resultsDiv.querySelectorAll('[id^="code-suggestion-"]');
                    console.log(`Found ${suggestionDivs.length} code suggestion divs to process`);

                    for (const div of suggestionDivs) {
                        try {
                            const threadId = parseInt(div.dataset.threadId);
                            const commentIdx = parseInt(div.dataset.commentIdx);
                            console.log(`Processing code suggestion for thread ${threadId}, comment ${commentIdx}`);

                            const thread = threads.find(t => t.id === threadId);
                            if (!thread) {
                                console.warn(`Thread ${threadId} not found`);
                                div.innerHTML = '<div style="padding: 12px; color: #a4262c;">Error: Thread not found</div>';
                                continue;
                            }

                            if (!thread.comments || !thread.comments[commentIdx]) {
                                console.warn(`Comment ${commentIdx} not found in thread ${threadId}`);
                                div.innerHTML = '<div style="padding: 12px; color: #a4262c;">Error: Comment not found</div>';
                                continue;
                            }

                            const comment = thread.comments[commentIdx];
                            const suggestionHtml = await renderCodeSuggestion(thread, comment);
                            if (suggestionHtml) {
                                div.innerHTML = suggestionHtml;
                                console.log(`Successfully loaded code suggestion for thread ${threadId}`);
                            } else {
                                console.log(`No suggestion HTML returned for thread ${threadId}`);
                                div.innerHTML = ''; // Remove loading message if no suggestion
                            }
                        } catch (error) {
                            console.error('Error processing individual code suggestion:', error);
                            div.innerHTML = `<div style="padding: 12px; color: #a4262c;">Error loading suggestion: ${ADOContent.escapeHtml(error.message)}</div>`;
                        }
                    }
                } catch (error) {
                    console.error('Error in code suggestion loading:', error);
                }
            }, 0);
        }

        // Left sidebar resize functionality
        (function initLeftSidebarResize() {
            const resizeHandle = document.getElementById('resizeHandle');
            const sidebar = document.querySelector('.left-sidebar');
            let isResizing = false;
            let startX = 0;
            let startWidth = 0;

            resizeHandle.addEventListener('mousedown', (e) => {
                isResizing = true;
                startX = e.clientX;
                startWidth = sidebar.offsetWidth;
                document.body.style.cursor = 'col-resize';
                document.body.style.userSelect = 'none';
                e.preventDefault();
            });

            document.addEventListener('mousemove', (e) => {
                if (!isResizing) return;

                const diff = e.clientX - startX;
                const newWidth = startWidth + diff;

                // Apply min/max constraints
                if (newWidth >= 200 && newWidth <= 600) {
                    sidebar.style.width = newWidth + 'px';
                }
            });

            document.addEventListener('mouseup', () => {
                if (isResizing) {
                    isResizing = false;
                    document.body.style.cursor = '';
                    document.body.style.userSelect = '';
                }
            });
        })();

        // Right sidebar resize functionality
        (function initRightSidebarResize() {
            const resizeHandle = document.getElementById('resizeHandleRight');
            const sidebar = document.getElementById('rightSidebar');
            let isResizing = false;
            let startX = 0;
            let startWidth = 0;

            resizeHandle.addEventListener('mousedown', (e) => {
                isResizing = true;
                startX = e.clientX;
                startWidth = sidebar.offsetWidth;
                document.body.style.cursor = 'col-resize';
                document.body.style.userSelect = 'none';
                e.preventDefault();
            });

            document.addEventListener('mousemove', (e) => {
                if (!isResizing) return;

                // Note: direction is reversed (dragging left increases width)
                const diff = startX - e.clientX;
                const newWidth = startWidth + diff;

                // Apply min/max constraints
                if (newWidth >= 200 && newWidth <= 500) {
                    sidebar.style.width = newWidth + 'px';
                }
            });

            document.addEventListener('mouseup', () => {
                if (isResizing) {
                    isResizing = false;
                    document.body.style.cursor = '';
                    document.body.style.userSelect = '';
                }
            });
        })();
    </script>
</body>
</html>
