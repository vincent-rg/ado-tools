<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Azure DevOps PR Threads Viewer</title>
    <link rel="stylesheet" href="common.css">
    <style>
        /* Sidebar layout */
        .page-layout {
            display: flex;
            gap: 20px;
            height: calc(100vh - 50px);
        }

        .sidebar {
            width: 280px;
            min-width: 200px;
            max-width: 400px;
            background: #f3f2f1;
            border-radius: 6px;
            padding: 20px;
            overflow-y: auto;
            flex-shrink: 0;
            position: relative;
        }

        .resize-handle {
            position: absolute;
            right: 0;
            top: 0;
            bottom: 0;
            width: 8px;
            cursor: col-resize;
            background: transparent;
            transition: background 0.2s;
        }

        .resize-handle:hover {
            background: rgba(0, 120, 212, 0.2);
        }

        .main-content {
            flex: 1;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        .results-container {
            flex: 1;
            overflow-y: auto;
            padding-right: 10px;
        }

        /* Filter section styling */
        .filter-section {
            margin-bottom: 20px;
        }

        .filter-section:last-child {
            margin-bottom: 0;
        }

        .filter-section h4 {
            margin-bottom: 10px;
            margin-top: 0;
            color: #323130;
            font-size: 14px;
        }

        .filter-section select {
            width: 100%;
            padding: 8px;
            border: 1px solid #d1d1d1;
            border-radius: 4px;
            background: white;
        }

        .filter-section input[type="text"] {
            width: 100%;
            padding: 8px;
            border: 1px solid #d1d1d1;
            border-radius: 4px;
            font-size: 14px;
            box-sizing: border-box;
        }

        .filter-section input[type="text"]:focus {
            outline: none;
            border-color: #0078d4;
        }

        /* Status chips for vertical layout */
        .status-chips-vertical {
            display: flex;
            flex-direction: column;
            gap: 6px;
        }

        .status-chip {
            padding: 6px 12px;
            border: 1px solid #d1d1d1;
            border-radius: 4px;
            background: white;
            color: #323130;
            font-size: 13px;
            cursor: pointer;
            transition: all 0.2s;
            user-select: none;
            text-align: left;
        }

        .status-chip:hover {
            border-color: #0078d4;
            background: #f3f9fd;
        }

        .status-chip.selected {
            background: #0078d4;
            color: white;
            border-color: #0078d4;
        }

        .checkbox-label {
            display: flex;
            align-items: center;
            padding: 8px;
            background: white;
            border-radius: 4px;
            cursor: pointer;
            transition: background 0.2s;
            margin-top: 8px;
        }

        .checkbox-label:hover {
            background: #e1f3ff;
        }

        .checkbox-label input[type="checkbox"] {
            margin-right: 8px;
        }

        .filter-actions {
            display: flex;
            gap: 10px;
            margin-top: 20px;
        }

        .thread-count {
            font-size: 13px;
            color: #605e5c;
            margin-top: 15px;
            padding-top: 15px;
            border-top: 1px solid #d1d1d1;
        }

        /* PR info bar */
        .pr-info {
            background: #f3f2f1;
            padding: 15px;
            border-radius: 6px;
            margin-bottom: 20px;
            display: flex;
            gap: 20px;
        }

        .pr-info-main {
            flex: 1;
            min-width: 0;
        }

        .pr-info-sidebar {
            flex: 0 0 auto;
            min-width: 200px;
            max-width: 280px;
        }

        .pr-info-sidebar .avatars-section {
            margin-top: 0;
        }

        .pr-info-sidebar .avatars-section + .avatars-section {
            margin-top: 10px;
        }

        .thread-container {
            margin-bottom: 30px;
        }

        .thread {
            border: 1px solid #edebe9;
            border-radius: 6px;
            margin-bottom: 20px;
            overflow: hidden;
        }

        .thread.compact-view .comment {
            padding: 8px 15px;
        }

        .thread.compact-view .comment-content {
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            max-width: 100%;
        }

        .thread.compact-view .comment-header {
            margin-bottom: 4px;
        }

        .thread.compact-view .thread-context,
        .thread.compact-view .raw-json-container {
            display: none;
        }

        .thread.compact-view .comment-content pre,
        .thread.compact-view .comment-content code,
        .thread.compact-view .comment-content img {
            display: none;
        }

        .thread-status-change {
            display: inline-flex;
            align-items: center;
            gap: 8px;
            margin-left: 10px;
        }

        .thread-status-change select {
            padding: 4px 8px;
            border: 1px solid #d1d1d1;
            border-radius: 4px;
            font-size: 12px;
            background: white;
        }

        .thread-checkbox {
            margin-right: 10px;
        }

        .bulk-actions {
            background: #fff4ce;
            border-left: 4px solid #ffb900;
            padding: 15px;
            border-radius: 4px;
            margin-bottom: 20px;
            display: none;
        }

        .bulk-actions.show {
            display: block;
        }

        .bulk-actions-buttons {
            display: flex;
            gap: 10px;
            align-items: center;
            flex-wrap: wrap;
            margin-top: 10px;
        }

        .bulk-actions-buttons select {
            padding: 8px;
            border: 1px solid #d1d1d1;
            border-radius: 4px;
        }

        .thread-header {
            background: #f3f2f1;
            padding: 10px 15px;
            font-weight: 600;
            color: #323130;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .comment {
            padding: 12px 15px;
            border-bottom: 1px solid #edebe9;
        }

        .comment:last-child {
            border-bottom: none;
        }

        .comment.system-comment {
            background: #f8f8f8;
            border-left: 3px solid #a19f9d;
        }

        .comment.code-change-comment {
            background: #fff9e6;
            border-left: 3px solid #ffb900;
        }

        .comment-type-badge {
            display: inline-block;
            padding: 2px 8px;
            border-radius: 3px;
            font-size: 11px;
            font-weight: 600;
            margin-left: 8px;
            text-transform: uppercase;
        }

        .comment-type-system {
            background: #e1dfdd;
            color: #605e5c;
        }

        .comment-type-code-change {
            background: #fff4ce;
            color: #8a6d3b;
        }

        .comment-type-text {
            background: #e1f3ff;
            color: #004578;
        }

        .comment-type-deleted {
            background: #fde7e9;
            color: #a4262c;
        }

        .comment-header {
            margin-bottom: 8px;
        }

        .comment-author-info {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .comment-author-info .avatar-wrapper {
            --avatar-size: 24px;
        }

        .comment-date {
            color: #605e5c;
            font-size: 13px;
        }

        .comment-link {
            color: #0078d4;
            text-decoration: none;
            font-size: 20px;
            margin-left: 12px;
            line-height: 1;
        }

        .comment-link:hover {
            opacity: 0.7;
        }

        .code-links {
            display: flex;
            align-items: center;
        }

        .comment-content {
            color: #323130;
            white-space: pre-wrap;
            word-wrap: break-word;
        }

        .comment-content strong {
            font-weight: 700;
            color: #323130;
        }

        .comment-content em {
            font-style: italic;
            color: #323130;
        }

        .comment-content a {
            color: #0078d4;
            text-decoration: none;
        }

        .comment-content a:hover {
            text-decoration: underline;
        }

        .comment-content img {
            max-width: 100%;
            height: auto;
            border: 1px solid #d1d1d1;
            border-radius: 4px;
            margin: 5px 5px 5px 0;
            display: inline-block;
            vertical-align: middle;
        }

        .thread-context {
            background: #fff4ce;
            padding: 8px 12px;
            margin-bottom: 10px;
            border-left: 3px solid #ffb900;
            font-size: 13px;
        }

        .file-preview {
            background: #f8f8f8;
            border: 1px solid #d1d1d1;
            border-radius: 4px;
            margin-bottom: 10px;
        }

        .file-preview-header {
            padding: 8px 12px;
            background: #fff4ce;
            border-left: 3px solid #ffb900;
            cursor: pointer;
            font-size: 13px;
            color: #323130;
            font-weight: normal;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .file-preview-header:hover {
            background: #ffecb3;
        }

        .file-preview-header span:first-child {
            color: #0078d4;
            font-weight: 600;
        }

        .file-preview-content {
            display: none;
            padding: 0;
            max-height: 400px;
            overflow-y: auto;
        }

        .file-preview-content.show {
            display: block;
        }

        .file-preview-content pre {
            margin: 0;
            padding: 12px;
            background: #f8f8f8;
            color: #323130;
            font-family: 'Consolas', 'Monaco', 'Courier New', monospace;
            font-size: 12px;
            line-height: 1.5;
            overflow-x: auto;
        }

        .file-preview-line {
            display: flex;
            gap: 10px;
        }

        .file-preview-line-number {
            color: #999;
            text-align: right;
            min-width: 40px;
            user-select: none;
        }

        .file-preview-line-content {
            flex: 1;
        }

        .file-preview-line.highlight {
            background: #264f78;
        }

        .api-link {
            color: #0078d4;
            text-decoration: none;
            font-size: 12px;
            font-family: monospace;
            background: #f3f2f1;
            padding: 4px 8px;
            border-radius: 3px;
            display: inline-block;
            margin-top: 5px;
        }

        .api-link:hover {
            background: #e1dfdd;
            text-decoration: underline;
        }

        /* Reviewer/Author avatars section */
        .avatars-section {
            margin-top: 15px;
            padding: 12px;
            background: #f8f8f8;
            border-radius: 4px;
        }

        .avatars-section h4 {
            margin: 0 0 10px 0;
            font-size: 14px;
            color: #323130;
        }

        .avatars-section .avatars-container {
            gap: 8px;
        }

        .avatars-section .avatar-wrapper {
            --avatar-size: 36px;
        }

        .avatars-section .avatar,
        .avatars-section .avatar-fallback,
        .avatars-section .avatar-placeholder {
            border-width: 2px;
            border-color: #e1dfdd;
        }

        /* Vote badges */
        .vote-badge {
            position: absolute;
            bottom: -3px;
            right: -3px;
            width: 16px;
            height: 16px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 10px;
            font-weight: bold;
            color: white;
            border: 2px solid white;
            z-index: 5;
        }

        .vote-badge.vote-approved {
            background: #107c10;
        }

        .vote-badge.vote-approved-suggestions {
            background: #498205;
        }

        .vote-badge.vote-wait {
            background: #d83b01;
        }

        .vote-badge.vote-rejected {
            background: #a4262c;
        }

        .vote-badge.vote-no-vote {
            background: #8a8886;
        }

        /* Thread count badge */
        .thread-badge {
            position: absolute;
            top: -5px;
            right: -5px;
            min-width: 18px;
            height: 18px;
            border-radius: 9px;
            background: #d83b01;
            color: white;
            font-size: 11px;
            font-weight: bold;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 0 4px;
            border: 2px solid white;
            z-index: 5;
        }

        .avatar-wrapper:hover .vote-badge,
        .avatar-wrapper:hover .thread-badge,
        .avatar-wrapper:hover .author-badge {
            transform: scale(1.15);
            z-index: 11;
        }

        /* PR Author badge */
        .author-badge {
            position: absolute;
            top: -4px;
            left: -4px;
            width: 14px;
            height: 14px;
            border-radius: 50%;
            background: #ffb900;
            color: #323130;
            font-size: 9px;
            display: flex;
            align-items: center;
            justify-content: center;
            border: 1px solid white;
            z-index: 5;
        }

        .comment-author-info .author-badge {
            width: 12px;
            height: 12px;
            font-size: 7px;
            top: -3px;
            left: -3px;
        }

        /* PR title avatar */
        .pr-title-avatar {
            --avatar-size: 28px;
            vertical-align: middle;
            margin-right: 8px;
        }

        /* Checks section */
        .checks-section {
            margin-top: 15px;
            padding: 12px;
            background: #f8f8f8;
            border-radius: 4px;
        }

        .checks-section h4 {
            margin: 0 0 12px 0;
            font-size: 14px;
            color: #323130;
        }

        .checks-loading {
            color: #605e5c;
            font-size: 13px;
        }

        .check-group {
            margin-bottom: 12px;
        }

        .check-group:last-child {
            margin-bottom: 0;
        }

        .check-group-header {
            font-weight: 600;
            font-size: 13px;
            margin-bottom: 6px;
            padding: 4px 8px;
            border-radius: 3px;
            background: #e1dfdd;
            color: #323130;
        }

        .check-group-header.status-indicator-error {
            background: #fde7e9;
            color: #d13438;
        }

        .check-group-header.status-indicator-pending {
            background: #e1f3ff;
            color: #0078d4;
        }

        .check-list {
            list-style: none;
            margin: 0;
            padding: 0;
        }

        .check-item {
            display: flex;
            align-items: flex-start;
            gap: 6px;
            padding: 4px 0;
            font-size: 12px;
            color: #323130;
            border-bottom: 1px solid #edebe9;
        }

        .check-item:last-child {
            border-bottom: none;
        }

        .check-item code {
            font-size: 11px;
            background: #fff;
            padding: 2px 6px;
            border-radius: 3px;
            word-break: break-all;
        }

        .check-item a {
            color: #0078d4;
            text-decoration: none;
        }

        .check-item a:hover {
            text-decoration: underline;
        }

        .check-icon {
            flex-shrink: 0;
            width: 14px;
            text-align: center;
        }

        .check-item.status-indicator-success .check-icon {
            color: #107c10;
        }

        .check-item.status-indicator-error .check-icon {
            color: #d13438;
        }

        .check-item.status-indicator-pending .check-icon {
            color: #0078d4;
        }

        .check-item-note {
            font-size: 12px;
            color: #605e5c;
            font-style: italic;
            padding: 4px 0;
        }

        .check-extra {
            color: #8a6d3b;
            font-size: 11px;
            font-style: italic;
        }
    </style>
</head>
<body>
    <div class="container wide">
        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px;">
            <div>
                <h1 style="font-size: 1.3em; margin: 0;">üí¨ PR Threads Viewer</h1>
            </div>
            <div style="display: flex; gap: 10px;">
                <a href="ado-pr-list.html" style="color: #0078d4; text-decoration: none; font-size: 14px;">üìã PR List</a>
                <a href="index.html" style="color: #0078d4; text-decoration: none; font-size: 14px;">üè† Home</a>
                <a href="ado-settings.html" style="color: #0078d4; text-decoration: none; font-size: 14px;">‚öôÔ∏è Settings</a>
            </div>
        </div>

        <div class="page-layout">
            <!-- Left Sidebar with Filters -->
            <div class="sidebar" id="threadFilters" style="display: none;">
                <div class="resize-handle" id="resizeHandle"></div>
                <h3 style="margin-top: 0; margin-bottom: 20px;">Filters</h3>

                <div class="filter-section">
                    <h4>Thread Status</h4>
                    <div class="status-chips-vertical">
                        <button class="status-chip selected" data-status="active" onclick="toggleStatusChip(this)">Active</button>
                        <button class="status-chip selected" data-status="fixed" onclick="toggleStatusChip(this)">Resolved</button>
                        <button class="status-chip selected" data-status="closed" onclick="toggleStatusChip(this)">Closed</button>
                        <button class="status-chip selected" data-status="wontFix" onclick="toggleStatusChip(this)">Won't Fix</button>
                        <button class="status-chip selected" data-status="pending" onclick="toggleStatusChip(this)">Pending</button>
                        <button class="status-chip" data-status="unknown" onclick="toggleStatusChip(this)">Unknown</button>
                        <button class="status-chip" data-status="noStatus" onclick="toggleStatusChip(this)">No status</button>
                    </div>
                    <label class="checkbox-label">
                        <input type="checkbox" id="showDeleted" onchange="applyThreadFilters()">
                        Show deleted threads
                    </label>
                </div>

                <div class="filter-section">
                    <h4>Thread Author</h4>
                    <select id="threadAuthorFilter" onchange="applyThreadFilters()">
                        <option value="">All authors</option>
                    </select>
                </div>

                <div class="filter-section">
                    <h4>Comments by User</h4>
                    <select id="commentAuthorFilter" onchange="applyThreadFilters()">
                        <option value="">All users</option>
                    </select>
                </div>

                <div class="filter-section">
                    <h4>Search in Comments</h4>
                    <input type="text" id="searchFilter" placeholder="Search text..." oninput="applyThreadFilters()">
                </div>

                <div class="filter-section">
                    <h4>View Options</h4>
                    <button id="viewToggle" onclick="toggleView()" class="btn-secondary" style="width: 100%; margin-bottom: 8px;">
                        Switch to Compact
                    </button>
                    <button id="bulkModeToggle" onclick="toggleBulkMode()" class="btn-secondary" style="width: 100%;">
                        Enable Bulk Selection
                    </button>
                </div>

                <div class="thread-count">
                    Showing <span id="filteredCount">0</span> of <span id="totalCount">0</span> threads
                </div>
            </div>

            <!-- Main Content -->
            <div class="main-content">
                <div id="bulkActions" class="bulk-actions">
                    <strong>Bulk Thread Selection Mode Active</strong>
                    <p style="margin: 10px 0 0 0; font-size: 14px; color: #605e5c;">Select threads using checkboxes, then change their status below. Filters are disabled in bulk mode.</p>
                    <div class="bulk-actions-buttons">
                        <button onclick="selectAllThreads()" class="btn-secondary">Select All</button>
                        <button onclick="deselectAllThreads()" class="btn-secondary">Deselect All</button>
                        <span style="margin-left: 10px; color: #323130;">Selected: <strong id="selectedCount">0</strong> threads</span>
                        <div style="margin-left: auto; display: flex; gap: 10px; align-items: center;">
                            <label for="bulkStatusSelect" style="margin: 0;">Change selected to:</label>
                            <select id="bulkStatusSelect">
                                <option value="">Select status...</option>
                                <option value="active">Active</option>
                                <option value="fixed">Resolved</option>
                                <option value="closed">Closed</option>
                                <option value="wontFix">Won't Fix</option>
                                <option value="pending">Pending</option>
                            </select>
                            <button onclick="applyBulkStatusChange()" class="btn-primary">Apply Changes</button>
                        </div>
                    </div>
                </div>


                <div class="config-section" id="configSection" style="display: none;">
                    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px;">
                        <h3 style="margin: 0;">Configuration</h3>
                    </div>

                    <details id="advancedConfig">
                        <summary style="cursor: pointer; color: #0078d4; font-weight: 600;">üîß Advanced Configuration</summary>
                        <div style="margin-top: 15px;">
                            <div class="form-group">
                                <label for="serverUrl">Azure DevOps Server URL</label>
                                <input type="text" id="serverUrl" placeholder="https://your-ado-server.com" />
                            </div>
                            <div class="form-group">
                                <label for="organization">Organization/Collection</label>
                                <input type="text" id="organization" placeholder="DefaultCollection" />
                            </div>
                            <div class="form-group">
                                <label for="project">Project Name</label>
                                <input type="text" id="project" placeholder="MyProject" />
                            </div>
                            <div class="form-group">
                                <label for="repository">Repository Name</label>
                                <input type="text" id="repository" placeholder="MyRepo" />
                            </div>
                            <div class="form-group">
                                <label for="pat">Personal Access Token (PAT)</label>
                                <input type="password" id="pat" placeholder="Your PAT with Code (Read) permission" />
                            </div>
                        </div>
                    </details>

                    <button id="loadButton" onclick="loadPRThreads()">Load PR Threads</button>
                    <div id="configStatus" style="margin-top: 10px; font-size: 12px; color: #605e5c;"></div>
                </div>

                <div class="results-container">
                    <div id="results"></div>
                </div>
            </div>
        </div>
    </div>

    <script src="common.js"></script>
    <script>
        let currentPRId = null;
        let allThreads = [];
        let allIterations = [];
        let currentPRData = null;
        let currentConfig = null;
        let currentFileChangeStats = null;
        let isCompactView = false;
        let isBulkMode = false;
        let selectedThreadIds = new Set();
        let isRestoringFromURL = false;

        function calculateFileChangeStats(changeEntries) {
            const stats = {
                totalFiles: 0,
                added: 0,
                modified: 0,
                deleted: 0,
                renamed: 0
            };

            changeEntries.forEach(entry => {
                stats.totalFiles++;
                const changeType = entry.changeType;
                // changeType can be: add, edit, delete, rename, etc.
                // It can also be a combination like "edit, rename"
                if (changeType.includes('add')) {
                    stats.added++;
                } else if (changeType.includes('delete')) {
                    stats.deleted++;
                } else if (changeType.includes('rename') && !changeType.includes('edit')) {
                    stats.renamed++;
                } else if (changeType.includes('edit')) {
                    stats.modified++;
                }
            });

            return stats;
        }

        function getLineStatsCacheKey(config, prId, iterationCount) {
            return `line-stats-${config.organization}-${config.project}-${config.repository}-${prId}-${iterationCount}`;
        }

        function getCachedLineStats(cacheKey) {
            try {
                const cached = localStorage.getItem(cacheKey);
                if (cached) {
                    return JSON.parse(cached);
                }
            } catch (e) {
                console.warn('Failed to read line stats cache:', e);
            }
            return null;
        }

        function setCachedLineStats(cacheKey, stats) {
            try {
                localStorage.setItem(cacheKey, JSON.stringify(stats));
            } catch (e) {
                console.warn('Failed to cache line stats:', e);
            }
        }

        function computeLineDiff(oldContent, newContent) {
            // Simple line diff: count added and removed lines
            const oldLines = (oldContent || '').split('\n');
            const newLines = (newContent || '').split('\n');

            // Use a simple LCS-based approach for accuracy
            const oldSet = new Map();
            oldLines.forEach((line, i) => {
                if (!oldSet.has(line)) oldSet.set(line, []);
                oldSet.get(line).push(i);
            });

            let matched = 0;
            const usedOldIndices = new Set();
            newLines.forEach(line => {
                if (oldSet.has(line)) {
                    const indices = oldSet.get(line);
                    for (const idx of indices) {
                        if (!usedOldIndices.has(idx)) {
                            usedOldIndices.add(idx);
                            matched++;
                            break;
                        }
                    }
                }
            });

            const removed = oldLines.length - matched;
            const added = newLines.length - matched;

            return { added, removed };
        }

        async function fetchFileContent(config, path, commitId) {
            try {
                const url = `${config.serverUrl}/${config.organization}/${config.project}/_apis/git/repositories/${config.repository}/items?path=${encodeURIComponent(path)}&versionDescriptor.version=${commitId}&versionDescriptor.versionType=commit&api-version=6.0`;
                const response = await fetch(url, {
                    headers: { 'Authorization': `Basic ${btoa(':' + config.pat)}` }
                });
                if (!response.ok) return null;
                return await response.text();
            } catch (e) {
                return null;
            }
        }

        async function fetchLineStatsViaInternalAPI(config, prData, changes) {
            const baseCommit = prData.lastMergeTargetCommit?.commitId;
            const targetCommit = prData.lastMergeSourceCommit?.commitId;
            const repositoryId = prData.repository?.id;

            if (!baseCommit || !targetCommit || !repositoryId) {
                return null;
            }

            // Get file paths from changes
            const filePaths = changes
                .filter(e => e.item?.path)
                .map(e => e.item.path);

            if (filePaths.length === 0) {
                return { added: 0, removed: 0 };
            }

            // Call internal API
            const diffData = await ADOAPI.getFileDiffs(config, repositoryId, baseCommit, targetCommit, filePaths);
            console.log('Internal API response:', diffData);

            // Parse response and sum line counts
            let added = 0, removed = 0;
            const fileDiffs = diffData?.dataProviders?.['ms.vss-code-web.file-diff-data-provider']?.fileDiffs || [];

            for (const fileDiff of fileDiffs) {
                for (const block of (fileDiff.lineDiffBlocks || [])) {
                    const changeType = block.changeType;
                    // changeType: 0 = none, 1 = add, 2 = delete, 3 = edit (need to verify)
                    if (changeType === 1) {
                        added += block.modifiedLinesCount || 0;
                    } else if (changeType === 2) {
                        removed += block.originalLinesCount || 0;
                    } else if (changeType === 3) {
                        // For edits, count both sides
                        added += block.modifiedLinesCount || 0;
                        removed += block.originalLinesCount || 0;
                    }
                }
            }

            return { added, removed };
        }

        async function fetchLineStatsViaLocalDiff(config, prData, changes) {
            const baseCommit = prData.lastMergeTargetCommit?.commitId;
            const targetCommit = prData.lastMergeSourceCommit?.commitId;

            let totalAdded = 0;
            let totalRemoved = 0;

            // Process files
            for (const change of changes) {
                const path = change.item?.path;
                if (!path) continue;

                const changeType = change.changeType || '';

                if (changeType.includes('add')) {
                    const content = await fetchFileContent(config, path, targetCommit);
                    if (content) {
                        totalAdded += content.split('\n').length;
                    }
                } else if (changeType.includes('delete')) {
                    const content = await fetchFileContent(config, path, baseCommit);
                    if (content) {
                        totalRemoved += content.split('\n').length;
                    }
                } else if (changeType.includes('edit')) {
                    const [oldContent, newContent] = await Promise.all([
                        fetchFileContent(config, path, baseCommit),
                        fetchFileContent(config, path, targetCommit)
                    ]);
                    const diff = computeLineDiff(oldContent, newContent);
                    totalAdded += diff.added;
                    totalRemoved += diff.removed;
                }
            }

            return { added: totalAdded, removed: totalRemoved };
        }

        async function fetchLineStatsAsync(config, prData) {
            const iterationCount = allIterations.length;
            const cacheKey = getLineStatsCacheKey(config, prData.pullRequestId, iterationCount);

            // Check cache first
            const cached = getCachedLineStats(cacheKey);
            if (cached) {
                console.log('Line stats from cache:', cached);
                updateLineStatsDisplay(cached.added, cached.removed);
                return;
            }

            // Need to compute - show loading
            updateLineStatsLoading();

            try {
                const baseCommit = prData.lastMergeTargetCommit?.commitId;
                const targetCommit = prData.lastMergeSourceCommit?.commitId;

                if (!baseCommit || !targetCommit) {
                    hideLineStatsLoading();
                    return;
                }

                // Get the file changes from iteration 1
                const changesData = await ADOAPI.getPRIterationChanges(config, prData.pullRequestId, 1);
                const changes = changesData.changeEntries || [];

                if (changes.length === 0) {
                    updateLineStatsDisplay(0, 0);
                    return;
                }

                let stats = null;

                // Try internal API first
                try {
                    stats = await fetchLineStatsViaInternalAPI(config, prData, changes);
                    if (stats) {
                        console.log('Line stats via internal API:', stats);
                    }
                } catch (e) {
                    console.warn('Internal API failed, falling back to local diff:', e);
                }

                // Fall back to local diff if internal API failed
                if (!stats) {
                    console.log('Using local diff computation...');
                    stats = await fetchLineStatsViaLocalDiff(config, prData, changes);
                    console.log('Line stats via local diff:', stats);
                }

                setCachedLineStats(cacheKey, stats);
                updateLineStatsDisplay(stats.added, stats.removed);

            } catch (e) {
                console.warn('Failed to compute line stats:', e);
                hideLineStatsLoading();
            }
        }

        function hideLineStatsLoading() {
            const container = document.getElementById('lineStatsContainer');
            if (container) {
                container.innerHTML = '';
            }
        }

        function updateLineStatsLoading() {
            const container = document.getElementById('lineStatsContainer');
            if (!container) return;
            container.innerHTML = `
                <div class="stat">
                    <div class="stat-value" style="color: #605e5c; font-size: 12px;">‚è≥</div>
                    <div class="stat-label">Lines...</div>
                </div>
            `;
        }

        function updateLineStatsDisplay(added, removed) {
            const container = document.getElementById('lineStatsContainer');
            if (!container) return;

            container.innerHTML = `
                <div class="stat">
                    <div class="stat-value" style="color: #107c10;">+${added}</div>
                    <div class="stat-label">Lines</div>
                </div>
                <div class="stat">
                    <div class="stat-value" style="color: #a4262c;">-${removed}</div>
                    <div class="stat-label">Lines</div>
                </div>
            `;
        }

        function getActiveThreadCounts(threads) {
            const counts = {};
            threads.forEach(thread => {
                if (thread.isDeleted) return;
                const status = thread.status;
                if (status === 'active' || status === 'Active' || status === 1) {
                    const firstComment = thread.comments && thread.comments[0];
                    const commentType = firstComment?.commentType;
                    // Only count threads with real comments (text type)
                    const isRealComment = commentType === 1 || commentType === 'text';
                    const authorId = firstComment?.author?.id;
                    if (authorId && isRealComment) {
                        counts[authorId] = (counts[authorId] || 0) + 1;
                    }
                }
            });
            return counts;
        }

        function renderAvatarWithBadges(user, vote, threadCount, isPRAuthor = false) {
            const initials = user.displayName.split(' ').map(n => n[0]).join('').substring(0, 2).toUpperCase();
            const displayName = ADOContent.escapeHtml(user.displayName);

            // Vote info
            let voteClass = '';
            let voteText = '';
            let voteIcon = '';
            if (vote !== undefined) {
                switch (vote) {
                    case 10:
                        voteClass = 'vote-approved';
                        voteText = 'Approved';
                        voteIcon = '‚úì';
                        break;
                    case 5:
                        voteClass = 'vote-approved-suggestions';
                        voteText = 'Approved with suggestions';
                        voteIcon = '‚úì';
                        break;
                    case -5:
                        voteClass = 'vote-wait';
                        voteText = 'Waiting for author';
                        voteIcon = '!';
                        break;
                    case -10:
                        voteClass = 'vote-rejected';
                        voteText = 'Rejected';
                        voteIcon = '‚úó';
                        break;
                    default:
                        voteClass = 'vote-no-vote';
                        voteText = 'No vote';
                }
            }

            const title = vote !== undefined ? `${displayName} - ${voteText}` : displayName;

            let avatarHtml;
            if (user.id) {
                const cachedUrl = AvatarLoader.getCached(user.id);
                if (cachedUrl) {
                    avatarHtml = `<img src="${cachedUrl}" alt="${title}" title="${title}" class="avatar">`;
                } else {
                    avatarHtml = `<div class="avatar-placeholder" title="${title}"></div><img data-user-id="${user.id}" alt="${title}" title="${title}" class="avatar avatar-pending">`;
                }
            } else {
                avatarHtml = `<div class="avatar-fallback" title="${title}">${initials}</div>`;
            }

            // Vote badge (bottom-left)
            let voteBadgeHtml = '';
            if (voteIcon) {
                voteBadgeHtml = `<span class="vote-badge ${voteClass}">${voteIcon}</span>`;
            }

            // Thread count badge (top-right)
            let threadBadgeHtml = '';
            if (threadCount && threadCount > 0) {
                threadBadgeHtml = `<span class="thread-badge" title="${threadCount} active thread${threadCount > 1 ? 's' : ''}">${threadCount}</span>`;
            }

            // PR Author badge (top-left)
            let authorBadgeHtml = '';
            if (isPRAuthor) {
                authorBadgeHtml = `<span class="author-badge" title="PR Author">‚òÖ</span>`;
            }

            return `<div class="avatar-wrapper" data-user-id="${user.id || ''}">${avatarHtml}${voteBadgeHtml}${threadBadgeHtml}${authorBadgeHtml}</div>`;
        }

        function renderReviewersSection(reviewers, threadCounts, prAuthorId) {
            if (!reviewers || reviewers.length === 0) {
                return '';
            }

            // Separate required and optional reviewers
            const requiredReviewers = reviewers.filter(r => r.isRequired);
            const optionalReviewers = reviewers.filter(r => !r.isRequired);

            let html = '';

            if (requiredReviewers.length > 0) {
                const requiredAvatarsHtml = requiredReviewers.map(r => {
                    const count = threadCounts[r.id] || 0;
                    return renderAvatarWithBadges(r, r.vote, count, r.id === prAuthorId);
                }).join('');

                html += `
                    <div class="avatars-section">
                        <h4>Required Reviewers</h4>
                        <div class="avatars-container">${requiredAvatarsHtml}</div>
                    </div>
                `;
            }

            if (optionalReviewers.length > 0) {
                const optionalAvatarsHtml = optionalReviewers.map(r => {
                    const count = threadCounts[r.id] || 0;
                    return renderAvatarWithBadges(r, r.vote, count, r.id === prAuthorId);
                }).join('');

                html += `
                    <div class="avatars-section">
                        <h4>Optional Reviewers</h4>
                        <div class="avatars-container">${optionalAvatarsHtml}</div>
                    </div>
                `;
            }

            return html;
        }

        function renderOtherAuthorsSection(threads, reviewers, threadCounts, prAuthorId) {
            // Get all unique thread authors who are not reviewers
            // Only include authors with at least one "real" comment (not system/codeChange)
            const reviewerIds = new Set((reviewers || []).map(r => r.id));
            const otherAuthors = new Map();

            threads.forEach(thread => {
                if (thread.isDeleted) return;
                const firstComment = thread.comments && thread.comments[0];
                const author = firstComment?.author;
                const commentType = firstComment?.commentType;

                // Skip system (3/'system') and codeChange (2/'codeChange') comments
                const isRealComment = commentType === 1 || commentType === 'text';

                if (author && author.id && isRealComment && !reviewerIds.has(author.id) && !otherAuthors.has(author.id)) {
                    otherAuthors.set(author.id, author);
                }
            });

            if (otherAuthors.size === 0) {
                return '';
            }

            const avatarsHtml = Array.from(otherAuthors.values()).map(author => {
                const count = threadCounts[author.id] || 0;
                return renderAvatarWithBadges(author, undefined, count, author.id === prAuthorId);
            }).join('');

            return `
                <div class="avatars-section">
                    <h4>Other Thread Authors</h4>
                    <div class="avatars-container">${avatarsHtml}</div>
                </div>
            `;
        }

        // Checks (statuses, policies, conflicts) caching
        let prChecksData = null;

        async function fetchPRChecks(config, prData) {
            const projectId = prData.repository?.project?.id || config.project;
            prChecksData = await ChecksFormatter.fetchPRChecks(
                config,
                config.project,
                config.repository,
                prData.pullRequestId,
                projectId,
                prData.mergeStatus
            );
            updateChecksDisplay();
        }

        function updateChecksDisplay() {
            const container = document.getElementById('checksSection');
            if (!container) return;

            container.innerHTML = renderChecksSection();
        }

        // Use shared utilities from common.js
        const getStatusIcon = ChecksFormatter.getIcon.bind(ChecksFormatter);
        const getStatusClass = ChecksFormatter.getClass.bind(ChecksFormatter);

        function renderChecksSection() {
            if (!prChecksData) {
                return `
                    <div class="checks-section">
                        <h4>Checks</h4>
                        <div class="checks-loading">Loading...</div>
                    </div>
                `;
            }

            const sections = [];
            const { statuses, policies, conflicts, mergeStatus } = prChecksData;

            // Merge conflicts section
            if (mergeStatus === 'conflicts') {
                let conflictHtml = '<div class="check-group"><div class="check-group-header status-indicator-error">‚ö†Ô∏è Merge Conflicts</div>';
                if (conflicts.length > 0) {
                    conflictHtml += '<ul class="check-list">';
                    conflicts.forEach(c => {
                        const path = c.conflictPath || c.filePath || c.sourceFilePath || c.targetFilePath || c.path || 'Unknown file';
                        conflictHtml += `<li class="check-item"><code>${ADOContent.escapeHtml(path)}</code></li>`;
                    });
                    conflictHtml += '</ul>';
                } else {
                    conflictHtml += '<div class="check-item-note">Unable to load conflict details</div>';
                }
                conflictHtml += '</div>';
                sections.push(conflictHtml);
            } else if (mergeStatus && mergeStatus !== 'succeeded' && mergeStatus !== 'notSet') {
                // Other merge issues
                let mergeText = '';
                switch (mergeStatus) {
                    case 'rejectedByPolicy': mergeText = 'üö´ Rejected by policy'; break;
                    case 'queued': mergeText = '‚è≥ Merge queued'; break;
                    case 'failure': mergeText = '‚ùå Merge failed'; break;
                }
                if (mergeText) {
                    sections.push(`<div class="check-group"><div class="check-group-header ${getStatusClass(mergeStatus)}">${mergeText}</div></div>`);
                }
            }

            // Pipeline/Status checks section
            if (statuses.length > 0) {
                // Group by latest status per context (pipeline may have multiple runs)
                const latestStatuses = new Map();
                statuses.forEach(s => {
                    const key = s.context?.name || s.description || 'Unknown';
                    const existing = latestStatuses.get(key);
                    if (!existing || new Date(s.creationDate) > new Date(existing.creationDate)) {
                        latestStatuses.set(key, s);
                    }
                });

                const statusList = Array.from(latestStatuses.values());
                const failed = statusList.filter(s => s.state === 'failed' || s.state === 'error');
                const pending = statusList.filter(s => s.state === 'pending');
                const succeeded = statusList.filter(s => s.state === 'succeeded');

                let checksHtml = '<div class="check-group"><div class="check-group-header">Pipeline Checks</div><ul class="check-list">';

                // Show failed first, then pending, then succeeded
                [...failed, ...pending, ...succeeded].forEach(s => {
                    const name = s.context?.name || s.description || 'Unknown check';
                    const icon = getStatusIcon(s.state);
                    const cls = getStatusClass(s.state);
                    const desc = s.description ? ` - ${ADOContent.escapeHtml(s.description)}` : '';

                    if (s.targetUrl) {
                        checksHtml += `<li class="check-item ${cls}"><span class="check-icon">${icon}</span> <a href="${ADOContent.escapeHtml(s.targetUrl)}" target="_blank" rel="noopener">${ADOContent.escapeHtml(name)}</a>${desc}</li>`;
                    } else {
                        checksHtml += `<li class="check-item ${cls}"><span class="check-icon">${icon}</span> ${ADOContent.escapeHtml(name)}${desc}</li>`;
                    }
                });

                checksHtml += '</ul></div>';
                sections.push(checksHtml);
            }

            // Policy evaluations section
            if (policies.length > 0) {
                const rejected = policies.filter(e => e.status === 'rejected');
                const running = policies.filter(e => e.status === 'running' || e.status === 'queued');
                const approved = policies.filter(e => e.status === 'approved');

                let policyHtml = '<div class="check-group"><div class="check-group-header">Policies</div><ul class="check-list">';

                // Show rejected first, then running, then approved
                [...rejected, ...running, ...approved].forEach(p => {
                    const icon = getStatusIcon(p.status);
                    const cls = getStatusClass(p.status);
                    const { label, extra } = ChecksFormatter.formatPolicy(p);
                    const extraHtml = extra ? ` <span class="check-extra">${extra}</span>` : '';

                    policyHtml += `<li class="check-item ${cls}"><span class="check-icon">${icon}</span> ${ADOContent.escapeHtml(label)}${extraHtml}</li>`;
                });

                policyHtml += '</ul></div>';
                sections.push(policyHtml);
            }

            if (sections.length === 0) {
                return '';
            }

            return `
                <div class="checks-section">
                    <h4>Checks</h4>
                    ${sections.join('')}
                </div>
            `;
        }

        // Parse URL parameters on load
        window.addEventListener('DOMContentLoaded', () => {
            const urlParams = ADOURL.getParams();
            currentPRId = urlParams.get('prId') || urlParams.get('id');

            // Load saved configuration from localStorage
            const savedConfig = ADOConfig.get();
            if (savedConfig) {
                document.getElementById('serverUrl').value = savedConfig.serverUrl || '';
                document.getElementById('organization').value = savedConfig.organization || '';
                document.getElementById('project').value = savedConfig.project || '';
                document.getElementById('repository').value = savedConfig.repository || '';
                document.getElementById('pat').value = savedConfig.pat || '';
            }

            // Auto-load or show config
            if (currentPRId) {
                // Auto-load if config is valid
                if (savedConfig && ADOConfig.isValid(savedConfig) && savedConfig.repository) {
                    setTimeout(() => loadPRThreads(), 100);
                } else {
                    // Show config section if settings are missing
                    document.getElementById('configSection').style.display = 'block';
                    const statusDiv = document.getElementById('configStatus');
                    statusDiv.innerHTML = '‚ö†Ô∏è Some settings are missing. <a href="ado-settings.html" style="color: #0078d4;">Configure in Settings</a> or use Advanced Configuration below.';
                    statusDiv.style.color = '#8a6d3b';
                }
            } else {
                showNoPRError();
            }
        });

        function showNoPRError() {
            document.getElementById('results').innerHTML = `
                <div class="warning">
                    <strong>‚ö†Ô∏è No Pull Request specified</strong><br>
                    Please navigate from the <a href="ado-pr-list.html" style="color: #0078d4; font-weight: 600;">PR List page</a>
                    or provide a PR ID in the URL (e.g., ?prId=123).
                </div>
            `;
        }

        // URL parameter helpers
        function getURLParams() {
            const params = new URLSearchParams(window.location.search);
            const statusParam = params.get('status');
            return {
                prId: params.get('prId') || params.get('id') || null,
                status: statusParam ? (statusParam === 'none' ? [] : statusParam.split(',')) : null,
                showDeleted: params.get('showDeleted') !== null ? params.get('showDeleted') === 'true' : null,
                author: params.get('author') || null,
                commentAuthor: params.get('commentAuthor') || null,
                search: params.get('search') || null,
                view: params.get('view') || null
            };
        }

        function updateURL() {
            if (isRestoringFromURL) return;

            const params = new URLSearchParams();

            // PR ID
            if (currentPRId) {
                params.set('prId', currentPRId);
            }

            // Thread status filters
            // Always include status parameter to preserve chip selection state (even if none selected)
            const selectedStatuses = getSelectedThreadStatuses();
            params.set('status', selectedStatuses.length > 0 ? selectedStatuses.join(',') : 'none');

            // Show deleted checkbox
            const showDeleted = document.getElementById('showDeleted').checked;
            if (showDeleted) {  // Only add to URL if checked (default is unchecked)
                params.set('showDeleted', 'true');
            }

            // Author filter
            const author = document.getElementById('threadAuthorFilter').value;
            if (author) {
                params.set('author', author);
            }

            // Comment author filter
            const commentAuthor = document.getElementById('commentAuthorFilter').value;
            if (commentAuthor) {
                params.set('commentAuthor', commentAuthor);
            }

            // Search filter
            const search = document.getElementById('searchFilter').value.trim();
            if (search) {
                params.set('search', search);
            }

            // View mode
            if (isCompactView) {  // Only add to URL if compact (default is detailed)
                params.set('view', 'compact');
            }

            const newURL = params.toString() ? `${window.location.pathname}?${params.toString()}` : window.location.pathname;
            history.replaceState(null, '', newURL);
        }

        function restoreFiltersFromURL() {
            const urlParams = getURLParams();
            isRestoringFromURL = true;

            try {
                // Restore status chips
                // If status param exists in URL (even if empty/none), restore that selection
                // If status param is missing, keep HTML defaults
                if (urlParams.status !== null) {
                    // First deselect all status chips
                    document.querySelectorAll('.sidebar .status-chip').forEach(chip => {
                        chip.classList.remove('selected');
                    });

                    // Then select only the ones in the URL (if any)
                    urlParams.status.forEach(status => {
                        const chip = document.querySelector(`.sidebar .status-chip[data-status="${status}"]`);
                        if (chip) {
                            chip.classList.add('selected');
                        }
                    });
                }

                // Restore showDeleted checkbox
                if (urlParams.showDeleted !== null) {
                    document.getElementById('showDeleted').checked = urlParams.showDeleted;
                }

                // Restore author filter
                if (urlParams.author) {
                    const authorSelect = document.getElementById('threadAuthorFilter');
                    // Check if the option exists (it might not be populated yet)
                    const option = Array.from(authorSelect.options).find(opt => opt.value === urlParams.author);
                    if (option) {
                        authorSelect.value = urlParams.author;
                    }
                }

                // Restore comment author filter
                if (urlParams.commentAuthor) {
                    const commentAuthorSelect = document.getElementById('commentAuthorFilter');
                    const option = Array.from(commentAuthorSelect.options).find(opt => opt.value === urlParams.commentAuthor);
                    if (option) {
                        commentAuthorSelect.value = urlParams.commentAuthor;
                    }
                }

                // Restore search filter
                if (urlParams.search) {
                    document.getElementById('searchFilter').value = urlParams.search;
                }

                // Restore view mode
                if (urlParams.view === 'compact' && !isCompactView) {
                    toggleView();
                }
            } finally {
                isRestoringFromURL = false;
            }

            // Apply filters to show the filtered results
            applyThreadFilters();
        }

        async function loadPRThreads() {
            const config = ADOConfig.getFromForm({});

            // Validation
            if (!currentPRId) {
                showNoPRError();
                return;
            }

            if (!ADOConfig.isValid(config) || !config.repository) {
                ADOUI.showError('results', 'Please fill in all fields. Missing fields can be configured in Settings or in Advanced Configuration below.');
                document.getElementById('configSection').style.display = 'block';
                return;
            }

            // Save configuration
            ADOConfig.save(config);

            ADOUI.showLoading('results', 'Loading PR threads...');

            // Reset checks data for new PR
            prChecksData = null;

            try {
                // Fetch PR details, threads, and iterations in parallel
                const [prData, threadsData, iterationsData] = await Promise.all([
                    ADOAPI.getPR(config, currentPRId),
                    ADOAPI.getPRThreads(config, currentPRId),
                    ADOAPI.getPRIterations(config, currentPRId)
                ]);

                allThreads = threadsData.value || [];
                allIterations = iterationsData.value || [];
                currentPRData = prData;
                currentConfig = config;

                // Fetch file change stats from the first iteration (shows all changes from base)
                let fileChangeStats = null;
                if (allIterations.length > 0) {
                    try {
                        const changesData = await ADOAPI.getPRIterationChanges(config, currentPRId, 1);
                        fileChangeStats = calculateFileChangeStats(changesData.changeEntries || []);
                    } catch (e) {
                        console.warn('Failed to fetch file change stats:', e);
                    }
                }
                currentFileChangeStats = fileChangeStats;

                // Debug: Log unique status values found in threads
                const uniqueStatuses = new Set(allThreads.map(t => t.status));
                console.log('Loaded threads. Unique status values found:', Array.from(uniqueStatuses));
                console.log('Sample threads with their statuses:', allThreads.slice(0, 5).map(t => ({ id: t.id, status: t.status })));

                // Collect and resolve identities
                await ADOIdentity.collectAndResolveFromThreads(allThreads, config.serverUrl, config.organization, config.pat);

                // Show filters
                document.getElementById('threadFilters').style.display = 'block';

                // Populate author filter
                populateAuthorFilter();

                // Restore filters from URL (if any) and apply
                restoreFiltersFromURL();

            } catch (error) {
                ADOUI.showError('results', error.message);
            }
        }

        function populateAuthorFilter() {
            const threadAuthorFilter = document.getElementById('threadAuthorFilter');
            const commentAuthorFilter = document.getElementById('commentAuthorFilter');
            const threadAuthors = new Set();
            const allCommentAuthors = new Set();

            allThreads.forEach(thread => {
                if (thread.comments && thread.comments.length > 0) {
                    // Collect first comment authors for thread author filter
                    const firstComment = thread.comments[0];
                    if (firstComment.author && firstComment.author.displayName) {
                        threadAuthors.add(firstComment.author.displayName);
                    }

                    // Collect all comment authors for comment author filter
                    thread.comments.forEach(comment => {
                        if (comment.author && comment.author.displayName) {
                            allCommentAuthors.add(comment.author.displayName);
                        }
                    });
                }
            });

            // Populate thread author filter
            let threadAuthorHtml = '<option value="">All authors</option>';
            Array.from(threadAuthors).sort().forEach(author => {
                threadAuthorHtml += `<option value="${ADOContent.escapeHtml(author)}">${ADOContent.escapeHtml(author)}</option>`;
            });
            threadAuthorFilter.innerHTML = threadAuthorHtml;

            // Populate comment author filter
            let commentAuthorHtml = '<option value="">All users</option>';
            Array.from(allCommentAuthors).sort().forEach(author => {
                commentAuthorHtml += `<option value="${ADOContent.escapeHtml(author)}">${ADOContent.escapeHtml(author)}</option>`;
            });
            commentAuthorFilter.innerHTML = commentAuthorHtml;
        }

        function applyThreadFilters() {
            const showDeleted = document.getElementById('showDeleted').checked;
            const selectedStatuses = getSelectedThreadStatuses();
            const selectedAuthor = document.getElementById('threadAuthorFilter').value;
            const selectedCommentAuthor = document.getElementById('commentAuthorFilter').value;
            const searchText = document.getElementById('searchFilter').value.trim();

            const filtered = allThreads.filter(thread => {
                // Deleted filter
                if (!showDeleted && thread.isDeleted === true) {
                    return false;
                }

                // Status filter
                // Distinguish between undefined (no status) and "unknown" (actual status value)
                if (selectedStatuses.length > 0) {
                    if (thread.status === undefined) {
                        // Thread has no status field
                        if (!selectedStatuses.includes('noStatus')) {
                            return false;
                        }
                    } else {
                        // Thread has a status field
                        // Lowercase both the thread status and selected statuses for comparison
                        // (selectedStatuses contains camelCase values like 'wontFix', 'active', etc.)
                        const status = thread.status.toLowerCase();
                        const selectedStatusesLower = selectedStatuses.map(s => s.toLowerCase());
                        if (!selectedStatusesLower.includes(status)) {
                            return false;
                        }
                    }
                }

                // Author filter (first comment author)
                if (selectedAuthor) {
                    if (!thread.comments || thread.comments.length === 0) {
                        return false;
                    }
                    const firstComment = thread.comments[0];
                    if (!firstComment.author || firstComment.author.displayName !== selectedAuthor) {
                        return false;
                    }
                }

                // Comment author filter (any comment from selected user)
                if (selectedCommentAuthor) {
                    if (!thread.comments || thread.comments.length === 0) {
                        return false;
                    }
                    const hasCommentFromUser = thread.comments.some(comment =>
                        comment.author && comment.author.displayName === selectedCommentAuthor
                    );
                    if (!hasCommentFromUser) {
                        return false;
                    }
                }

                // Search filter (search in all comment content)
                if (searchText) {
                    if (!thread.comments || thread.comments.length === 0) {
                        return false;
                    }
                    const searchLower = searchText.toLowerCase();
                    const hasMatchingContent = thread.comments.some(comment =>
                        comment.content && comment.content.toLowerCase().includes(searchLower)
                    );
                    if (!hasMatchingContent) {
                        return false;
                    }
                }

                return true;
            });

            // Update counts
            document.getElementById('totalCount').textContent = allThreads.length;
            document.getElementById('filteredCount').textContent = filtered.length;

            // Display filtered threads
            displayResults(currentPRData, filtered, allIterations, currentConfig);

            // Update URL with current filter state
            updateURL();
        }

        function toggleStatusChip(button) {
            button.classList.toggle('selected');
            applyThreadFilters();
        }

        function getSelectedThreadStatuses() {
            const selectedChips = document.querySelectorAll('.sidebar .status-chip.selected');
            return Array.from(selectedChips).map(chip => {
                // Return original camelCase value (e.g., 'wontFix', 'noStatus', 'active')
                // This preserves the exact data-status attribute value for URL persistence
                return chip.dataset.status;
            });
        }

        function toggleView() {
            isCompactView = !isCompactView;
            const button = document.getElementById('viewToggle');
            button.textContent = isCompactView ? 'Switch to Detailed' : 'Switch to Compact';

            // Re-apply filters to refresh display
            applyThreadFilters();
        }

        function toggleBulkMode() {
            isBulkMode = !isBulkMode;
            selectedThreadIds.clear();

            const button = document.getElementById('bulkModeToggle');
            const bulkActions = document.getElementById('bulkActions');
            const filters = document.querySelectorAll('.sidebar .filter-section');

            if (isBulkMode) {
                button.textContent = 'Disable Bulk Selection';
                button.classList.remove('btn-secondary');
                button.classList.add('btn-primary');
                bulkActions.classList.add('show');

                // Disable filters in bulk mode
                filters.forEach(row => {
                    const inputs = row.querySelectorAll('input, select');
                    inputs.forEach(input => input.disabled = true);
                });
            } else {
                button.textContent = 'Enable Bulk Selection';
                button.classList.remove('btn-primary');
                button.classList.add('btn-secondary');
                bulkActions.classList.remove('show');

                // Enable filters
                filters.forEach(row => {
                    const inputs = row.querySelectorAll('input, select');
                    inputs.forEach(input => input.disabled = false);
                });
            }

            // Refresh display to show/hide checkboxes
            applyThreadFilters();
        }

        function toggleThreadSelection(threadId) {
            if (selectedThreadIds.has(threadId)) {
                selectedThreadIds.delete(threadId);
            } else {
                selectedThreadIds.add(threadId);
            }

            // Update selected count
            document.getElementById('selectedCount').textContent = selectedThreadIds.size;

            // Update checkbox state
            const checkbox = document.getElementById(`thread-checkbox-${threadId}`);
            if (checkbox) {
                checkbox.checked = selectedThreadIds.has(threadId);
            }
        }

        function selectAllThreads() {
            selectedThreadIds.clear();

            // Get all visible thread IDs
            const checkboxes = document.querySelectorAll('.thread-checkbox');
            checkboxes.forEach(checkbox => {
                const threadId = checkbox.dataset.threadId;
                selectedThreadIds.add(threadId);
                checkbox.checked = true;
            });

            document.getElementById('selectedCount').textContent = selectedThreadIds.size;
        }

        function deselectAllThreads() {
            selectedThreadIds.clear();

            const checkboxes = document.querySelectorAll('.thread-checkbox');
            checkboxes.forEach(checkbox => {
                checkbox.checked = false;
            });

            document.getElementById('selectedCount').textContent = 0;
        }

        async function changeThreadStatus(threadId, newStatus) {
            if (!currentConfig || !currentPRId || !newStatus) return;

            try {
                console.log(`Attempting to change thread ${threadId} status to: ${newStatus}`);
                const updatedThread = await ADOAPI.updateThreadStatus(currentConfig, currentPRId, threadId, newStatus);
                console.log(`API returned status:`, updatedThread.status);
                console.log(`Full updated thread:`, updatedThread);

                // Update local thread data with response from API
                // Note: threadId from onclick is a string, but thread.id is a number
                const thread = allThreads.find(t => t.id == threadId);
                if (thread && updatedThread) {
                    const oldStatus = thread.status;
                    thread.status = updatedThread.status;
                    thread.properties = updatedThread.properties;
                    console.log(`Updated local thread from ${oldStatus} to ${thread.status}`);
                } else {
                    console.warn(`Could not find thread ${threadId} in allThreads to update locally`);
                }

                // Refresh display to show updated badge
                applyThreadFilters();

                return true;
            } catch (error) {
                console.error(`Failed to update thread status:`, error);
                alert(`Failed to update thread status: ${error.message}\n\nNote: This requires a PAT with "Code (Write)" permissions.`);
                return false;
            }
        }

        async function removeThreadStatus(threadId) {
            if (!currentConfig || !currentPRId) return;

            const confirmed = confirm('Are you sure you want to remove the status from this thread?');
            if (!confirmed) return;

            try {
                console.log(`Attempting to remove status from thread ${threadId}`);
                const updatedThread = await ADOAPI.removeThreadStatus(currentConfig, currentPRId, threadId);
                console.log(`API returned after removing status:`, updatedThread);

                // Update local thread data with response from API
                // Note: threadId from onclick is a string, but thread.id is a number
                const thread = allThreads.find(t => t.id == threadId);
                if (thread && updatedThread) {
                    thread.status = updatedThread.status;
                    thread.properties = updatedThread.properties;
                    console.log(`Removed status from thread, new status:`, thread.status);
                } else {
                    console.warn(`Could not find thread ${threadId} in allThreads to update locally`);
                }

                // Refresh display
                applyThreadFilters();

                return true;
            } catch (error) {
                console.error(`Failed to remove thread status:`, error);
                alert(`Failed to remove thread status: ${error.message}\n\nNote: This requires a PAT with "Code (Write)" permissions.`);
                return false;
            }
        }

        async function applyBulkStatusChange() {
            const newStatus = document.getElementById('bulkStatusSelect').value;

            if (!newStatus) {
                alert('Please select a status to apply.');
                return;
            }

            if (selectedThreadIds.size === 0) {
                alert('Please select at least one thread.');
                return;
            }

            const statusLabels = {
                'active': 'Active',
                'fixed': 'Resolved',
                'closed': 'Closed',
                'wontFix': "Won't Fix",
                'pending': 'Pending'
            };
            const statusLabel = statusLabels[newStatus] || newStatus;

            const confirmed = confirm(`Are you sure you want to change ${selectedThreadIds.size} thread(s) to "${statusLabel}"?`);
            if (!confirmed) return;

            ADOUI.showLoading('results', `Updating ${selectedThreadIds.size} thread(s)...`);

            let successCount = 0;
            let failCount = 0;

            for (const threadId of selectedThreadIds) {
                const success = await changeThreadStatus(threadId, newStatus);
                if (success) {
                    successCount++;
                } else {
                    failCount++;
                }
            }

            // Clear selection and refresh
            selectedThreadIds.clear();
            document.getElementById('selectedCount').textContent = 0;
            document.getElementById('bulkStatusSelect').value = '';

            applyThreadFilters();

            if (failCount === 0) {
                alert(`Successfully updated ${successCount} thread(s).`);
            } else {
                alert(`Updated ${successCount} thread(s) successfully.\n${failCount} thread(s) failed to update.`);
            }
        }

        function getIterationLinksForComment(comment, thread, iterations, config, prData, filePath) {
            const commentId = comment.id;
            const discussionId = thread.id;

            if (!iterations || iterations.length === 0) {
                return { beforeLink: null, afterLink: null, completeLink: null };
            }

            const sortedIterations = [...iterations].sort((a, b) =>
                new Date(a.createdDate) - new Date(b.createdDate)
            );

            const commentTime = new Date(comment.publishedDate);

            // Find last iteration before comment
            let lastBeforeIndex = -1;
            for (let i = sortedIterations.length - 1; i >= 0; i--) {
                if (new Date(sortedIterations[i].createdDate) < commentTime) {
                    lastBeforeIndex = i;
                    break;
                }
            }

            // Find first iteration after comment
            let firstAfterIndex = -1;
            for (let i = 0; i < sortedIterations.length; i++) {
                if (new Date(sortedIterations[i].createdDate) > commentTime) {
                    firstAfterIndex = i;
                    break;
                }
            }

            const latestIteration = sortedIterations[sortedIterations.length - 1];

            let beforeLink = null;
            let afterLink = null;
            let completeLink = null;

            const baseUrl = `${config.serverUrl}/${config.organization}/${config.project}/_git/${config.repository}/pullrequest/${prData.pullRequestId}`;
            const pathParam = filePath ? `&path=${encodeURIComponent(filePath)}` : '';
            const commentParams = `&discussionId=${discussionId}&commentId=${commentId}`;

            if (lastBeforeIndex >= 0) {
                const baseIteration = 0;
                const targetIteration = sortedIterations[lastBeforeIndex].id;
                beforeLink = `${baseUrl}?_a=files${pathParam}&iteration=${targetIteration}&base=${baseIteration}${commentParams}`;
            }

            if (firstAfterIndex >= 0) {
                const baseIteration = sortedIterations[firstAfterIndex].id - 1;
                const targetIteration = latestIteration.id;
                afterLink = `${baseUrl}?_a=files${pathParam}&iteration=${targetIteration}&base=${baseIteration}${commentParams}`;
            }

            const baseIteration = 0;
            const targetIteration = latestIteration.id;
            completeLink = `${baseUrl}?_a=files${pathParam}&iteration=${targetIteration}&base=${baseIteration}${commentParams}`;

            return { beforeLink, afterLink, completeLink };
        }

        async function renderCodeSuggestion(thread, comment) {
            console.log('renderCodeSuggestion called for thread:', thread.id);

            // Extract suggestion from comment content
            const suggestionMatch = comment.content?.match(/```suggestion\n([\s\S]*?)\n```/);
            if (!suggestionMatch) {
                console.log('No suggestion match found in comment content');
                return null;
            }

            const suggestion = suggestionMatch[1];
            console.log('Found suggestion:', suggestion);

            const ctx = thread.threadContext;

            // For code suggestions, we use rightFileStart (the target/new code location)
            // leftFileStart is only for diffs that show both old and new code
            if (!ctx || !ctx.rightFileStart || !currentConfig || !thread.pullRequestThreadContext) {
                console.log('Missing required context:', {
                    hasCtx: !!ctx,
                    hasRightFileStart: !!ctx?.rightFileStart,
                    hasLeftFileStart: !!ctx?.leftFileStart,
                    hasCurrentConfig: !!currentConfig,
                    hasPullRequestThreadContext: !!thread.pullRequestThreadContext
                });
                return null;
            }

            try {
                console.log('Fetching file content for code suggestion...');
                // Get the iteration to fetch the original code
                const iterationId = thread.pullRequestThreadContext.iterationContext?.secondComparingIteration;
                let iteration;

                if (iterationId !== null && iterationId !== undefined) {
                    iteration = allIterations.find(it => it.id === iterationId);
                }

                if (!iteration) {
                    iteration = allIterations[allIterations.length - 1];
                }

                const commitId = iteration?.sourceRefCommit?.commitId || currentPRData.lastMergeSourceCommit?.commitId;
                if (!commitId) {
                    throw new Error('Could not determine commit version');
                }

                // Fetch the file content
                const fileContent = await ADOAPI.getFileContent(currentConfig, ctx.filePath, {
                    version: commitId,
                    versionType: 'commit'
                });

                // Extract the original lines and character offsets
                // For code suggestions, use rightFileStart (the location in the new/target code)
                const lines = fileContent.split('\n');
                const startLine = ctx.rightFileStart.line;
                const endLine = ctx.rightFileEnd ? ctx.rightFileEnd.line : startLine;
                const startOffset = ctx.rightFileStart.offset || 0;
                const endOffset = ctx.rightFileEnd?.offset || 0;

                // Adjust offsets (ADO uses 1-based, JavaScript uses 0-based)
                const adjustedStartOffset = Math.max(0, startOffset - 1);
                const adjustedEndOffset = Math.max(0, endOffset - 1);

                console.log(`Extracting lines ${startLine}-${endLine} with offsets ${startOffset}-${endOffset} from file`);

                // Extract the full original lines
                const fullOriginalLines = lines.slice(startLine - 1, endLine).join('\n');

                // Extract the portion being changed (using character offsets)
                let originalChangedText = '';
                let prefixText = '';
                let suffixText = '';

                if (startLine === endLine) {
                    // Single line change
                    const line = lines[startLine - 1] || '';
                    prefixText = line.substring(0, adjustedStartOffset);
                    originalChangedText = line.substring(adjustedStartOffset, adjustedEndOffset);
                    suffixText = line.substring(adjustedEndOffset);
                } else {
                    // Multi-line change
                    const firstLine = lines[startLine - 1] || '';
                    const lastLine = lines[endLine - 1] || '';
                    const middleLines = lines.slice(startLine, endLine - 1);

                    prefixText = firstLine.substring(0, adjustedStartOffset);
                    originalChangedText = firstLine.substring(adjustedStartOffset);
                    if (middleLines.length > 0) {
                        originalChangedText += '\n' + middleLines.join('\n');
                    }
                    originalChangedText += '\n' + lastLine.substring(0, adjustedEndOffset);
                    suffixText = lastLine.substring(adjustedEndOffset);
                }

                // Build the diff view (light theme) with full line context
                let html = '<div style="background: #f8f8f8; color: #323130; padding: 12px; margin-top: 8px; border-radius: 4px; border: 1px solid #d1d1d1; font-family: \'Consolas\', \'Monaco\', \'Courier New\', monospace; font-size: 12px;">';
                html += '<div style="color: #8a6d3b; font-weight: 600; margin-bottom: 8px;">üí° Code change suggestion</div>';
                html += '<div style="border: 1px solid #d1d1d1; border-radius: 4px; overflow: hidden; background: white;">';

                // Original line(s) with changed part highlighted
                const originalWithHighlight = ADOContent.escapeHtml(prefixText) +
                    `<strong style="background: #ffc0cb; font-weight: 700;">${ADOContent.escapeHtml(originalChangedText)}</strong>` +
                    ADOContent.escapeHtml(suffixText);

                const originalLinesArray = originalWithHighlight.split('\n');
                originalLinesArray.forEach(line => {
                    html += `<div style="background: #ffeef0; padding: 2px 8px; border-left: 2px solid #d73a49;"><span style="color: #d73a49; font-weight: 600;">- </span>${line}</div>`;
                });

                // Suggested line(s) with changed part highlighted
                const suggestedWithHighlight = ADOContent.escapeHtml(prefixText) +
                    `<strong style="background: #c3f0c8; font-weight: 700;">${ADOContent.escapeHtml(suggestion)}</strong>` +
                    ADOContent.escapeHtml(suffixText);

                const suggestedLinesArray = suggestedWithHighlight.split('\n');
                suggestedLinesArray.forEach(line => {
                    html += `<div style="background: #e6ffed; padding: 2px 8px; border-left: 2px solid #28a745;"><span style="color: #28a745; font-weight: 600;">+ </span>${line}</div>`;
                });

                html += '</div></div>';
                return html;
            } catch (error) {
                console.error('Failed to render code suggestion:', error);
                return `<div style="background: #f8f8f8; color: #323130; padding: 12px; margin-top: 8px; border-radius: 4px; border: 1px solid #d1d1d1; font-family: 'Consolas', 'Monaco', 'Courier New', monospace; font-size: 12px;">
                    <div style="color: #8a6d3b; font-weight: 600; margin-bottom: 8px;">üí° Code change suggestion</div>
                    <div style="color: #605e5c; font-size: 11px;">Could not load suggestion details. Click the iteration links above or "View in ADO" to see the code diff.</div>
                </div>`;
            }
        }

        async function toggleFilePreview(threadId, filePath, startLine, endLine, firstIterationId, secondIterationId, startOffset, endOffset, useRight = true) {
            const previewDiv = document.getElementById(`file-preview-${threadId}`);
            const headerDiv = previewDiv.previousElementSibling;
            const arrow = headerDiv.querySelector('span:first-child');
            const label = headerDiv.querySelector('span:last-child');

            if (previewDiv.classList.contains('show')) {
                // Collapse
                previewDiv.classList.remove('show');
                arrow.textContent = '‚ñ∂';
                // Keep the label as is when collapsed
            } else {
                // Expand
                previewDiv.classList.add('show');
                arrow.textContent = '‚ñº';

                // Load content if not already loaded
                if (!previewDiv.hasAttribute('data-loaded')) {
                    previewDiv.innerHTML = '<div style="padding: 12px; color: #858585;">Loading...</div>';

                    try {
                        // Use the iteration context to get the correct file version
                        // secondComparingIteration is the iteration where the comment was made (the "right" side of the diff)
                        // firstComparingIteration is the base iteration (the "left" side of the diff)
                        let commitId;
                        let iteration;

                        console.log(`Loading file preview for thread ${threadId}:`, {
                            firstIterationId,
                            secondIterationId,
                            useRight,
                            totalIterations: allIterations.length
                        });

                        // Choose iteration based on whether we're showing right (new) or left (old/deleted) file
                        // Right file: use secondComparingIteration (the target/right side)
                        // Left file: use firstComparingIteration (the base/left side)
                        const targetIterationId = useRight ? secondIterationId : firstIterationId;
                        const fallbackIterationId = useRight ? firstIterationId : secondIterationId;

                        if (targetIterationId !== null && targetIterationId !== undefined) {
                            iteration = allIterations.find(it => it.id === targetIterationId);
                            console.log(`Using ${useRight ? 'secondIterationId' : 'firstIterationId'} ${targetIterationId}, found:`, iteration?.id);
                        } else if (fallbackIterationId !== null && fallbackIterationId !== undefined) {
                            iteration = allIterations.find(it => it.id === fallbackIterationId);
                            console.log(`Using fallback ${useRight ? 'firstIterationId' : 'secondIterationId'} ${fallbackIterationId}, found:`, iteration?.id);
                        }

                        if (!iteration) {
                            // Last resort: use latest iteration
                            iteration = allIterations[allIterations.length - 1];
                            console.log('Using latest iteration as fallback:', iteration?.id);
                        }

                        commitId = iteration?.sourceRefCommit?.commitId || currentPRData.lastMergeSourceCommit?.commitId;
                        console.log(`Using commit ID: ${commitId}`);

                        if (!commitId) {
                            throw new Error('Could not determine commit version');
                        }

                        const fileContent = await ADOAPI.getFileContent(currentConfig, filePath, {
                            version: commitId,
                            versionType: 'commit'
                        });

                        // Split into lines and show context around the referenced lines
                        const lines = fileContent.split('\n');
                        const contextLines = 5; // Show 5 lines before and after
                        const startIdx = Math.max(0, startLine - contextLines - 1);
                        const endIdx = Math.min(lines.length, endLine + contextLines);

                        let html = '<pre>';
                        for (let i = startIdx; i < endIdx; i++) {
                            const lineNum = i + 1;
                            const rawLine = lines[i] || '';
                            const isInRange = lineNum >= startLine && lineNum <= endLine;

                            let lineContentHtml;
                            if (isInRange && startOffset !== undefined && endOffset !== undefined) {
                                // Apply character-level highlighting based on offsets
                                // Adjust offsets by -1 to align correctly (ADO offsets are 1-based)
                                const adjustedStartOffset = Math.max(0, startOffset - 1);
                                const adjustedEndOffset = Math.max(0, endOffset - 1);

                                if (lineNum === startLine && lineNum === endLine) {
                                    // Single line: highlight from startOffset to endOffset
                                    const before = ADOContent.escapeHtml(rawLine.substring(0, adjustedStartOffset));
                                    const highlighted = ADOContent.escapeHtml(rawLine.substring(adjustedStartOffset, adjustedEndOffset));
                                    const after = ADOContent.escapeHtml(rawLine.substring(adjustedEndOffset));
                                    lineContentHtml = `${before}<mark style="background: #ffe082; color: #000000; font-weight: 600;">${highlighted}</mark>${after}`;
                                } else if (lineNum === startLine) {
                                    // First line: highlight from startOffset to end
                                    const before = ADOContent.escapeHtml(rawLine.substring(0, adjustedStartOffset));
                                    const highlighted = ADOContent.escapeHtml(rawLine.substring(adjustedStartOffset));
                                    lineContentHtml = `${before}<mark style="background: #ffe082; color: #000000; font-weight: 600;">${highlighted}</mark>`;
                                } else if (lineNum === endLine) {
                                    // Last line: highlight from start to endOffset
                                    const highlighted = ADOContent.escapeHtml(rawLine.substring(0, adjustedEndOffset));
                                    const after = ADOContent.escapeHtml(rawLine.substring(adjustedEndOffset));
                                    lineContentHtml = `<mark style="background: #ffe082; color: #000000; font-weight: 600;">${highlighted}</mark>${after}`;
                                } else {
                                    // Middle lines: highlight entire line
                                    lineContentHtml = `<mark style="background: #ffe082; color: #000000; font-weight: 600;">${ADOContent.escapeHtml(rawLine)}</mark>`;
                                }
                            } else {
                                // No offset highlighting, just escape
                                lineContentHtml = ADOContent.escapeHtml(rawLine);
                            }

                            html += `<div class="file-preview-line"><span class="file-preview-line-number">${lineNum}</span><span class="file-preview-line-content">${lineContentHtml}</span></div>`;
                        }
                        html += '</pre>';

                        previewDiv.innerHTML = html;
                        previewDiv.setAttribute('data-loaded', 'true');
                    } catch (error) {
                        console.error('Failed to load file preview:', error);
                        previewDiv.innerHTML = `<div style="padding: 12px; color: #a4262c;">Failed to load file preview: ${ADOContent.escapeHtml(error.message)}</div>`;
                    }
                }
            }
        }

        function displayResults(prData, threads, iterations, config) {
            const resultsDiv = document.getElementById('results');

            // Count threads by status
            const statusCounts = threads.reduce((acc, thread) => {
                if (thread.isDeleted === true) {
                    acc.deleted = (acc.deleted || 0) + 1;
                } else if (thread.status === undefined) {
                    // Thread has no status field
                    acc.noStatus = (acc.noStatus || 0) + 1;
                } else {
                    // Thread has a status field (including "unknown" as a valid value)
                    const status = thread.status;
                    acc[status] = (acc[status] || 0) + 1;
                }
                return acc;
            }, {});

            // Get active thread counts per author (using all threads, not just filtered)
            const threadCounts = getActiveThreadCounts(allThreads);

            const prUrl = `${config.serverUrl}/${config.organization}/${config.project}/_git/${config.repository}/pullrequest/${prData.pullRequestId}`;

            // Generate status badge for title
            const statusBadgeClass = `badge-${prData.status}`;
            const statusLabel = prData.status.charAt(0).toUpperCase() + prData.status.slice(1);
            const draftBadge = prData.isDraft ? ' <span class="badge badge-draft">Draft</span>' : '';
            const statusBadgeHtml = `<span class="badge ${statusBadgeClass}">${statusLabel}</span>${draftBadge}`;

            // Generate PR author avatar for title
            let prAuthorAvatarHtml = '';
            if (prData.createdBy?.id) {
                const authorTitle = ADOContent.escapeHtml(prData.createdBy.displayName || 'Unknown');
                const cachedUrl = AvatarLoader.getCached(prData.createdBy.id);
                if (cachedUrl) {
                    prAuthorAvatarHtml = `<span class="avatar-wrapper pr-title-avatar"><img src="${cachedUrl}" alt="${authorTitle}" title="${authorTitle}" class="avatar"></span>`;
                } else {
                    prAuthorAvatarHtml = `<span class="avatar-wrapper pr-title-avatar"><div class="avatar-placeholder" title="${authorTitle}"></div><img data-user-id="${prData.createdBy.id}" alt="${authorTitle}" title="${authorTitle}" class="avatar avatar-pending"></span>`;
                }
            }

            let html = `
                <div class="pr-info">
                    <div class="pr-info-main">
                        <h2 style="display: flex; justify-content: space-between; align-items: center; gap: 16px;">
                            <span>${statusBadgeHtml} ${prAuthorAvatarHtml}PR #${prData.pullRequestId}: ${ADOContent.escapeHtml(prData.title)}</span>
                            <a href="${prUrl}" target="_blank" style="font-size: 14px; color: #0078d4; text-decoration: none; white-space: nowrap;" title="Open PR in Azure DevOps">üîó View in ADO</a>
                        </h2>
                        <p><strong>Created:</strong> ${ADOUI.formatDate(prData.creationDate)}</p>
                        ${prData.description ? `
                        <details style="margin-top: 15px;" open>
                            <summary style="cursor: pointer; color: #0078d4; font-weight: 600;">üìù Description</summary>
                            <div class="pr-description" style="margin-top: 10px; padding: 12px; background: #f8f8f8; border-radius: 4px; white-space: pre-wrap;">${ADOContent.processContent(prData.description)}</div>
                        </details>
                        ` : ''}
                        <div id="checksSection">${renderChecksSection()}</div>
                    </div>
                    <div class="pr-info-sidebar">
                        ${renderReviewersSection(prData.reviewers, threadCounts, prData.createdBy?.id)}
                        ${renderOtherAuthorsSection(allThreads, prData.reviewers, threadCounts, prData.createdBy?.id)}
                    </div>
                </div>

                <div class="stats">
                    <div class="stat">
                        <div class="stat-value">${threads.length}</div>
                        <div class="stat-label">Total Threads</div>
                    </div>
                    <div class="stat">
                        <div class="stat-value">${statusCounts.active || 0}</div>
                        <div class="stat-label">Active</div>
                    </div>
                    <div class="stat">
                        <div class="stat-value">${statusCounts.fixed || 0}</div>
                        <div class="stat-label">Fixed</div>
                    </div>
                    <div class="stat">
                        <div class="stat-value">${statusCounts.closed || 0}</div>
                        <div class="stat-label">Closed</div>
                    </div>
                    ${statusCounts.deleted ? `
                    <div class="stat">
                        <div class="stat-value" style="color: #a4262c;">${statusCounts.deleted}</div>
                        <div class="stat-label">Deleted</div>
                    </div>
                    ` : ''}
                    ${currentFileChangeStats ? `
                    <div class="stat" style="border-left: 2px solid #d1d1d1; padding-left: 20px; margin-left: 10px;">
                        <div class="stat-value">${currentFileChangeStats.totalFiles}</div>
                        <div class="stat-label">Files Changed</div>
                    </div>
                    <div class="stat">
                        <div class="stat-value" style="color: #107c10;">+${currentFileChangeStats.added}</div>
                        <div class="stat-label">Added</div>
                    </div>
                    <div class="stat">
                        <div class="stat-value" style="color: #0078d4;">~${currentFileChangeStats.modified}</div>
                        <div class="stat-label">Modified</div>
                    </div>
                    <div class="stat">
                        <div class="stat-value" style="color: #a4262c;">-${currentFileChangeStats.deleted}</div>
                        <div class="stat-label">Deleted</div>
                    </div>
                    <div id="lineStatsContainer" style="display: contents;">
                        <div class="stat">
                            <div class="stat-value" style="color: #605e5c; font-size: 12px;">‚è≥</div>
                            <div class="stat-label">Lines...</div>
                        </div>
                    </div>
                    ` : ''}
                </div>
            `;

            if (threads.length === 0) {
                html += '<div class="info">No threads found for this Pull Request.</div>';
            } else {
                html += '<div class="thread-container">';

                threads.forEach((thread, index) => {
                    const hasStatus = thread.status !== undefined;
                    const status = thread.status; // Keep actual status value (could be undefined, 'unknown', 'active', etc.)
                    const isThreadDeleted = thread.isDeleted === true;

                    const statusClass = ADOUI.getStatusBadgeClass(status, isThreadDeleted);
                    const statusText = ADOUI.getStatusText(status, isThreadDeleted);

                    const threadId = thread.id;
                    const threadUrl = ADOURL.buildThreadUrl(config, prData.pullRequestId, threadId, thread.threadContext?.filePath);
                    const apiEndpoint = `${config.serverUrl}/${config.organization}/${config.project}/_apis/git/repositories/${config.repository}/pullRequests/${prData.pullRequestId}/threads/${threadId}?api-version=6.0`;

                    const compactClass = isCompactView ? 'compact-view' : '';
                    const isChecked = selectedThreadIds.has(threadId) ? 'checked' : '';

                    // Build status dropdown (only when not in bulk mode and not deleted)
                    let statusControl = '';
                    if (!isBulkMode && !isThreadDeleted) {
                        if (hasStatus) {
                            // Thread has status: show "Change status:" with current selection and remove button
                            statusControl = `
                                <span class="thread-status-change">
                                    <select onchange="changeThreadStatus('${threadId}', this.value); this.blur();">
                                        <option value="">Change status...</option>
                                        <option value="active" ${status === 'active' ? 'selected' : ''}>Active</option>
                                        <option value="fixed" ${status === 'fixed' ? 'selected' : ''}>Resolved</option>
                                        <option value="closed" ${status === 'closed' ? 'selected' : ''}>Closed</option>
                                        <option value="wontFix" ${status === 'wontFix' ? 'selected' : ''}>Won't Fix</option>
                                        <option value="pending" ${status === 'pending' ? 'selected' : ''}>Pending</option>
                                        <option value="unknown" ${status === 'unknown' ? 'selected' : ''}>Unknown</option>
                                    </select>
                                    <button onclick="removeThreadStatus('${threadId}')" class="btn-secondary" style="margin-left: 5px; padding: 2px 8px; font-size: 12px;" title="Remove status from this thread">‚úï</button>
                                </span>
                            `;
                        } else {
                            // Thread has no status: show "Try force status:" with no selection
                            statusControl = `
                                <span class="thread-status-change">
                                    <select onchange="changeThreadStatus('${threadId}', this.value); this.blur();">
                                        <option value="" selected>Try force status...</option>
                                        <option value="active">Active</option>
                                        <option value="fixed">Resolved</option>
                                        <option value="closed">Closed</option>
                                        <option value="wontFix">Won't Fix</option>
                                        <option value="pending">Pending</option>
                                        <option value="unknown">Unknown</option>
                                    </select>
                                </span>
                            `;
                        }
                    }

                    html += `
                        <div class="thread ${compactClass}">
                            <div class="thread-header">
                                <span>
                                    ${isBulkMode ? `<input type="checkbox" class="thread-checkbox" id="thread-checkbox-${threadId}" data-thread-id="${threadId}" ${isChecked} onchange="toggleThreadSelection('${threadId}')">` : ''}
                                    Thread #${index + 1}
                                    <a href="${threadUrl}" target="_blank" style="font-size: 13px; margin-left: 8px; color: #0078d4; text-decoration: none;" title="Open thread in Azure DevOps (${thread.threadContext ? 'files tab' : 'overview tab'})">üîó</a>
                                </span>
                                <span>
                                    <button class="raw-json-toggle" onclick="ADOUI.toggleRawJson('thread-${index}')">View Raw JSON</button>
                                    ${hasStatus ? `<span class="badge ${statusClass}">${statusText}</span>` : ''}
                                    ${statusControl}
                                </span>
                            </div>
                    `;

                    // Add raw JSON container
                    const jsonString = JSON.stringify(thread, null, 2);
                    html += `
                        <div id="thread-${index}" class="raw-json-container">
                            <div style="margin-bottom: 10px; color: #9cdcfe;">
                                <strong>API Endpoint:</strong><br>
                                <a href="${apiEndpoint}" target="_blank" class="api-link" title="Open in new tab (requires authentication)">${apiEndpoint}</a>
                            </div>
                            <pre>${ADOContent.escapeHtml(jsonString)}</pre>
                        </div>
                    `;

                    // Show thread context if it's a code comment
                    // threadContext has file path and line info
                    // pullRequestThreadContext has iteration context
                    if (thread.threadContext) {
                        const ctx = thread.threadContext;

                        // Determine which file location to use (rightFile for new code, leftFile for deleted code)
                        const useRight = !!ctx.rightFileStart;
                        const fileStart = useRight ? ctx.rightFileStart : ctx.leftFileStart;
                        const fileEnd = useRight ? ctx.rightFileEnd : ctx.leftFileEnd;
                        const lineInfo = fileStart ? ` (Line ${fileStart.line}${fileEnd && fileEnd.line !== fileStart.line ? `-${fileEnd.line}` : ''})` : '';

                        // If we have line information, make the file path a collapsible preview header
                        if (ctx.filePath && fileStart) {
                            const iterationId = thread.pullRequestThreadContext?.iterationContext?.firstComparingIteration;
                            const secondIterationId = thread.pullRequestThreadContext?.iterationContext?.secondComparingIteration;
                            const startOffset = fileStart.offset || 0;
                            const endOffset = fileEnd?.offset || 0;

                            // Log iteration context for debugging
                            console.log(`Thread ${threadId} iteration context:`, {
                                firstComparingIteration: iterationId,
                                secondComparingIteration: secondIterationId,
                                useRight: useRight,
                                fullContext: thread.pullRequestThreadContext?.iterationContext
                            });

                            html += `
                                <div class="file-preview">
                                    <div class="file-preview-header" onclick="toggleFilePreview('${threadId}', '${ADOContent.escapeHtml(ctx.filePath)}', ${fileStart.line}, ${fileEnd ? fileEnd.line : fileStart.line}, ${iterationId !== undefined ? iterationId : 'null'}, ${secondIterationId !== undefined ? secondIterationId : 'null'}, ${startOffset}, ${endOffset}, ${useRight})">
                                        <span>‚ñ∂</span>
                                        <span><strong>File:</strong> ${ADOContent.escapeHtml(ctx.filePath || 'N/A')}${lineInfo}${useRight ? '' : ' <span style="color: #a4262c; font-size: 11px;">(deleted)</span>'} - Click to show file preview</span>
                                    </div>
                                    <div id="file-preview-${threadId}" class="file-preview-content"></div>
                                </div>
                            `;
                        } else {
                            // No line information, just show as regular context
                            html += `
                                <div class="thread-context">
                                    <strong>File:</strong> ${ADOContent.escapeHtml(ctx.filePath || 'N/A')}${lineInfo}
                                </div>
                            `;
                        }
                    }

                    // Show all comments in the thread
                    if (thread.comments && thread.comments.length > 0) {
                        thread.comments.forEach((comment, commentIdx) => {
                            // Check if this is a code suggestion
                            const isCodeSuggestion = comment.content?.includes('```suggestion');

                            // Remove suggestion block from content before processing to avoid duplicate display
                            let contentToProcess = comment.content;
                            if (isCodeSuggestion) {
                                contentToProcess = contentToProcess.replace(/```suggestion\n[\s\S]*?\n```/g, '');
                            }

                            let resolvedContent = ADOContent.processContent(contentToProcess);

                            // Check if content is essentially empty (just whitespace or empty code blocks)
                            const contentStripped = resolvedContent.replace(/<pre><code><\/code><\/pre>/g, '').trim();
                            const hasRealContent = contentStripped.length > 0;

                            // Get iteration links for this comment
                            const filePath = thread.threadContext?.filePath || null;
                            const iterationLinks = getIterationLinksForComment(
                                comment,
                                thread,
                                iterations,
                                config,
                                prData,
                                filePath
                            );

                            // Check if comment is deleted
                            const isDeleted = comment.isDeleted === true;

                            // Determine comment type
                            const commentType = comment.commentType || 'unknown';
                            let commentTypeLabel = '';
                            let commentClass = '';
                            let commentTypeBadgeClass = '';

                            if (isDeleted) {
                                commentTypeLabel = 'Deleted';
                                commentTypeBadgeClass = 'comment-type-deleted';
                            } else {
                                switch(commentType) {
                                    case 'system':
                                    case 3:
                                        commentTypeLabel = 'System';
                                        commentClass = 'system-comment';
                                        commentTypeBadgeClass = 'comment-type-system';
                                        break;
                                    case 'codeChange':
                                    case 2:
                                        commentTypeLabel = 'Code Change';
                                        commentClass = 'code-change-comment';
                                        commentTypeBadgeClass = 'comment-type-code-change';
                                        break;
                                    case 'text':
                                    case 1:
                                        commentTypeLabel = 'Text';
                                        commentTypeBadgeClass = 'comment-type-text';
                                        break;
                                    default:
                                        commentTypeLabel = 'Unknown';
                                        break;
                                }
                            }

                            // Generate avatar HTML for comment author
                            let commentAvatarHtml = '';
                            if (comment.author?.id) {
                                const authorTitle = ADOContent.escapeHtml(comment.author.displayName || 'Unknown');
                                const isCommentByPRAuthor = comment.author.id === prData.createdBy?.id;
                                const authorBadge = isCommentByPRAuthor ? `<span class="author-badge" title="PR Author">‚òÖ</span>` : '';
                                const cachedUrl = AvatarLoader.getCached(comment.author.id);
                                if (cachedUrl) {
                                    commentAvatarHtml = `<div class="avatar-wrapper"><img src="${cachedUrl}" alt="${authorTitle}" title="${authorTitle}" class="avatar">${authorBadge}</div>`;
                                } else {
                                    commentAvatarHtml = `<div class="avatar-wrapper"><div class="avatar-placeholder" title="${authorTitle}"></div><img data-user-id="${comment.author.id}" alt="${authorTitle}" title="${authorTitle}" class="avatar avatar-pending">${authorBadge}</div>`;
                                }
                            }

                            html += `
                                <div class="comment ${commentClass}">
                                    <div class="comment-header">
                                        <span class="comment-author-info">
                                            ${commentAvatarHtml}
                                            <span class="comment-date">${ADOUI.formatDate(comment.publishedDate)}</span>
                                            ${iterationLinks.completeLink ? `
                                            <span class="code-links">
                                                ${iterationLinks.beforeLink ? `<a href="${iterationLinks.beforeLink}" target="_blank" class="comment-link" title="Diff from first update to last update before this comment">‚Üê</a>` : ''}
                                                ${iterationLinks.afterLink ? `<a href="${iterationLinks.afterLink}" target="_blank" class="comment-link" title="Diff from first update after this comment to latest">‚Üí</a>` : ''}
                                                <a href="${iterationLinks.completeLink}" target="_blank" class="comment-link" title="Complete diff from first to latest update">‚Üî</a>
                                            </span>
                                            ` : ''}
                                            ${isDeleted || commentTypeLabel !== 'Text' ? `<span class="comment-type-badge ${commentTypeBadgeClass}">${commentTypeLabel}</span>` : ''}
                                        </span>
                                    </div>
                                    ${hasRealContent ? `<div class="comment-content">${resolvedContent}</div>` : ''}

                                    ${isCodeSuggestion ? `<div id="code-suggestion-${threadId}-${commentIdx}" data-thread-id="${threadId}" data-comment-idx="${commentIdx}"><div style="padding: 12px; color: #858585;">Loading code suggestion...</div></div>` : ''}
                                </div>
                            `;
                        });
                    }

                    html += '</div>';
                });

                html += '</div>';
            }

            resultsDiv.innerHTML = html;

            // Load avatars
            AvatarLoader.loadPending();

            // Fetch PR checks (statuses, policies) asynchronously
            fetchPRChecks(config, prData);

            // Fetch line stats asynchronously
            fetchLineStatsAsync(config, prData);

            // Asynchronously load code suggestions
            setTimeout(async () => {
                try {
                    const suggestionDivs = resultsDiv.querySelectorAll('[id^="code-suggestion-"]');
                    console.log(`Found ${suggestionDivs.length} code suggestion divs to process`);

                    for (const div of suggestionDivs) {
                        try {
                            const threadId = parseInt(div.dataset.threadId);
                            const commentIdx = parseInt(div.dataset.commentIdx);
                            console.log(`Processing code suggestion for thread ${threadId}, comment ${commentIdx}`);

                            const thread = threads.find(t => t.id === threadId);
                            if (!thread) {
                                console.warn(`Thread ${threadId} not found`);
                                div.innerHTML = '<div style="padding: 12px; color: #a4262c;">Error: Thread not found</div>';
                                continue;
                            }

                            if (!thread.comments || !thread.comments[commentIdx]) {
                                console.warn(`Comment ${commentIdx} not found in thread ${threadId}`);
                                div.innerHTML = '<div style="padding: 12px; color: #a4262c;">Error: Comment not found</div>';
                                continue;
                            }

                            const comment = thread.comments[commentIdx];
                            const suggestionHtml = await renderCodeSuggestion(thread, comment);
                            if (suggestionHtml) {
                                div.innerHTML = suggestionHtml;
                                console.log(`Successfully loaded code suggestion for thread ${threadId}`);
                            } else {
                                console.log(`No suggestion HTML returned for thread ${threadId}`);
                                div.innerHTML = ''; // Remove loading message if no suggestion
                            }
                        } catch (error) {
                            console.error('Error processing individual code suggestion:', error);
                            div.innerHTML = `<div style="padding: 12px; color: #a4262c;">Error loading suggestion: ${ADOContent.escapeHtml(error.message)}</div>`;
                        }
                    }
                } catch (error) {
                    console.error('Error in code suggestion loading:', error);
                }
            }, 0);
        }

        // Sidebar resize functionality
        (function initSidebarResize() {
            const resizeHandle = document.getElementById('resizeHandle');
            const sidebar = document.querySelector('.sidebar');
            let isResizing = false;
            let startX = 0;
            let startWidth = 0;

            resizeHandle.addEventListener('mousedown', (e) => {
                isResizing = true;
                startX = e.clientX;
                startWidth = sidebar.offsetWidth;
                document.body.style.cursor = 'col-resize';
                document.body.style.userSelect = 'none';
                e.preventDefault();
            });

            document.addEventListener('mousemove', (e) => {
                if (!isResizing) return;

                const diff = e.clientX - startX;
                const newWidth = startWidth + diff;

                // Apply min/max constraints
                if (newWidth >= 200 && newWidth <= 600) {
                    sidebar.style.width = newWidth + 'px';
                }
            });

            document.addEventListener('mouseup', () => {
                if (isResizing) {
                    isResizing = false;
                    document.body.style.cursor = '';
                    document.body.style.userSelect = '';
                }
            });
        })();
    </script>
</body>
</html>
